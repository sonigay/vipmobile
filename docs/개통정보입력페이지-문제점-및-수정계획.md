# 개통정보입력페이지 문제점 및 수정 계획

## 📋 개요
직영점모드와 고객모드 개통정보입력페이지의 문제점을 파악하고 수정 계획을 수립한 문서입니다.

---

## 🔍 현재 구조 분석

### 컴포넌트 구조
- **파일**: `src/components/direct/OpeningInfoPage.js`
- **공통 사용**: 직영점모드와 고객모드 모두 동일한 컴포넌트 사용
- **모드 구분**: `mode` prop으로 구분 (`'customer'` | `'directStore'` | `'management'`)

### Props 구조
```javascript
{
  initialData,        // 선택한 상품 정보
  onBack,            // 뒤로가기 핸들러
  loggedInStore,     // 직영점모드: 로그인한 매장 정보
  mode,              // 모드 구분
  customerInfo,      // 고객모드: 로그인한 고객 정보
  selectedStore,     // 고객모드: 선택한 매장 정보
  saveToSheet        // 저장 대상 시트 ('purchaseQueue' | 'salesReport')
}
```

---

## 🚨 발견된 문제점

### 문제 1: 매장정보 표시 불일치

#### 증상
- 고객모드에서 선택한 매장 정보가 표시되어야 하는데, 어느 순간 접속자(로그인한 매장) 정보가 들어가 있음

#### 원인 분석
1. **매장정보 표시 로직** (969-991줄)
   ```javascript
   {(mode === 'customer' ? selectedStore : loggedInStore) && (
     // 매장 정보 표시
     <strong>업체명:</strong> {(mode === 'customer' ? selectedStore : loggedInStore)?.name || ''}
   )}
   ```
   - 코드 자체는 올바르게 작성되어 있음
   - 하지만 `selectedStore`가 `null`이거나 `undefined`일 때 `loggedInStore`가 표시될 수 있음

2. **사전승낙서 마크 로드** (352-370줄)
   ```javascript
   const currentStore = mode === 'customer' ? selectedStore : loggedInStore;
   ```
   - 여기서는 올바르게 처리하고 있음

3. **저장 시 매장 정보** (591-600줄)
   ```javascript
   const currentStore = mode === 'customer' ? selectedStore : loggedInStore;
   ```
   - 저장 시에도 올바르게 처리하고 있음

#### 문제점
- `selectedStore`가 제대로 전달되지 않거나, `null`/`undefined`일 때 fallback으로 `loggedInStore`가 사용될 수 있음
- 고객모드에서 `selectedStore`가 없으면 매장 정보를 표시하지 않아야 하는데, 조건문이 `&&`로 되어 있어서 `selectedStore`가 없으면 아무것도 표시하지 않음 (이건 맞음)
- 하지만 실제로는 `selectedStore`가 있는데도 `loggedInStore`가 표시되는 경우가 있다면, props 전달 과정에서 문제가 있을 수 있음

#### 수정 방안
1. **매장정보 표시 조건 강화**
   - 고객모드일 때는 반드시 `selectedStore`가 있어야만 매장 정보 표시
   - `selectedStore`가 없으면 경고 메시지 표시

2. **Props 검증 추가**
   - 컴포넌트 마운트 시 props 검증
   - 고객모드인데 `selectedStore`가 없으면 경고 로그 출력

---

### 문제 2: 금액 계산 로직 분산 및 비동기 상태 참조 문제

#### 증상
- 가입유형, 약정유형, 요금제 변경 시 금액이 제대로 계산되지 않음
- 계산 값이 최신 상태를 반영하지 못함

#### 원인 분석

1. **가입유형 변경 시** (`OpeningInfoFormSection.js`)
   - `handleOpeningTypeChange` 함수에서 가격 정책 조회
   - `formData.contractType`을 참조하는데, 이 값이 최신 상태가 아닐 수 있음

2. **약정유형 변경 시** (`ContractInfoFormSection.js`)
   - `handleContractTypeChange` 함수에서 가격 정책 조회
   - `formData.openingType`, `formData.plan`을 참조하는데, 최신 상태가 아닐 수 있음

3. **요금제 변경 시** (`OpeningInfoPage.js` 1101-1181줄)
   - 요금제 Autocomplete `onChange`에서 가격 정책 조회
   - `formData.contractType`, `formData.openingType`을 참조하는데, 최신 상태가 아닐 수 있음

#### 문제점
- **비동기 상태 참조**: React의 상태 업데이트는 비동기이므로, 여러 필드를 연속으로 변경하면 이전 상태를 참조할 수 있음
- **중복 로직**: 가격 정책 조회 로직이 3곳에 반복됨
- **의존성 누락**: `useEffect`로 관련 필드 변경 시 자동 재계산하는 로직이 없음

#### 수정 방안
1. **통합 가격 정보 업데이트 함수 생성**
   - 가격 정책 조회 로직을 하나의 함수로 통합
   - `openingType`, `contractType`, `plan`을 모두 파라미터로 받아서 처리

2. **useEffect로 자동 재계산**
   - 관련 필드(`openingType`, `contractType`, `plan`, `selectedPlanGroup`) 변경 시 자동으로 가격 정보 업데이트
   - `useEffect`의 의존성 배열에 모든 관련 필드 포함

3. **상태 업데이트 순서 보장**
   - `formData` 업데이트와 가격 정보 업데이트를 분리
   - 가격 정보 업데이트는 항상 최신 `formData` 값을 참조하도록 수정

---

### 문제 3: 계산 필드 의존성 체인 복잡성

#### 증상
- 한 필드를 변경했을 때 예상치 못한 다른 필드가 재계산됨
- 또는 필요한 재계산이 누락됨

#### 원인 분석

1. **의존성 체인**
   ```
   publicSupport, storeSupportWithAddon, storeSupportWithoutAddon
   → calculateDynamicStoreSupport
   → installmentPrincipal
   → installmentFeeResult
   → totalMonthlyFeeResult
   ```

2. **useMemo 의존성**
   - 각 계산값이 `useMemo`로 메모이제이션되어 있음
   - 의존성 배열이 정확하지 않으면 재계산이 누락될 수 있음

#### 수정 방안
1. **의존성 명확화**
   - 각 계산값의 의존성을 명확히 문서화
   - `useMemo`의 의존성 배열을 정확히 설정

2. **계산 순서 보장**
   - 계산 순서를 명확히 정의
   - 하위 계산값이 상위 계산값에 의존하도록 구조화

---

### 문제 4: 금액종합안내 섹션 표시 불일치

#### 증상
- 요금 금액 섹션과 최종 합계 섹션에서 다른 값이 표시됨

#### 원인 분석
- 요금 금액 섹션: `planBasicFee` (할인 전) 표시
- 최종 합계 섹션: `planFeeResult` (할인 후) 표시
- 할인 항목을 별도로 표시하지만, 계산 값과 표시 값이 일치하지 않을 수 있음

#### 수정 방안
1. **표시 값 일관성 확보**
   - 요금 금액 섹션에서도 할인 후 값(`planFeeResult`)을 표시하거나
   - 할인 전 값과 할인 후 값을 명확히 구분하여 표시

2. **할인 계산 검증**
   - 표시된 할인 금액이 실제 계산 값과 일치하는지 검증 로직 추가

---

## 📝 수정 계획

### Phase 1: 매장정보 문제 수정

1. **Props 검증 강화**
   ```javascript
   useEffect(() => {
     if (mode === 'customer' && !selectedStore) {
       console.warn('고객모드인데 selectedStore가 없습니다.');
     }
   }, [mode, selectedStore]);
   ```

2. **매장정보 표시 조건 개선**
   ```javascript
   // 고객모드일 때는 반드시 selectedStore가 있어야 함
   const shouldShowStoreInfo = mode === 'customer' 
     ? selectedStore 
     : loggedInStore;
   
   {shouldShowStoreInfo && (
     // 매장 정보 표시
   )}
   ```

3. **currentStore 변수 통일**
   - 모든 곳에서 동일한 `currentStore` 변수 사용
   - `useMemo`로 메모이제이션하여 일관성 보장

---

### Phase 2: 금액 계산 로직 통합

1. **통합 가격 정보 업데이트 함수 생성**
   ```javascript
   const updatePriceInfo = useCallback(async (
     openingType,
     contractType,
     planGroup,
     modelId
   ) => {
     // 가격 정책 조회
     // 이통사지원금, 대리점지원금 업데이트
   }, [selectedCarrier, initialData]);
   ```

2. **useEffect로 자동 재계산**
   ```javascript
   useEffect(() => {
     if (formData.openingType && formData.contractType && selectedPlanGroup) {
       updatePriceInfo(
         formData.openingType,
         formData.contractType,
         selectedPlanGroup,
         initialData?.id
       );
     }
   }, [formData.openingType, formData.contractType, selectedPlanGroup, updatePriceInfo]);
   ```

3. **개별 핸들러 수정**
   - `OpeningInfoFormSection`: 가입유형 변경 시 `updatePriceInfo` 호출
   - `ContractInfoFormSection`: 약정유형 변경 시 `updatePriceInfo` 호출
   - `OpeningInfoPage`: 요금제 변경 시 `updatePriceInfo` 호출

---

### Phase 3: 계산 의존성 명확화

1. **의존성 문서화**
   - 각 계산값의 의존성을 주석으로 명시

2. **useMemo 의존성 배열 정확히 설정**
   - 모든 의존성을 빠짐없이 포함

---

### Phase 4: UI 표시 일관성 확보

1. **금액종합안내 섹션 수정**
   - 할인 전/후 값을 명확히 구분하여 표시
   - 계산 값과 표시 값이 일치하는지 검증

---

## ✅ 수정 우선순위

1. **높음**: 매장정보 표시 문제 (사용자 경험에 직접 영향)
2. **높음**: 금액 계산 로직 통합 (핵심 기능)
3. **중간**: 계산 의존성 명확화 (안정성)
4. **낮음**: UI 표시 일관성 (사용성)

---

## 🔧 수정 시 주의사항

1. **현재 모습과 위치 유지**
   - UI 레이아웃과 스타일은 변경하지 않음
   - 필드 위치와 표시 방식은 그대로 유지

2. **기존 기능 보존**
   - 기존에 작동하던 기능은 그대로 유지
   - 새로운 기능 추가는 최소화

3. **점진적 수정**
   - 한 번에 모든 것을 바꾸지 않고 단계적으로 수정
   - 각 단계마다 테스트

---

**작성일**: 2024년
**대상 파일**: `src/components/direct/OpeningInfoPage.js`

