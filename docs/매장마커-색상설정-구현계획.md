# 매장 마커 색상 설정 기능 구현 계획

## 📋 요구사항 분석

### 목표
관리자모드에서 지도상에 표시되는 매장 마커의 색상을 코드별로 구분하여 표시하고, 사용자가 각 코드별 색상을 자유롭게 설정할 수 있도록 함.

### 핵심 기능
1. **코드 정보 수집**: 폰클출고처데이터 시트의 H열(7인덱스)에서 코드 정보 가져오기
2. **유니크 코드 추출**: "VIP(경수)", "VIP(호남)" 등 유니크한 코드 값만 추출
3. **색상 설정 UI**: 메인헤더에 색상 설정 버튼 추가 및 모달 구현
4. **색상 저장**: 사용자별 색상 설정 저장
5. **마커 색상 적용**: 관리자모드에서 코드별 색상으로 마커 표시

---

## 🔍 현재 코드 구조 분석

### 1. 데이터 구조

#### 서버 측 (server/index.js)
- **시트명**: `폰클출고처데이터` (STORE_SHEET_NAME)
- **코드 위치**: H열 (인덱스 7)
- **현재 처리**: 
  ```javascript
  // server/index.js:4304
  code: (foundStoreRow[7] || '').toString().trim(),  // H열(7인덱스): 코드
  ```
- **store 객체에 포함**: `storeDetails`에 `code` 필드로 포함되어 클라이언트로 전달됨

#### 클라이언트 측 (src/components/Map.js)
- **마커 생성 함수**: `createMarkerIcon(store)`
- **현재 색상 로직**: 
  - 요청점: `#ff9800` (주황색)
  - 사무실: `#21f8fb` (청록색)
  - 선택된 매장: `#2196f3` (파란색)
  - 로그인한 매장: `#9c27b0` (보라색)
  - 일반 매장: 출고일 기준 색상 (초록/노랑/주황/빨강)
- **관리자모드 구분**: `isAgentMode` prop으로 확인

### 2. 헤더 구조 (src/components/Header.js)
- **위치**: `src/components/Header.js`
- **현재 버튼들**:
  - 모드 전환 버튼 (SwapHorizIcon)
  - 푸시 알림 설정 버튼 (NotificationsIcon)
  - 업데이트 확인 버튼
  - 지도 재고 노출 옵션 설정 버튼 (M 권한자만, MapIcon)
  - 관리자모드 메뉴 (MenuIcon)
- **버튼 추가 위치**: 기존 버튼들과 함께 `Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}` 내부

### 3. App.js 구조
- **관리자모드 상태**: `isAgentMode` state
- **Map 컴포넌트 전달**: `isAgentMode={isAgentMode}` prop 전달
- **Header 컴포넌트**: `isAgentMode={isAgentMode}` prop 전달

---

## ✅ 확인 완료 사항

### 1. 색상 저장 위치
**결정**: 구글시트에 저장
- **시트명**: `관리자모드_마커색상설정` (새로 생성)
- **구조**: 사용자별로 색상 설정 저장
- **장점**: 모든 기기에서 동기화, 관리 용이
- **구현**: 서버 API를 통해 구글시트에 저장/조회

### 2. 색상 구분 옵션 (라디오 버튼 - 단일 선택)
**결정**: 여러 옵션 중 하나만 선택 가능
- **옵션 종류**:
  1. **기존 로직** (출고일 기준 색상) - 선택 시 기존 로직 유지
  2. **코드별** - H열(7인덱스): 코드
  3. **사무실별** - D열(3인덱스): 사무실
  4. **소속별** - E열(4인덱스): 소속
  5. **담당자별** - F열(5인덱스): 담당자
- **동작**: 선택된 옵션 하나에 따라 해당 값의 유니크 목록을 가져와서 색상 설정
- **선택 방식**: 라디오 버튼으로 단일 선택만 가능

### 3. 기본 색상 설정
**결정**: 구분이 잘되도록 권장 색상 팔레트 사용
- **색상 팔레트**: Material-UI 색상 또는 구분이 잘되는 색상 조합
- **할당 방식**: 유니크 값 목록 순서대로 순차 할당
- **기본 색상 목록** (20개):
  ```javascript
  const DEFAULT_COLOR_PALETTE = [
    '#f44336', // 빨강
    '#2196f3', // 파랑
    '#4caf50', // 초록
    '#ff9800', // 주황
    '#9c27b0', // 보라
    '#00bcd4', // 청록
    '#ffeb3b', // 노랑
    '#e91e63', // 분홍
    '#795548', // 갈색
    '#607d8b', // 청회색
    '#3f51b5', // 남색
    '#009688', // 청록
    '#ff5722', // 주황빨강
    '#673ab7', // 보라
    '#cddc39', // 연두
    '#ffc107', // 호박색
    '#00acc1', // 청록
    '#8bc34a', // 연두
    '#ff6f00', // 주황
    '#5c6bc0'  // 남보라
  ];
  ```

### 4. 값이 없는 매장 처리
**결정**: 특정 색상 지정
- **기본 색상**: `#9e9e9e` (회색) 또는 `#757575` (어두운 회색)
- **우선순위**: 요청점/사무실/선택된 매장/로그인한 매장 > 선택된 옵션별 색상 > 값 없는 매장 (회색) > 기존 출고일 기준 색상

### 5. 색상 설정 권한
**결정**: 모든 관리자모드 사용자
- **조건**: `isAgentMode === true`인 모든 사용자
- **제한 없음**: 특정 권한 레벨 제한 없이 모든 관리자모드 사용자가 설정 가능

---

## 📐 구현 계획

### Phase 1: 구글시트 구조 설계 및 데이터 수집

#### 1.1 구글시트 구조 설계

**시트명**: `관리자모드_마커색상설정` (새로 생성)

**헤더 구조**:
```javascript
const HEADERS_MARKER_COLOR_SETTINGS = [
  '사용자ID',      // A열: 사용자 ID (x-user-id)
  '옵션타입',      // B열: 옵션 타입 ('code', 'office', 'department', 'manager', 'selected')
  '값',            // C열: 옵션 값 (예: "VIP(경수)", "서울사무실", "경수팀", "홍길동")
  '색상',          // D열: HEX 색상 코드 (예: "#ff5722")
  '등록일시',      // E열: ISO 형식 날짜
  '수정일시'       // F열: ISO 형식 날짜
];
```

**데이터 구조 예시**:
| 사용자ID | 옵션타입 | 값 | 색상 | 등록일시 | 수정일시 |
|---------|---------|-----|------|----------|----------|
| 01012345678 | code | VIP(경수) | #f44336 | 2026-01-18T10:00:00Z | 2026-01-18T10:00:00Z |
| 01012345678 | code | VIP(호남) | #2196f3 | 2026-01-18T10:00:00Z | 2026-01-18T10:00:00Z |
| 01012345678 | office | 서울사무실 | #4caf50 | 2026-01-18T10:00:00Z | 2026-01-18T10:00:00Z |
| 01012345678 | department | 경수팀 | #ff9800 | 2026-01-18T10:00:00Z | 2026-01-18T10:00:00Z |
| 01012345678 | manager | 홍길동 | #9c27b0 | 2026-01-18T10:00:00Z | 2026-01-18T10:00:00Z |
| 01012345678 | enabled | code,office | - | 2026-01-18T10:00:00Z | 2026-01-18T10:00:00Z |

**특징**:
- 사용자별로 독립적인 색상 설정 저장
- 옵션 타입별로 색상 설정 가능
- 활성화된 옵션은 별도 행에 저장 (옵션타입='enabled', 값='code,office' 형식)
- 등록일시/수정일시로 변경 이력 추적 가능

---

#### 1.2 유니크 값 목록 API 구현

**엔드포인트**: `GET /api/stores/unique-values`

**구현 위치**: `server/index.js`

**파라미터**:
- `type`: 옵션 타입 ('code', 'office', 'department', 'manager')

**구현 내용**:
```javascript
// GET /api/stores/unique-values?type=code
app.get('/api/stores/unique-values', async (req, res) => {
  try {
    const { type } = req.query; // 'code', 'office', 'department', 'manager'
    
    if (!type || !['code', 'office', 'department', 'manager'].includes(type)) {
      return res.status(400).json({ success: false, error: '올바른 타입이 필요합니다.' });
    }

    const { sheets, SPREADSHEET_ID } = createSheetsClient();
    
    // 타입에 따라 컬럼 인덱스 결정
    const columnIndexMap = {
      'code': 7,        // H열: 코드
      'office': 3,     // D열: 사무실
      'department': 4, // E열: 소속
      'manager': 5     // F열: 담당자
    };
    
    const columnIndex = columnIndexMap[type];
    const columnLetter = String.fromCharCode(65 + columnIndex); // A=0, B=1, ...
    
    const response = await sheets.spreadsheets.values.get({
      spreadsheetId: SPREADSHEET_ID,
      range: `폰클출고처데이터!${columnLetter}:${columnLetter}`
    });
    
    const rows = response.data.values || [];
    const values = new Set();
    
    // 헤더 제외하고 데이터 처리
    rows.slice(1).forEach(row => {
      const value = (row[0] || '').toString().trim();
      if (value) {
        values.add(value);
      }
    });
    
    // 배열로 변환 및 정렬
    const uniqueValues = Array.from(values).sort();
    
    res.json({ success: true, type, values: uniqueValues });
  } catch (error) {
    console.error('유니크 값 목록 조회 오류:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});
```

**캐싱**: 30초 TTL 적용

---

### Phase 2: 색상 설정 UI 구현

#### 2.1 헤더에 색상 설정 버튼 추가 (src/components/Header.js)

**위치**: 기존 버튼들과 함께 추가
```javascript
// src/components/Header.js
// 관리자모드일 때만 표시
{isAgentMode && (
  <Tooltip title="마커 색상 설정">
    <IconButton
      color="inherit"
      onClick={() => setMarkerColorDialogOpen(true)}
      sx={{ 
        border: '1px solid rgba(255,255,255,0.3)',
        borderRadius: 1
      }}
    >
      <PaletteIcon />
    </IconButton>
  </Tooltip>
)}
```

**필요한 import**:
```javascript
import PaletteIcon from '@mui/icons-material/Palette';
```

**상태 관리**:
```javascript
const [markerColorDialogOpen, setMarkerColorDialogOpen] = useState(false);
```

---

#### 2.2 색상 설정 모달 컴포넌트 생성

**파일**: `src/components/MarkerColorSettingsModal.js` (새로 생성)

**기능**:
1. **옵션 선택 라디오 버튼** (기존 로직, 코드별, 사무실별, 소속별, 담당자별) - 단일 선택만 가능
2. 선택된 옵션의 유니크 값 목록 표시
3. 각 값별 색상 선택기 (TextField type="color")
4. 색상 미리보기
5. 저장/취소 버튼

**UI 구조**:
```
┌──────────────────────────────────────────────┐
│ 마커 색상 설정                      [X]     │
├──────────────────────────────────────────────┤
│                                              │
│ 색상 구분 옵션 선택:                         │
│ ⦿ 기존 로직 (출고일 기준)                    │
│ ○ 코드별                                    │
│ ○ 사무실별                                  │
│ ○ 소속별                                    │
│ ○ 담당자별                                  │
│                                              │
│ ────────────────────────────────────────    │
│                                              │
│ [선택된 옵션의 색상 설정]                   │
│ VIP(경수)    [색상선택] [미리보기]          │
│ VIP(호남)    [색상선택] [미리보기]          │
│ ...                                          │
│                                              │
│ [기본값으로 초기화]  [취소]  [저장]         │
└──────────────────────────────────────────────┘
```

**상태 관리**:
```javascript
const [selectedOption, setSelectedOption] = useState('default'); // 'default', 'code', 'office', 'department', 'manager'

const [colorSettings, setColorSettings] = useState({
  code: {},           // { "VIP(경수)": "#f44336", ... }
  office: {},         // { "서울사무실": "#2196f3", ... }
  department: {},     // { "경수팀": "#4caf50", ... }
  manager: {}        // { "홍길동": "#ff9800", ... }
});

const [uniqueValues, setUniqueValues] = useState({
  code: [],
  office: [],
  department: [],
  manager: []
});
```

**색상 저장 형식** (구글시트):
- 사용자별로 행 단위로 저장
- 각 행: [사용자ID, 옵션타입, 값, 색상, 등록일시, 수정일시]
- 선택된 옵션: [사용자ID, 'selected', 'code', '', 등록일시, 수정일시] (단일 옵션만 저장, 'default', 'code', 'office', 'department', 'manager' 중 하나)
- 조회 시 사용자ID로 필터링하여 Map 형태로 변환

**서버 API**:
- `GET /api/stores/unique-values?type=code`: 유니크 값 목록 조회
- `GET /api/marker-color-settings`: 현재 사용자의 색상 설정 조회
- `POST /api/marker-color-settings`: 색상 설정 저장/업데이트

---

### Phase 3: 마커 색상 적용

#### 3.1 Map.js 수정 (src/components/Map.js)

**수정 위치**: `createMarkerIcon` 함수 내부

**로직 순서**:
1. 관리자모드 확인 (`isAgentMode`)
2. 코드별 색상 설정 확인 (로컬스토리지에서 읽기)
3. 코드별 색상이 있으면 해당 색상 사용
4. 코드별 색상이 없으면 기존 로직 유지

**우선순위** (기존 로직 유지):
1. 요청점 (최우선) - `#ff9800`
2. 사무실 - `#21f8fb`
3. 선택된 매장 - `#2196f3`
4. 로그인한 매장 - `#9c27b0`
5. **선택된 옵션별 색상** (새로 추가) - 구글시트에서 조회, 선택된 단일 옵션에 따라
6. **값 없는 매장** (새로 추가) - `#9e9e9e` (회색)
7. 기존 출고일 기준 색상 (fallback, 'default' 옵션이 선택된 경우)

**구현 예시**:
```javascript
// createMarkerIcon 함수 내부
// App.js에서 colorSettings와 selectedOption을 state로 관리하고 Map 컴포넌트에 prop으로 전달

// 일반 매장 색상 결정 부분 (818번째 줄 근처)
else {
  // 선택된 옵션별 색상 확인 (관리자모드에서만)
  if (isAgentMode && selectedOption && selectedOption !== 'default') {
    let matchedColor = null;
    let hasValue = false;
    
    // 선택된 옵션에 따라 색상 확인
    if (selectedOption === 'code' && store.code) {
      hasValue = true;
      matchedColor = colorSettings?.code?.[store.code];
    } else if (selectedOption === 'office' && store.office) {
      hasValue = true;
      matchedColor = colorSettings?.office?.[store.office];
    } else if (selectedOption === 'department' && store.department) {
      hasValue = true;
      matchedColor = colorSettings?.department?.[store.department];
    } else if (selectedOption === 'manager' && store.managerForFilter) {
      hasValue = true;
      matchedColor = colorSettings?.manager?.[store.managerForFilter];
    }
    
    // 색상이 매칭되면 적용
    if (matchedColor) {
      fillColor = matchedColor;
      strokeColor = adjustBrightness(matchedColor, -30); // 30% 어둡게
      radius = hasInventory ? 14 : 10;
      iconStyle = '';
      return L.divIcon({...});
    }
    
    // 값은 있지만 색상이 설정되지 않은 경우 회색 처리
    if (hasValue && !matchedColor) {
      fillColor = '#9e9e9e'; // 회색
      strokeColor = '#757575'; // 어두운 회색
      radius = hasInventory ? 14 : 10;
      iconStyle = '';
      return L.divIcon({...});
    }
  }
  
  // 기존 로직 (출고일 기준 색상) - 'default' 옵션이 선택된 경우 또는 옵션 색상이 없는 경우
  if (selectedOption === 'default' || !matchedColor) {
    const totalFilteredInventory = inventoryByAge.within30 + inventoryByAge.within60 + inventoryByAge.over60;
    // ... 기존 코드 유지
  }
}
```

**색상 밝기 조정 함수** (strokeColor 계산용):
```javascript
const adjustBrightness = (hex, percent) => {
  // hex 색상을 RGB로 변환하고 밝기 조정
  // 간단한 구현 또는 라이브러리 사용
};
```

---

### Phase 4: 유니크 코드 목록 API 구현

#### 4.1 서버 API 추가 (server/index.js)

**엔드포인트**: `GET /api/stores/codes`

**구현 내용**:
```javascript
// server/index.js
app.get('/api/stores/codes', async (req, res) => {
  try {
    const { sheets, SPREADSHEET_ID } = createSheetsClient();
    
    const response = await sheets.spreadsheets.values.get({
      spreadsheetId: SPREADSHEET_ID,
      range: '폰클출고처데이터!H:H' // H열 전체
    });
    
    const rows = response.data.values || [];
    const codes = new Set();
    
    // 헤더 제외하고 데이터 처리
    rows.slice(1).forEach(row => {
      const code = (row[0] || '').toString().trim();
      if (code) {
        codes.add(code);
      }
    });
    
    // 배열로 변환 및 정렬
    const uniqueCodes = Array.from(codes).sort();
    
    res.json({ success: true, codes: uniqueCodes });
  } catch (error) {
    console.error('코드 목록 조회 오류:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});
```

---

## 📝 상세 구현 체크리스트

### ✅ Phase 1: 구글시트 구조 및 데이터 수집
- [ ] `관리자모드_마커색상설정` 시트 생성 확인
- [ ] `HEADERS_MARKER_COLOR_SETTINGS` 헤더 정의
- [ ] `ensureSheetHeaders` 함수로 시트 헤더 자동 생성 확인
- [ ] 서버에서 `store.code` 필드가 정상적으로 포함되는지 확인
- [ ] 폰클출고처데이터 시트의 H열(7인덱스) 데이터 형식 확인
- [ ] 빈 값 및 null 처리 확인
- [ ] 유니크 코드 추출 로직 테스트

### ✅ Phase 2: 서버 API 구현
- [ ] `GET /api/stores/codes` 엔드포인트 구현
  - [ ] 폰클출고처데이터 시트 H열 조회
  - [ ] 유니크 값 추출 및 정렬
  - [ ] 캐싱 적용 (30초 TTL)
  - [ ] 에러 처리
- [ ] `GET /api/marker-color-settings` 엔드포인트 구현
  - [ ] 사용자ID로 필터링
  - [ ] Map 형태로 변환하여 반환
  - [ ] 에러 처리
- [ ] `POST /api/marker-color-settings` 엔드포인트 구현
  - [ ] 기존 설정 조회
  - [ ] 업데이트/추가 로직 분리
  - [ ] 등록일시/수정일시 관리
  - [ ] 배치 업데이트 처리
  - [ ] 에러 처리

### ✅ Phase 3: 프론트엔드 UI 구현
- [ ] `MarkerColorSettingsModal.js` 컴포넌트 생성
  - [ ] 기본 색상 팔레트 정의 (20개 색상)
  - [ ] TextField with type="color" 사용
  - [ ] 유니크 코드 목록 API 호출 및 표시
  - [ ] 색상 미리보기 구현
  - [ ] 기본값 자동 할당 로직
  - [ ] 기본값으로 초기화 기능
- [ ] `markerColorUtils.js` 유틸리티 함수 구현
  - [ ] `getMarkerColorSettings` (서버 API 호출)
  - [ ] `saveMarkerColorSettings` (서버 API 호출)
- [ ] `Header.js` 수정
  - [ ] 색상 설정 버튼 추가 (관리자모드에서만)
  - [ ] PaletteIcon import
  - [ ] 모달 열기/닫기 상태 관리
- [ ] `App.js` 수정
  - [ ] `markerColorSettings` state 추가
  - [ ] 관리자모드일 때 색상 설정 로드
  - [ ] Map 컴포넌트에 `colorSettings` prop 전달
  - [ ] 모달 저장 후 색상 설정 재로드

### ✅ Phase 4: 마커 색상 적용
- [ ] `Map.js` 수정
  - [ ] `createMarkerIcon` 함수에 `colorSettings` prop 추가
  - [ ] 코드별 색상 확인 로직 추가
  - [ ] 코드 없는 매장 회색 처리 로직 추가
  - [ ] 색상 우선순위 로직 구현 (요청점 > 사무실 > 선택 > 로그인 > 코드별 > 코드없음(회색) > 기존)
  - [ ] strokeColor 자동 계산 (fillColor 기반, adjustBrightness 함수 사용)
  - [ ] 관리자모드에서만 코드별 색상 적용 확인
- [ ] `colorUtils.js` 유틸리티 함수 구현
  - [ ] `adjustBrightness` 함수 (RGB 기반 밝기 조정)
  - [ ] 또는 `darkenColor` 함수 (HSL 기반, 더 정확)

### ✅ Phase 5: 통합 및 테스트
- [ ] 관리자모드에서 색상 설정 버튼 표시 확인
- [ ] 모달 열기/닫기 동작 확인
- [ ] 코드 목록 정상 로드 확인
- [ ] 기본 색상 자동 할당 확인
- [ ] 색상 선택 및 저장 동작 확인
- [ ] 구글시트에 정상 저장 확인
- [ ] 저장된 색상이 마커에 즉시 적용되는지 확인
- [ ] 코드가 없는 매장은 회색으로 표시 확인
- [ ] 요청점/사무실/선택된 매장 등 우선순위 확인
- [ ] 브라우저 새로고침 후 색상 유지 확인
- [ ] 다른 사용자는 독립적인 색상 설정 확인
- [ ] 여러 코드에 대한 색상 설정 및 적용 확인

---

## 🎨 UI/UX 상세 설계

### 색상 설정 모달

**레이아웃**:
```
┌──────────────────────────────────────────────┐
│ 마커 색상 설정                    [X]       │
├──────────────────────────────────────────────┤
│                                              │
│ 코드별 색상을 설정할 수 있습니다.            │
│                                              │
│ ┌────────────────────────────────────────┐ │
│ │ VIP(경수)                               │ │
│ │ [색상선택 버튼] [색상 미리보기 박스]   │ │
│ └────────────────────────────────────────┘ │
│                                              │
│ ┌────────────────────────────────────────┐ │
│ │ VIP(호남)                               │ │
│ │ [색상선택 버튼] [색상 미리보기 박스]   │ │
│ └────────────────────────────────────────┘ │
│                                              │
│ ... (스크롤 가능)                           │
│                                              │
│ [기본값으로 초기화]  [취소]  [저장]        │
└──────────────────────────────────────────────┘
```

**컴포넌트 구조**:
- `Dialog`: 모달 컨테이너
- `DialogTitle`: "마커 색상 설정"
- `DialogContent`: 
  - 설명 텍스트
  - 코드별 색상 설정 리스트 (List 또는 Table)
- `DialogActions`: 취소/저장 버튼

**색상 선택 방법**:
- **옵션 A**: Material-UI `TextField` with `type="color"` (간단)
- **옵션 B**: Material-UI `ColorPicker` (더 많은 옵션)
- **옵션 C**: 커스텀 색상 팔레트 (미리 정의된 색상 선택)

**권장**: 옵션 A - 브라우저 기본 color picker 사용 (구현 간단, 모든 색상 선택 가능)

---

## 🔧 기술적 세부사항

### 1. 구글시트 구조 및 API

#### 1.1 시트 구조
**시트명**: `관리자모드_마커색상설정`

**헤더 정의** (server/index.js):
```javascript
const SHEET_MARKER_COLOR_SETTINGS = '관리자모드_마커색상설정';
const HEADERS_MARKER_COLOR_SETTINGS = [
  '사용자ID',      // A열: 사용자 ID (x-user-id)
  '옵션타입',      // B열: 옵션 타입 ('code', 'office', 'department', 'manager', 'enabled')
  '값',            // C열: 옵션 값 (예: "VIP(경수)", "서울사무실", "경수팀", "홍길동")
  '색상',          // D열: HEX 색상 코드 (예: "#ff5722")
  '등록일시',      // E열: ISO 형식 날짜
  '수정일시'       // F열: ISO 형식 날짜
];
```

#### 1.2 서버 API 구현

**GET /api/marker-color-settings** - 현재 사용자의 색상 설정 조회
```javascript
// server/index.js
app.get('/api/marker-color-settings', async (req, res) => {
  try {
    const userId = req.headers['x-user-id'] || req.query.userId;
    if (!userId) {
      return res.status(400).json({ success: false, error: '사용자 ID가 필요합니다.' });
    }

    const { sheets, SPREADSHEET_ID } = createSheetsClient();
    await ensureSheetHeaders(sheets, SPREADSHEET_ID, SHEET_MARKER_COLOR_SETTINGS, HEADERS_MARKER_COLOR_SETTINGS);

    const response = await sheets.spreadsheets.values.get({
      spreadsheetId: SPREADSHEET_ID,
      range: `${SHEET_MARKER_COLOR_SETTINGS}!A:F`
    });

    const rows = response.data.values || [];
    const dataRows = rows.slice(1);
    
    // 현재 사용자의 설정만 필터링
    const userRows = dataRows.filter(row => row[0] === userId);
    
      // 선택된 옵션 추출
      const selectedRow = userRows.find(row => row[1] === 'selected');
      const selectedOption = selectedRow ? (selectedRow[2] || 'default') : 'default';
      
      // 색상 설정을 옵션별로 그룹화
      const settings = {
        selectedOption,
        colorSettings: {
          code: {},
          office: {},
          department: {},
          manager: {}
        }
      };
    
    userRows.forEach(row => {
      const optionType = row[1] || '';
      const value = row[2] || '';
      const color = row[3] || '';
      
      if (optionType !== 'selected' && optionType && value && color) {
        if (settings.colorSettings[optionType]) {
          settings.colorSettings[optionType][value] = color;
        }
      }
    });

    res.json({ success: true, settings });
  } catch (error) {
    console.error('색상 설정 조회 오류:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});
```

**POST /api/marker-color-settings** - 색상 설정 저장/업데이트
```javascript
// server/index.js
app.post('/api/marker-color-settings', express.json(), async (req, res) => {
  try {
    const userId = req.headers['x-user-id'] || req.body.userId;
    const { settings } = req.body; // { "VIP(경수)": "#ff5722", ... }

    if (!userId) {
      return res.status(400).json({ success: false, error: '사용자 ID가 필요합니다.' });
    }

    if (!settings || typeof settings !== 'object') {
      return res.status(400).json({ success: false, error: '색상 설정이 필요합니다.' });
    }

    const { sheets, SPREADSHEET_ID } = createSheetsClient();
    await ensureSheetHeaders(sheets, SPREADSHEET_ID, SHEET_MARKER_COLOR_SETTINGS, HEADERS_MARKER_COLOR_SETTINGS);

    // 기존 설정 조회
    const response = await sheets.spreadsheets.values.get({
      spreadsheetId: SPREADSHEET_ID,
      range: `${SHEET_MARKER_COLOR_SETTINGS}!A:E`
    });

    const rows = response.data.values || [];
    const dataRows = rows.slice(1);
    const now = new Date().toISOString();

    // 기존 행에서 현재 사용자의 설정 찾기
    const existingRows = dataRows.filter(row => row[0] === userId);
    const existingCodes = new Set(existingRows.map(row => row[1]));

    // 업데이트할 행과 새로 추가할 행 분리
    const rowsToUpdate = [];
    const rowsToAppend = [];

    Object.entries(settings).forEach(([code, color]) => {
      const existingRow = existingRows.find(row => row[1] === code);
      if (existingRow) {
        // 업데이트
        const rowIndex = dataRows.findIndex(row => row[0] === userId && row[1] === code);
        rowsToUpdate.push({
          rowIndex: rowIndex + 2, // 헤더 + 1부터 시작
          values: [userId, code, color, existingRow[3] || now, now]
        });
      } else {
        // 새로 추가
        rowsToAppend.push([userId, code, color, now, now]);
      }
    });

    // 업데이트 실행
    await Promise.all([
      ...rowsToUpdate.map(({ rowIndex, values }) =>
        sheets.spreadsheets.values.update({
          spreadsheetId: SPREADSHEET_ID,
          range: `${SHEET_MARKER_COLOR_SETTINGS}!A${rowIndex}:E${rowIndex}`,
          valueInputOption: 'USER_ENTERED',
          resource: { values: [values] }
        })
      ),
      rowsToAppend.length > 0 && sheets.spreadsheets.values.append({
        spreadsheetId: SPREADSHEET_ID,
        range: `${SHEET_MARKER_COLOR_SETTINGS}!A:E`,
        valueInputOption: 'USER_ENTERED',
        resource: { values: rowsToAppend }
      })
    ]);

    res.json({ success: true, message: '색상 설정이 저장되었습니다.' });
  } catch (error) {
    console.error('색상 설정 저장 오류:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});
```

#### 1.3 클라이언트 유틸리티 함수
```javascript
// src/utils/markerColorUtils.js (새로 생성)
import { API_BASE_URL } from '../api';

// 유니크 값 목록 조회
export const getUniqueValues = async (type) => {
  try {
    const response = await fetch(`${API_BASE_URL}/api/stores/unique-values?type=${type}`);
    if (response.ok) {
      const data = await response.json();
      return data.values || [];
    }
    return [];
  } catch (error) {
    console.error('유니크 값 목록 조회 오류:', error);
    return [];
  }
};

// 색상 설정 조회 (옵션별로 그룹화)
export const getMarkerColorSettings = async (userId) => {
  try {
    const response = await fetch(`${API_BASE_URL}/api/marker-color-settings`, {
      headers: {
        'x-user-id': userId
      }
    });
    
    if (response.ok) {
      const data = await response.json();
      // 서버에서 받은 데이터를 옵션별로 그룹화
      const settings = {
        enabledOptions: {
          default: false,
          code: false,
          office: false,
          department: false,
          manager: false
        },
        colorSettings: {
          code: {},
          office: {},
          department: {},
          manager: {}
        }
      };
      
      // 선택된 옵션 처리
      const selectedRow = data.settings.find(row => row.optionType === 'selected');
      if (selectedRow && selectedRow.value) {
        settings.selectedOption = selectedRow.value;
      } else {
        settings.selectedOption = 'default';
      }
      
      // 색상 설정 처리
      data.settings.forEach(row => {
        if (row.optionType !== 'enabled' && row.optionType && row.value && row.color) {
          if (settings.colorSettings[row.optionType]) {
            settings.colorSettings[row.optionType][row.value] = row.color;
          }
        }
      });
      
      return settings;
    }
      return {
        selectedOption: settings.selectedOption || 'default',
        colorSettings: settings.colorSettings || { code: {}, office: {}, department: {}, manager: {} }
      };
    } catch (error) {
      console.error('색상 설정 조회 오류:', error);
      return {
        selectedOption: 'default',
        colorSettings: { code: {}, office: {}, department: {}, manager: {} }
      };
    }
};

// 색상 설정 저장
export const saveMarkerColorSettings = async (userId, selectedOption, colorSettings) => {
  try {
    const response = await fetch(`${API_BASE_URL}/api/marker-color-settings`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-user-id': userId
      },
      body: JSON.stringify({
        selectedOption,
        colorSettings
      })
    });
    
    if (response.ok) {
      const data = await response.json();
      return { success: true, message: data.message };
    }
    
    const errorData = await response.json();
    return { success: false, error: errorData.error };
  } catch (error) {
    console.error('색상 설정 저장 오류:', error);
    return { success: false, error: error.message };
  }
};
```

---

### 2. 색상 밝기 조정

**strokeColor 계산**:
```javascript
// src/utils/colorUtils.js (새로 생성 또는 기존 파일에 추가)
export const adjustBrightness = (hex, percent) => {
  // hex를 RGB로 변환
  const num = parseInt(hex.replace('#', ''), 16);
  const r = (num >> 16) + percent;
  const g = ((num >> 8) & 0x00FF) + percent;
  const b = (num & 0x0000FF) + percent;
  
  // 0-255 범위로 제한
  const clamp = (val) => Math.min(255, Math.max(0, val));
  
  return `#${((clamp(r) << 16) | (clamp(g) << 8) | clamp(b)).toString(16).padStart(6, '0')}`;
};

// 또는 더 정확한 방법: HSL 변환 후 밝기 조정
export const darkenColor = (hex, percent) => {
  // HSL 변환 후 L(밝기) 값 감소
  // 구현 생략 (필요시 추가)
};
```

---

### 3. 마커 색상 적용 로직

**createMarkerIcon 함수 수정 위치**:
```javascript
// src/components/Map.js
// createMarkerIcon 함수에 colorSettings prop 추가 필요
// App.js에서 colorSettings state 관리 및 Map 컴포넌트에 전달

// 818번째 줄 근처의 "일반 매장" 색상 결정 부분
else {
  // 코드별 색상 확인 (관리자모드에서만)
  if (isAgentMode && store.code) {
    const codeColor = colorSettings?.[store.code];
    if (codeColor) {
      fillColor = codeColor;
      strokeColor = adjustBrightness(codeColor, -30); // 30% 어둡게
      radius = hasInventory ? 14 : 10;
      iconStyle = '';
      // 코드별 색상이 있으면 여기서 return
      return L.divIcon({...});
    }
  }
  
  // 코드가 없는 매장 처리 (관리자모드에서만)
  if (isAgentMode && (!store.code || store.code.trim() === '')) {
    fillColor = '#9e9e9e'; // 회색
    strokeColor = '#757575'; // 어두운 회색
    radius = hasInventory ? 14 : 10;
    iconStyle = '';
    return L.divIcon({...});
  }
  
  // 기존 로직 (출고일 기준 색상) - 코드별 색상이 없고 코드도 있는 경우
  const totalFilteredInventory = inventoryByAge.within30 + inventoryByAge.within60 + inventoryByAge.over60;
  // ... 기존 코드 유지
}
```

**App.js 수정 필요**:
```javascript
// src/App.js
const [markerColorSettings, setMarkerColorSettings] = useState({});

// 관리자모드일 때 색상 설정 로드
useEffect(() => {
  if (isAgentMode && loggedInStore?.id) {
    loadMarkerColorSettings();
  }
}, [isAgentMode, loggedInStore?.id]);

const loadMarkerColorSettings = async () => {
  try {
    const settings = await getMarkerColorSettings(loggedInStore.id);
    setMarkerColorSettings(settings);
  } catch (error) {
    console.error('색상 설정 로드 오류:', error);
  }
};

// Map 컴포넌트에 전달
<Map
  ...
  colorSettings={markerColorSettings.colorSettings}
  selectedOption={markerColorSettings.selectedOption}
/>
```

---

### 4. 색상 설정 모달 컴포넌트 상세

**파일**: `src/components/MarkerColorSettingsModal.js`

**기본 색상 팔레트**:
```javascript
// 구분이 잘되는 색상 팔레트 (Material-UI 기반)
const DEFAULT_COLOR_PALETTE = [
  '#f44336', // 빨강
  '#2196f3', // 파랑
  '#4caf50', // 초록
  '#ff9800', // 주황
  '#9c27b0', // 보라
  '#00bcd4', // 청록
  '#ffeb3b', // 노랑
  '#e91e63', // 분홍
  '#795548', // 갈색
  '#607d8b', // 청회색
  '#3f51b5', // 남색
  '#009688', // 청록
  '#ff5722', // 주황빨강
  '#673ab7', // 보라
  '#cddc39', // 연두
  '#ffc107', // 호박색
  '#00acc1', // 청록
  '#8bc34a', // 연두
  '#ff6f00', // 주황
  '#5c6bc0'  // 남보라
];
```

**전체 구조**:
```javascript
import React, { useState, useEffect } from 'react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  TextField,
  Box,
  Typography,
  List,
  ListItem,
  ListItemText,
  CircularProgress,
  Alert
} from '@mui/material';
import { API_BASE_URL } from '../api';
import { getMarkerColorSettings, saveMarkerColorSettings } from '../utils/markerColorUtils';

const DEFAULT_COLOR_PALETTE = [
  '#f44336', '#2196f3', '#4caf50', '#ff9800', '#9c27b0',
  '#00bcd4', '#ffeb3b', '#e91e63', '#795548', '#607d8b',
  '#3f51b5', '#009688', '#ff5722', '#673ab7', '#cddc39',
  '#ffc107', '#00acc1', '#8bc34a', '#ff6f00', '#5c6bc0'
];

const MarkerColorSettingsModal = ({ open, onClose, userId, onSave }) => {
  const [selectedOption, setSelectedOption] = useState('default');
  const [colorSettings, setColorSettings] = useState({
    code: {},
    office: {},
    department: {},
    manager: {}
  });
  const [uniqueValues, setUniqueValues] = useState({
    code: [],
    office: [],
    department: [],
    manager: []
  });
  const [loading, setLoading] = useState(false);
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState(null);

  // 유니크 코드 목록 및 색상 설정 로드
  useEffect(() => {
    if (open && userId) {
      loadData();
    }
  }, [open, userId]);

  const loadData = async () => {
    try {
      setLoading(true);
      setError(null);
      
      // 병렬로 코드 목록과 색상 설정 로드
      const [codesResponse, settings] = await Promise.all([
        fetch(`${API_BASE_URL}/api/stores/codes`),
        getMarkerColorSettings(userId)
      ]);
      
      if (codesResponse.ok) {
        const codesData = await codesResponse.json();
        setUniqueCodes(codesData.codes || []);
      }
      
      setColorSettings(settings);
    } catch (error) {
      console.error('데이터 로드 오류:', error);
      setError('데이터를 불러오는 중 오류가 발생했습니다.');
    } finally {
      setLoading(false);
    }
  };

  const handleOptionChange = async (option) => {
    setSelectedOption(option);
    
    // 선택된 옵션의 유니크 값 로드
    if (option !== 'default') {
      const values = await getUniqueValues(option);
      setUniqueValues(prev => ({
        ...prev,
        [option]: values
      }));
    }
  };

  const handleColorChange = (optionType, value, color) => {
    setColorSettings(prev => ({
      ...prev,
      [optionType]: {
        ...prev[optionType],
        [value]: color
      }
    }));
  };

  const handleSave = async () => {
    try {
      setSaving(true);
      setError(null);
      
      const result = await saveMarkerColorSettings(userId, selectedOption, colorSettings);
      
      if (result.success) {
        if (onSave) {
          onSave({ selectedOption, colorSettings });
        }
        onClose();
      } else {
        setError(result.error || '저장에 실패했습니다.');
      }
    } catch (error) {
      console.error('저장 오류:', error);
      setError('저장 중 오류가 발생했습니다.');
    } finally {
      setSaving(false);
    }
  };

  const handleReset = () => {
    if (selectedOption !== 'default') {
      const values = uniqueValues[selectedOption] || [];
      const resetSettings = {};
      values.forEach((value, index) => {
        resetSettings[value] = DEFAULT_COLOR_PALETTE[index % DEFAULT_COLOR_PALETTE.length];
      });
      setColorSettings(prev => ({
        ...prev,
        [selectedOption]: resetSettings
      }));
    }
  };

  return (
    <Dialog open={open} onClose={onClose} maxWidth="sm" fullWidth>
      <DialogTitle>마커 색상 설정</DialogTitle>
      <DialogContent>
        {error && (
          <Alert severity="error" sx={{ mb: 2 }} onClose={() => setError(null)}>
            {error}
          </Alert>
        )}
        
        <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
          색상 구분 옵션을 선택하고 각 값별로 색상을 설정할 수 있습니다.
        </Typography>
        
        {/* 라디오 버튼으로 옵션 선택 */}
        <FormControl component="fieldset" sx={{ mb: 3 }}>
          <FormLabel component="legend">색상 구분 옵션 선택</FormLabel>
          <RadioGroup
            value={selectedOption}
            onChange={(e) => handleOptionChange(e.target.value)}
          >
            <FormControlLabel value="default" control={<Radio />} label="기존 로직 (출고일 기준)" />
            <FormControlLabel value="code" control={<Radio />} label="코드별" />
            <FormControlLabel value="office" control={<Radio />} label="사무실별" />
            <FormControlLabel value="department" control={<Radio />} label="소속별" />
            <FormControlLabel value="manager" control={<Radio />} label="담당자별" />
          </RadioGroup>
        </FormControl>
        
        {loading ? (
          <Box sx={{ display: 'flex', justifyContent: 'center', p: 3 }}>
            <CircularProgress />
          </Box>
        ) : selectedOption !== 'default' ? (
          <List>
            {(uniqueValues[selectedOption] || []).map((value, index) => {
              const defaultColor = DEFAULT_COLOR_PALETTE[index % DEFAULT_COLOR_PALETTE.length];
              const currentColor = colorSettings[selectedOption]?.[value] || defaultColor;
              
              return (
                <ListItem key={value}>
                  <ListItemText 
                    primary={value}
                    secondary={!colorSettings[selectedOption]?.[value] ? '기본 색상' : '사용자 설정'}
                  />
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                    <TextField
                      type="color"
                      value={currentColor}
                      onChange={(e) => handleColorChange(selectedOption, value, e.target.value)}
                      sx={{ width: 60, height: 40 }}
                    />
                    <Box
                      sx={{
                        width: 40,
                        height: 40,
                        backgroundColor: currentColor,
                        border: '1px solid #ccc',
                        borderRadius: 1
                      }}
                    />
                  </Box>
                </ListItem>
              );
            })}
          </List>
        ) : (
          <Typography variant="body2" color="text.secondary" sx={{ p: 2, textAlign: 'center' }}>
            기존 로직을 선택하셨습니다. 출고일 기준 색상이 적용됩니다.
          </Typography>
        )}
      </DialogContent>
      <DialogActions>
        <Button onClick={handleReset} disabled={loading || saving}>
          기본값으로 초기화
        </Button>
        <Button onClick={onClose} disabled={saving}>취소</Button>
        <Button onClick={handleSave} variant="contained" disabled={loading || saving}>
          {saving ? <CircularProgress size={24} /> : '저장'}
        </Button>
      </DialogActions>
    </Dialog>
  );
};

export default MarkerColorSettingsModal;
```

---

## 🚨 주의사항 및 고려사항

### 1. 성능
- 유니크 코드 목록은 한 번만 로드하고 캐싱 (서버 측 30초 TTL)
- 색상 설정은 App.js에서 한 번만 로드하고 state로 관리
- 마커 생성 시마다 API 호출하지 않고 prop으로 전달
- `useMemo` 또는 `useCallback` 활용하여 불필요한 재렌더링 방지

### 2. 호환성
- 기존 마커 색상 로직과의 호환성 유지
- 코드가 없는 매장은 회색으로 표시 (기존 출고일 기준 색상 대신)
- 요청점/사무실/선택된 매장 등 우선순위 유지
- 관리자모드가 아닐 때는 기존 로직 그대로 동작

### 3. 사용자 경험
- 색상 설정 후 즉시 반영 (새로고침 없이, state 업데이트로)
- 색상 미리보기 제공
- 기본값 자동 할당 (설정하지 않은 코드는 팔레트에서 순차 할당)
- 기본값으로 초기화 기능
- 로딩 상태 표시

### 4. 에러 처리
- API 호출 실패 처리 (에러 메시지 표시)
- 잘못된 색상 값 처리 (HEX 형식 검증)
- 구글시트 쓰기 실패 처리
- 네트워크 오류 처리

---

## 📦 파일 변경 목록

### 새로 생성할 파일
1. `src/components/MarkerColorSettingsModal.js` - 색상 설정 모달
2. `src/utils/markerColorUtils.js` - 색상 설정 유틸리티 (서버 API 호출)
3. `src/utils/colorUtils.js` - 색상 조정 유틸리티 (adjustBrightness 함수)

### 수정할 파일
1. `src/components/Header.js` - 색상 설정 버튼 추가 및 모달 상태 관리
2. `src/components/Map.js` - `createMarkerIcon` 함수에 `colorSettings` prop 추가 및 로직 수정
3. `src/App.js` - `markerColorSettings` state 추가 및 로드/저장 로직
4. `server/index.js` - 다음 API 엔드포인트 추가:
   - `GET /api/stores/codes` - 유니크 코드 목록 조회
   - `GET /api/marker-color-settings` - 현재 사용자의 색상 설정 조회
   - `POST /api/marker-color-settings` - 색상 설정 저장/업데이트
   - `SHEET_MARKER_COLOR_SETTINGS`, `HEADERS_MARKER_COLOR_SETTINGS` 상수 정의

---

## ✅ 최종 체크리스트

### 구현 전 확인
- [x] 폰클출고처데이터 시트의 H열 데이터 형식 확인
- [x] 유니크 코드 예시 확인 (예: "VIP(경수)", "VIP(호남)" 등)
- [x] 색상 저장 위치 결정: **구글시트**
- [x] 기본 색상 전략 결정: **구분이 잘되는 색상 팔레트 (20개)**
- [x] 코드 없는 매장 처리 결정: **회색 (#9e9e9e)**
- [x] 권한 결정: **모든 관리자모드 사용자**

### 구현 중
- [ ] 구글시트 헤더 정의 및 상수 추가
- [ ] `GET /api/stores/unique-values?type=code` API 구현
- [ ] `GET /api/marker-color-settings` API 구현
- [ ] `POST /api/marker-color-settings` API 구현
- [ ] `markerColorUtils.js` 유틸리티 함수 구현
- [ ] `colorUtils.js` 유틸리티 함수 구현
- [ ] `MarkerColorSettingsModal.js` 컴포넌트 구현
- [ ] `Header.js`에 색상 설정 버튼 추가
- [ ] `App.js`에 색상 설정 state 및 로드 로직 추가
- [ ] `Map.js`에 코드별 색상 적용 로직 추가

### 구현 후 테스트
- [ ] 관리자모드에서 색상 설정 버튼 표시 확인
- [ ] 모달 열기/닫기 동작 확인
- [ ] 코드 목록 정상 로드 확인
- [ ] 기본 색상 자동 할당 확인
- [ ] 색상 선택 및 저장 확인
- [ ] 구글시트에 정상 저장 확인
- [ ] 저장된 색상이 마커에 즉시 적용 확인
- [ ] 코드 없는 매장 회색 표시 확인
- [ ] 우선순위 로직 확인 (요청점 > 사무실 > 선택 > 로그인 > 코드별 > 코드없음 > 기존)
- [ ] 브라우저 새로고침 후 색상 유지 확인
- [ ] 다른 사용자는 독립적인 색상 설정 확인
- [ ] 여러 코드에 대한 색상 설정 및 적용 확인

---

## 🎯 최종 구현 가이드

### 구현 순서

#### Step 1: 서버 API 구현 (server/index.js)
1. 시트 상수 정의
2. `GET /api/stores/codes` 구현
3. `GET /api/marker-color-settings` 구현
4. `POST /api/marker-color-settings` 구현

#### Step 2: 유틸리티 함수 구현
1. `src/utils/markerColorUtils.js` 생성
2. `src/utils/colorUtils.js` 생성 (또는 기존 파일에 추가)

#### Step 3: 프론트엔드 컴포넌트 구현
1. `src/components/MarkerColorSettingsModal.js` 생성
2. `src/components/Header.js` 수정 (버튼 추가)
3. `src/App.js` 수정 (state 및 로드 로직)
4. `src/components/Map.js` 수정 (색상 적용 로직)

### 핵심 구현 포인트

1. **색상 우선순위**: 요청점 > 사무실 > 선택된 매장 > 로그인한 매장 > 선택된 옵션별 색상 > 값 없는 매장(회색) > 기존 출고일 기준 색상
2. **기본 색상**: 설정하지 않은 코드는 팔레트에서 순차 할당
3. **즉시 반영**: 저장 후 state 업데이트로 마커 재렌더링 (새로고침 불필요)
4. **사용자별 독립성**: 구글시트에서 사용자ID로 필터링하여 각 사용자별 독립적인 설정

---

## 📌 구현 완료 확인

위의 체크리스트를 순서대로 진행하면 완벽하게 구현할 수 있습니다.

**특히 주의할 점**:
- 구글시트 헤더는 `ensureSheetHeaders` 함수로 자동 생성되므로 별도 생성 불필요
- 색상 설정은 사용자별로 독립적이므로 다른 사용자의 설정과 충돌 없음
- 기본 색상은 팔레트에서 순차 할당하되, 사용자가 직접 변경 가능
- 코드 없는 매장은 항상 회색으로 표시 (기존 출고일 기준 색상 대신)

**구현 시작 준비 완료!** 🚀
