# 별도정책 설정 구현 계획

## 📋 목차
1. [요구사항 분석](#요구사항-분석)
2. [현재 코드 구조 분석](#현재-코드-구조-분석)
3. [구현 계획](#구현-계획)
4. [구글시트 구조 변경](#구글시트-구조-변경)
5. [코드 수정 계획](#코드-수정-계획)
6. [정책 타입 확장성](#정책-타입-확장성)

---

## 요구사항 분석

### 핵심 요구사항
1. **유연한 정책 추가/삭제**: 정책명을 사용자가 텍스트 필드에 직접 입력하여 생성/삭제 가능
2. **정책명 자유 입력**: 정책명은 하드코딩되지 않고, 사용자가 원하는 이름을 자유롭게 입력 가능
3. **통신사별 독립 관리**: 각 통신사(SK, KT, LG)별로 정책을 독립적으로 관리
4. **조건 기반 적용**: 개통유형, 개통모델, 요금제군별로 조건 설정 가능
5. **확장 가능한 정책 타입**: 다양한 정책 타입을 쉽게 추가 가능

### 정책 사용 예시 (참고용)

> ⚠️ **중요**: 아래 정책명들은 단지 예시일 뿐입니다. 실제로는 사용자가 텍스트 필드에 원하는 정책명을 직접 입력하여 생성할 수 있습니다.

#### 예시 1: 선택약정시 차감정책
**정책명**: 사용자가 직접 입력 (예: "선택약정시 차감정책", "선택약정 할인", "약정별 차감" 등)
**목적**: 선택약정 선택 시 대리점추가지원금이 축소되는 기능

**조건 설정 예시**:
- 모델: SM-A166L, 개통유형: MNP, 요금제군: 33군 → 차감: 30,000원
- 모델: SM-A166L, 개통유형: 010신규, 요금제군: 115군 → 차감: 50,000원

#### 예시 2: 유통망지원금 활성화정책
**정책명**: 사용자가 직접 입력 (예: "유통망지원금 활성화", "지원금 보너스", "추가 인센티브" 등)
**목적**: 개통유형별 대리점추가지원금 금액에 따라 일정 금액 이상이 되면 대리점추가지원금이 추가되는 정책

**조건 설정 예시**:
- 개통유형: MNP, 기준 금액: 200,000원 이상 → 추가: 20,000원
- 개통유형: 010신규, 기준 금액: 150,000원 이상 → 추가: 15,000원

#### 예시 3: 키즈폰 010신규 결합 활성화 정책
**정책명**: 사용자가 직접 입력 (예: "키즈폰 010신규 결합 활성화 정책", "키즈폰 신규 보너스" 등)
**목적**: 키즈폰 모델에서 010신규 개통 시 대리점추가지원금 추가/차감

**조건 설정 예시**:
- 모델: 키즈폰 모델들, 개통유형: 010신규, 요금제군: 33군 → 추가: 30,000원

#### 예시 4: 청소년 요금제 추가정책
**정책명**: 사용자가 직접 입력 (예: "청소년 요금제 추가정책(1)", "청소년 특별 할인", "청소년 인센티브" 등)
**목적**: 청소년 요금제 선택 시 대리점추가지원금 추가/차감

**조건 설정 예시**:
- 요금제군: 청소년 요금제군, 개통유형: MNP → 추가: 25,000원
- 요금제군: 청소년 요금제군, 개통유형: 010신규 → 추가: 30,000원

---

## 현재 코드 구조 분석

### 1. 별도정책 설정 모달
**위치**: `src/components/direct/management/PolicySettingsTab.js`

**현재 구조**:
```javascript
// 별도정책 상태
const [specialPolicies, setSpecialPolicies] = useState([
    { id: 1, name: '기기반납', addition: 0, deduction: 100000, isActive: true },
    { id: 2, name: '제휴카드', addition: 50000, deduction: 0, isActive: false }
]);

// 입력 폼 상태
const [newSpecial, setNewSpecial] = useState({ 
    name: '', 
    addition: '', 
    deduction: '', 
    isActive: true 
});
```

**현재 시트 구조** (`직영점_정책_별도`):
- 컬럼: ['통신사', '정책명', '추가금액', '차감금액', '적용여부']
- 예시: ['LG', '기기반납', '0', '100000', 'true']

**문제점**:
- 조건 정보(모델, 개통유형, 요금제군)를 저장할 수 없음
- 정책 타입 구분이 없음
- 정책별로 다른 조건 구조를 저장할 수 없음

### 2. 정책 설정 저장/로드
**위치**: `server/directRoutes.js`

**현재 구조**:
```javascript
// GET /api/direct/policy-settings
const specialPolicies = specialRows
    .filter(row => (row[0] || '').trim() === carrier)
    .map((row, idx) => ({
        id: idx + 1,
        name: (row[1] || '').trim(),
        addition: Number(row[2] || 0),
        deduction: Number(row[3] || 0),
        isActive: (row[4] || '').toString().toLowerCase() === 'true' || (row[4] || '').toString() === '1'
    }));
```

### 3. 대리점추가지원금 계산
**위치**: `src/components/direct/OpeningInfoPage.js`

**현재 구조**:
```javascript
const calculateDynamicStoreSupport = useMemo(() => {
    // ...
    const finalStoreSupport = baseStoreSupport 
        - initialSelectedIncentive 
        - initialSelectedDeduction 
        + selectedIncentive 
        + selectedDeduction;
    
    // 직접입력 추가금액 반영
    const additionalAmount = additionalStoreSupport !== null && additionalStoreSupport !== undefined ? Number(additionalStoreSupport) : 0;
    const finalWithAdditional = Math.max(0, finalStoreSupport + additionalAmount);
    
    return {
        current: finalWithAdditional,
        withAddon: finalWithAdditional
    };
}, [/* dependencies */]);
```

**현재 로직**:
- 부가서비스 incentive/deduction만 반영
- 별도정책은 아직 반영되지 않음
- 선택약정 여부는 화면 표시에만 영향 (계산에는 영향 없음)

---

## 구현 계획

### 핵심 설계 원칙

1. **유연한 정책 시스템**: 정책 타입을 하드코딩하지 않고, 조건 기반으로 유연하게 정책 적용
2. **조건 기반 매칭**: 모델, 개통유형, 요금제군 조건을 JSON으로 저장하여 다양한 정책 지원
3. **통신사별 독립 관리**: 각 통신사별로 정책을 독립적으로 관리
4. **확장 가능성**: 새로운 정책 타입을 추가할 때 코드 수정 최소화

### 1. 구글시트 구조 변경

#### 1.1. `직영점_정책_별도` 시트 구조 확장

**현재 구조** (5개 컬럼):
```
A: 통신사
B: 정책명
C: 추가금액
D: 차감금액
E: 적용여부
```

**변경 후 구조** (6개 컬럼):
```
A: 통신사
B: 정책명
C: 정책타입          🔥 추가
D: 금액              🔥 변경: 추가금액/차감금액 → 금액 하나로 통합 (양수: 추가, 음수: 차감)
E: 적용여부
F: 조건JSON          🔥 추가
```

**정책타입 값**:
- `general`: 일반 별도정책 (기존 방식, 하위 호환)
- `conditional`: 조건 기반 정책 (모델, 개통유형, 요금제군 조건)
- 기타: 사용자가 자유롭게 정책명을 설정하고 정책타입을 지정 가능

**조건JSON 구조** (통일된 구조):
```json
{
  "type": "conditional",
  "conditions": [
    {
      "models": ["SM-A166L", "키즈폰"],           // 대상모델 배열 (빈 배열이면 전체 모델)
      "openingTypes": ["MNP", "010신규"],         // 개통유형 배열 (빈 배열이면 전체 유형)
      "planGroups": ["33군", "50군"],             // 대상요금제군 배열 (빈 배열이면 전체 요금제군)
      "contractType": "selected",                 // 약정유형 (선택약정/일반약정, 선택사항)
      "minStoreSupport": 200000,                  // 최소 대리점추가지원금 (선택사항)
      "amount": 30000                             // 🔥 금액 (양수: 추가, 음수: 차감)
    }
  ]
}
```

> 💡 **설계 결정**: 추가금액과 차감금액을 분리하지 않고, 하나의 금액 필드로 통합합니다. 양수를 입력하면 추가, 음수를 입력하면 차감으로 처리합니다. 이렇게 하면 UI가 더 간단하고 직관적입니다.

**예시 데이터** (정책명은 사용자가 입력한 값):

> ⚠️ **참고**: 아래 예시의 정책명들은 사용자가 텍스트 필드에 입력한 값입니다. 실제로는 사용자가 원하는 이름을 자유롭게 입력할 수 있습니다.

1. **사용자가 입력한 정책명 예시: "선택약정시 차감정책"** (금액: -30000)
```
LG | 선택약정시 차감정책 | conditional | -30000 | true | {"type":"conditional","conditions":[{"models":["SM-A166L"],"openingTypes":["MNP"],"planGroups":["33군"],"contractType":"selected","amount":-30000}]}
```

2. **사용자가 입력한 정책명 예시: "유통망지원금 활성화"** (금액: 20000)
```
LG | 유통망지원금 활성화 | conditional | 20000 | true | {"type":"conditional","conditions":[{"openingTypes":["MNP"],"minStoreSupport":200000,"amount":20000}]}
```

3. **사용자가 입력한 정책명 예시: "키즈폰 010신규 결합 활성화 정책"** (금액: 30000)
```
LG | 키즈폰 010신규 결합 활성화 정책 | conditional | 30000 | true | {"type":"conditional","conditions":[{"models":["키즈폰"],"openingTypes":["010신규"],"planGroups":["33군"],"amount":30000}]}
```

4. **사용자가 입력한 정책명 예시: "청소년 요금제 추가정책(1)"** (금액: 25000)
```
LG | 청소년 요금제 추가정책(1) | conditional | 25000 | true | {"type":"conditional","conditions":[{"planGroups":["청소년 요금제군"],"openingTypes":["MNP"],"amount":25000}]}
```

5. **사용자가 입력한 정책명 예시: "청소년 요금제 추가정책(2)"** (금액: 30000)
```
LG | 청소년 요금제 추가정책(2) | conditional | 30000 | true | {"type":"conditional","conditions":[{"planGroups":["청소년 요금제군"],"openingTypes":["010신규"],"amount":30000}]}
```

### 2. 프론트엔드 수정

#### 2.1. PolicySettingsTab.js 수정

**별도정책 입력 폼 확장**:
```javascript
// 정책명은 사용자가 직접 입력하는 텍스트 필드
const [newSpecial, setNewSpecial] = useState({ 
    name: '',              // 🔥 정책명: 사용자가 텍스트 필드에 직접 입력
    policyType: 'general',  // 'general' | 'conditional'
    amount: '',             // 🔥 금액: 양수(추가) 또는 음수(차감)
    isActive: true,
    conditions: []  // 조건 배열 (conditional 타입일 때만 사용)
});

// 정책 추가 UI 구성:
// 1. 정책명 입력 필드 (TextField) - 사용자가 자유롭게 입력
// 2. 정책 타입 선택 드롭다운 (general / conditional)
// 3. 금액 입력 필드 (NumberField)
//    - 양수 입력: 추가 정책
//    - 음수 입력: 차감 정책
//    - 예: 30000 (추가), -30000 (차감)
// 4. conditional 타입 선택 시 조건 입력 UI 표시:
//    - 조건 추가 버튼
//    - 각 조건별 입력 필드:
//      - 대상모델 검색 추가 (Autocomplete with search, multiple)
//        * 모델명을 검색하여 선택
//        * 여러 모델 선택 가능
//      - 개통유형 검색 추가 (Autocomplete with search, multiple)
//        * 010신규, MNP, 기변 등을 검색하여 선택
//        * 여러 유형 선택 가능
//      - 대상요금제군 검색 추가 (Autocomplete with search, multiple)
//        * 요금제군을 검색하여 선택 (예: 33군, 50군, 115군)
//        * 여러 요금제군 선택 가능
//      - 약정유형 선택 (Radio: 전체/선택약정/일반약정)
//      - 최소 대리점추가지원금 입력 (선택사항, NumberField)
//      - 금액 입력 (NumberField, 양수: 추가, 음수: 차감)
//    - 조건 삭제 버튼
// 5. 정책 추가 버튼
// 6. 정책 목록 표시 및 삭제 버튼
```

**조건 추가/삭제 기능**:
```javascript
// 조건 추가
const handleAddCondition = () => {
    const newCondition = {
        models: [],              // 검색으로 추가한 모델 배열
        openingTypes: [],        // 검색으로 추가한 개통유형 배열
        planGroups: [],         // 검색으로 추가한 요금제군 배열
        contractType: '',       // 'selected' | 'standard' | '' (전체)
        minStoreSupport: '',    // 최소 대리점추가지원금 (선택사항)
        amount: ''              // 🔥 금액 (양수: 추가, 음수: 차감)
    };
    setNewSpecial(prev => ({
        ...prev,
        conditions: [...prev.conditions, newCondition]
    }));
};

// 조건 삭제
const handleRemoveCondition = (index) => {
    setNewSpecial(prev => ({
        ...prev,
        conditions: prev.conditions.filter((_, i) => i !== index)
    }));
};

// 모델 검색 및 추가
const handleAddModel = (modelName) => {
    // Autocomplete에서 선택한 모델을 조건의 models 배열에 추가
    // 중복 체크 포함
};

// 개통유형 검색 및 추가
const handleAddOpeningType = (openingType) => {
    // Autocomplete에서 선택한 개통유형을 조건의 openingTypes 배열에 추가
    // 중복 체크 포함
};

// 요금제군 검색 및 추가
const handleAddPlanGroup = (planGroup) => {
    // Autocomplete에서 선택한 요금제군을 조건의 planGroups 배열에 추가
    // 중복 체크 포함
};
```

**저장 로직 수정**:
```javascript
const handleSave = async (type) => {
    if (type === 'special') {
        const specialData = specialPolicies.map(policy => {
            let conditionsJson = null;
            
            if (policy.policyType === 'conditional' && policy.conditions && policy.conditions.length > 0) {
                conditionsJson = {
                    type: 'conditional',
                    conditions: policy.conditions.map(cond => ({
                        models: cond.models || [],
                        openingTypes: cond.openingTypes || [],
                        planGroups: cond.planGroups || [],
                        contractType: cond.contractType || '',
                        minStoreSupport: cond.minStoreSupport ? Number(cond.minStoreSupport) : undefined,
                        amount: cond.amount ? Number(cond.amount) : 0  // 🔥 양수: 추가, 음수: 차감
                    }))
                };
            }
            
            return {
                name: policy.name,
                policyType: policy.policyType || 'general',
                amount: policy.amount ? Number(policy.amount) : 0,  // 🔥 양수: 추가, 음수: 차감
                isActive: policy.isActive,
                conditionsJson: conditionsJson ? JSON.stringify(conditionsJson) : null
            };
        });
        
        await directStoreApi.savePolicySettings(carrier, {
            special: specialData
        });
    }
};
```

#### 2.2. OpeningInfoPage.js 수정

**정책 적용 로직 추가**:
```javascript
// 정책 설정에서 조건 기반 정책 로드
const conditionalPolicies = useMemo(() => {
    if (!policySettings?.specialPolicies) {
        return [];
    }
    
    return policySettings.specialPolicies
        .filter(policy => policy.isActive && policy.policyType === 'conditional')
        .map(policy => {
            try {
                const conditionsJson = typeof policy.conditionsJson === 'string' 
                    ? JSON.parse(policy.conditionsJson) 
                    : policy.conditionsJson || {};
                
                if (conditionsJson.type === 'conditional' && conditionsJson.conditions) {
                    return {
                        name: policy.name,
                        conditions: conditionsJson.conditions || []
                    };
                }
            } catch (e) {
                console.warn('정책 조건 JSON 파싱 실패:', e);
            }
            return null;
        })
        .filter(Boolean);
}, [policySettings?.specialPolicies]);

// 조건 기반 정책 적용 함수
// ⚠️ 주의: minStoreSupport 체크는 순환 참조를 피하기 위해 calculateDynamicStoreSupport 내부에서 별도 처리
const calculateConditionalPolicies = useMemo(() => {
    let totalAmount = 0;  // 🔥 하나의 변수로 통합 (양수: 추가, 음수: 차감)
    
    conditionalPolicies.forEach(policy => {
        policy.conditions.forEach(condition => {
            // 모델 매칭
            const modelMatch = (condition.models || []).length === 0 || 
                condition.models.some(model => 
                    initialData?.model === model ||
                    initialData?.petName === model ||
                    (initialData?.model || '').includes(model) ||
                    (initialData?.petName || '').includes(model)
                );
            
            // 개통유형 매칭
            const openingTypeMatch = (condition.openingTypes || []).length === 0 ||
                condition.openingTypes.includes(formData.openingType) ||
                condition.openingTypes.includes(convertOpeningType(formData.openingType));
            
            // 요금제군 매칭
            const planGroupMatch = (condition.planGroups || []).length === 0 ||
                condition.planGroups.includes(selectedPlanGroup) ||
                condition.planGroups.includes(initialData?.planGroup);
            
            // 약정유형 매칭
            const contractTypeMatch = !condition.contractType ||
                condition.contractType === formData.contractType;
            
            // ⚠️ minStoreSupport 체크는 제외 (순환 참조 방지)
            // minStoreSupport는 calculateDynamicStoreSupport 내부에서 별도로 처리
            
            // 모든 조건이 일치하면 적용 (minStoreSupport 제외)
            if (modelMatch && openingTypeMatch && planGroupMatch && contractTypeMatch) {
                // minStoreSupport가 있는 경우는 나중에 체크
                totalAmount += condition.amount || 0;  // 🔥 양수면 추가, 음수면 차감
            }
        });
    });
    
    return totalAmount;  // 🔥 하나의 값으로 반환
}, [
    conditionalPolicies,
    formData.openingType,
    formData.contractType,
    selectedPlanGroup,
    initialData?.model,
    initialData?.petName,
    initialData?.planGroup
    // ⚠️ calculateDynamicStoreSupport 제외 (순환 참조 방지)
]);

// calculateDynamicStoreSupport에 정책 적용
const calculateDynamicStoreSupport = useMemo(() => {
    // ... 기존 로직 ...
    
    const finalStoreSupport = baseStoreSupport 
        - initialSelectedIncentive 
        - initialSelectedDeduction 
        + selectedIncentive 
        + selectedDeduction;
    
    // 직접입력 추가금액 반영
    const additionalAmount = additionalStoreSupport !== null && additionalStoreSupport !== undefined ? Number(additionalStoreSupport) : 0;
    
    // 🔥 추가: 조건 기반 정책 적용
    let conditionalPolicyAmount = calculateConditionalPolicies;  // 양수: 추가, 음수: 차감
    
    // ⚠️ minStoreSupport 조건이 있는 정책은 별도로 체크
    conditionalPolicies.forEach(policy => {
        policy.conditions.forEach(condition => {
            if (condition.minStoreSupport) {
                // 이미 계산된 대리점추가지원금과 비교
                const currentStoreSupport = finalStoreSupport + additionalAmount + conditionalPolicyAmount;
                if (currentStoreSupport >= condition.minStoreSupport) {
                    // 조건 매칭 체크 (위에서 이미 체크했지만 minStoreSupport만 제외)
                    const modelMatch = (condition.models || []).length === 0 || 
                        condition.models.some(model => 
                            initialData?.model === model ||
                            initialData?.petName === model ||
                            (initialData?.model || '').includes(model) ||
                            (initialData?.petName || '').includes(model)
                        );
                    const openingTypeMatch = (condition.openingTypes || []).length === 0 ||
                        condition.openingTypes.includes(formData.openingType) ||
                        condition.openingTypes.includes(convertOpeningType(formData.openingType));
                    const planGroupMatch = (condition.planGroups || []).length === 0 ||
                        condition.planGroups.includes(selectedPlanGroup) ||
                        condition.planGroups.includes(initialData?.planGroup);
                    const contractTypeMatch = !condition.contractType ||
                        condition.contractType === formData.contractType;
                    
                    if (modelMatch && openingTypeMatch && planGroupMatch && contractTypeMatch) {
                        conditionalPolicyAmount += condition.amount || 0;
                    }
                }
            }
        });
    });
    
    // 최종 계산: 기본값 + 직접입력 + 조건정책금액 (양수면 추가, 음수면 차감)
    const finalWithPolicies = Math.max(0, 
        finalStoreSupport 
        + additionalAmount 
        + conditionalPolicyAmount  // 🔥 하나의 값으로 처리
    );
    
    return {
        current: finalWithPolicies,
        withAddon: finalWithPolicies
    };
}, [/* dependencies + calculateConditionalPolicies */]);
```

### 3. 서버 수정

#### 3.1. directRoutes.js 수정

**HEADERS_POLICY_SPECIAL 확장**:
```javascript
const HEADERS_POLICY_SPECIAL = [
    '통신사', 
    '정책명', 
    '정책타입',  // 🔥 추가: 'general' | 'conditional'
    '금액',      // 🔥 변경: 추가금액/차감금액 → 금액 하나로 통합 (양수: 추가, 음수: 차감)
    '적용여부',
    '조건JSON'  // 🔥 추가: 조건 정보 JSON 문자열
];
```

**getPolicySettings 함수 수정**:
```javascript
const specialRows = (specialRes.data.values || []).slice(1);
const specialPolicies = specialRows
    .filter(row => (row[0] || '').trim() === carrier)
    .map((row, idx) => {
        let conditionsJson = null;
        try {
            // 조건JSON 파싱 (7번째 컬럼, 인덱스 6)
            const conditionsJsonStr = (row[6] || '').trim();
            if (conditionsJsonStr) {
                conditionsJson = JSON.parse(conditionsJsonStr);
            }
        } catch (e) {
            console.warn(`[Direct][getPolicySettings] 정책 조건 JSON 파싱 실패: ${row[1]}`, e);
        }
        
        return {
            id: idx + 1,
            name: (row[1] || '').trim(),
            policyType: (row[2] || '').trim() || 'general',  // 🔥 추가: 정책 타입
            amount: Number(row[3] || 0),  // 🔥 변경: 양수(추가) 또는 음수(차감)
            isActive: (row[4] || '').toString().toLowerCase() === 'true' || (row[4] || '').toString() === '1',
            conditionsJson: conditionsJson  // 🔥 추가: 조건 JSON
        };
    });
```

**POST /api/direct/policy-settings 수정**:
```javascript
// 별도정책 설정 저장
if (special && Array.isArray(special)) {
    await ensureSheetHeaders(sheets, SPREADSHEET_ID, SHEET_POLICY_SPECIAL, HEADERS_POLICY_SPECIAL);
    
    // 기존 데이터 읽기
    const specialRes = await sheets.spreadsheets.values.get({
        spreadsheetId: SPREADSHEET_ID,
        range: SHEET_POLICY_SPECIAL
    });
    const specialRows = (specialRes.data.values || []).slice(1);
    
    // 해당 통신사의 기존 행 찾기 및 삭제
    const rowsToDelete = [];
    specialRows.forEach((row, idx) => {
        if ((row[0] || '').trim() === carrier) {
            rowsToDelete.push(idx + 2); // +2: 헤더(1) + 0-based index(1)
        }
    });
    
    // 역순으로 삭제 (인덱스 변경 방지)
    for (let i = rowsToDelete.length - 1; i >= 0; i--) {
        const sheetId = await getSheetId(sheets, SPREADSHEET_ID, SHEET_POLICY_SPECIAL);
        await sheets.spreadsheets.batchUpdate({
            spreadsheetId: SPREADSHEET_ID,
            resource: {
                requests: [{
                    deleteDimension: {
                        range: {
                            sheetId: sheetId,
                            dimension: 'ROWS',
                            startIndex: rowsToDelete[i] - 1,
                            endIndex: rowsToDelete[i]
                        }
                    }
                }]
            }
        });
    }
    
    // 새 데이터 추가
    const newSpecialRows = special.map(policy => [
        carrier,
        policy.name || '',
        policy.policyType || 'general',  // 🔥 추가: 정책 타입
        policy.amount || 0,  // 🔥 변경: 양수(추가) 또는 음수(차감)
        policy.isActive ? 'true' : 'false',
        typeof policy.conditionsJson === 'string' 
            ? policy.conditionsJson 
            : (policy.conditionsJson ? JSON.stringify(policy.conditionsJson) : '')  // 🔥 추가: 조건 JSON
    ]);
    
    if (newSpecialRows.length > 0) {
        await sheets.spreadsheets.values.append({
            spreadsheetId: SPREADSHEET_ID,
            range: SHEET_POLICY_SPECIAL,
            valueInputOption: 'USER_ENTERED',
            insertDataOption: 'INSERT_ROWS',
            resource: { values: newSpecialRows }
        });
    }
}
```

---

## 구글시트 구조 변경

### 변경 사항 요약

#### 1. `직영점_정책_별도` 시트

**현재 구조** (5개 컬럼):
```
A: 통신사
B: 정책명
C: 추가금액
D: 차감금액
E: 적용여부
```

**변경 후 구조** (6개 컬럼):
```
A: 통신사
B: 정책명
C: 정책타입          🔥 추가
D: 금액              🔥 변경: 추가금액/차감금액 → 금액 하나로 통합 (양수: 추가, 음수: 차감)
E: 적용여부
F: 조건JSON          🔥 추가
```

**정책타입 값**:
- `general`: 일반 별도정책 (기존 방식, 하위 호환)
- `conditional`: 조건 기반 정책 (모델, 개통유형, 요금제군 조건)

**조건JSON 구조** (통일된 구조):
```json
{
  "type": "conditional",
  "conditions": [
    {
      "models": ["SM-A166L", "키즈폰"],           // 대상모델 배열 (빈 배열이면 전체 모델)
      "openingTypes": ["MNP", "010신규"],         // 개통유형 배열 (빈 배열이면 전체 유형)
      "planGroups": ["33군", "50군"],             // 대상요금제군 배열 (빈 배열이면 전체 요금제군)
      "contractType": "selected",                 // 약정유형 (선택약정/일반약정, 선택사항)
      "minStoreSupport": 200000,                  // 최소 대리점추가지원금 (선택사항)
      "amount": 30000                             // 🔥 금액 (양수: 추가, 음수: 차감)
    }
  ]
}
```

**예시 데이터** (정책명은 사용자가 입력한 값):

> ⚠️ **참고**: 아래 예시의 정책명들은 사용자가 텍스트 필드에 입력한 값입니다. 실제로는 사용자가 원하는 이름을 자유롭게 입력할 수 있습니다.

1. **사용자가 입력한 정책명 예시: "선택약정시 차감정책"** (금액: -30000)
```
LG | 선택약정시 차감정책 | conditional | -30000 | true | {"type":"conditional","conditions":[{"models":["SM-A166L"],"openingTypes":["MNP"],"planGroups":["33군"],"contractType":"selected","amount":-30000}]}
```

2. **사용자가 입력한 정책명 예시: "유통망지원금 활성화"** (금액: 20000)
```
LG | 유통망지원금 활성화 | conditional | 20000 | true | {"type":"conditional","conditions":[{"openingTypes":["MNP"],"minStoreSupport":200000,"amount":20000}]}
```

3. **사용자가 입력한 정책명 예시: "키즈폰 010신규 결합 활성화 정책"** (금액: 30000)
```
LG | 키즈폰 010신규 결합 활성화 정책 | conditional | 30000 | true | {"type":"conditional","conditions":[{"models":["키즈폰"],"openingTypes":["010신규"],"planGroups":["33군"],"amount":30000}]}
```

4. **사용자가 입력한 정책명 예시: "청소년 요금제 추가정책(1)"** (금액: 25000)
```
LG | 청소년 요금제 추가정책(1) | conditional | 25000 | true | {"type":"conditional","conditions":[{"planGroups":["청소년 요금제군"],"openingTypes":["MNP"],"amount":25000}]}
```

5. **사용자가 입력한 정책명 예시: "청소년 요금제 추가정책(2)"** (금액: 30000)
```
LG | 청소년 요금제 추가정책(2) | conditional | 30000 | true | {"type":"conditional","conditions":[{"planGroups":["청소년 요금제군"],"openingTypes":["010신규"],"amount":30000}]}
```

---

## 코드 수정 계획

### 1. 서버 수정 (`server/directRoutes.js`)

#### 1.1. HEADERS_POLICY_SPECIAL 확장 (45번 라인)
```javascript
const HEADERS_POLICY_SPECIAL = [
    '통신사', 
    '정책명', 
    '정책타입',  // 🔥 추가
    '금액',      // 🔥 변경: 추가금액/차감금액 → 금액 하나로 통합 (양수: 추가, 음수: 차감)
    '적용여부',
    '조건JSON'  // 🔥 추가
];
```

#### 1.2. getPolicySettings 함수 수정 (2500번 라인 근처)
- 조건JSON 파싱 로직 추가
- policyType 필드 추가
- addition/deduction → amount로 변경 (양수: 추가, 음수: 차감)

#### 1.3. POST /api/direct/policy-settings 수정 (2530번 라인 근처)
- 정책타입 저장 로직 추가
- 조건JSON 저장 로직 추가
- addition/deduction → amount로 변경 (양수: 추가, 음수: 차감)

### 2. 프론트엔드 수정

#### 2.1. PolicySettingsTab.js 수정

**추가할 기능**:
1. **정책명 입력 필드** (TextField)
   - 사용자가 원하는 정책명을 직접 입력
   - 정책명은 하드코딩되지 않고 자유롭게 설정 가능
   - 예: "선택약정시 차감정책", "유통망지원금 활성화", "키즈폰 010신규 결합 활성화 정책" 등
2. **정책 타입 선택 드롭다운** (general / conditional)
3. **금액 입력 필드** (NumberField)
   - 양수 입력: 추가 정책 (예: 30000)
   - 음수 입력: 차감 정책 (예: -30000)
   - 하나의 필드로 통합하여 간단하게 처리
4. **정책 추가 버튼**: 정책명과 조건을 입력한 후 추가
5. **정책 목록 표시 및 삭제 기능**: 등록된 정책 목록을 표시하고 삭제 가능
6. **conditional 타입 선택 시 조건 입력 UI 표시**
   - 조건 추가 버튼
   - 각 조건별 입력 필드:
     - **대상모델 검색 추가** (Autocomplete with search, multiple)
       * 모델명을 검색하여 선택
       * 여러 모델 선택 가능
       * 검색 기능으로 편리하게 추가
     - **개통유형 검색 추가** (Autocomplete with search, multiple)
       * 010신규, MNP, 기변 등을 검색하여 선택
       * 여러 유형 선택 가능
       * 검색 기능으로 편리하게 추가
     - **대상요금제군 검색 추가** (Autocomplete with search, multiple)
       * 요금제군을 검색하여 선택 (예: 33군, 50군, 115군)
       * 여러 요금제군 선택 가능
       * 검색 기능으로 편리하게 추가
     - 약정유형 선택 (Radio: 전체/선택약정/일반약정)
     - 최소 대리점추가지원금 입력 (선택사항, NumberField)
     - **금액 입력** (NumberField, 양수: 추가, 음수: 차감)
   - 조건 삭제 버튼
7. **조건 추가/삭제 기능**
8. **저장 시 조건JSON 생성 및 저장**

#### 2.2. OpeningInfoPage.js 수정

**추가할 기능**:
1. 정책 설정에서 conditional 타입 정책 필터링
2. 조건 기반 정책 적용 함수
3. calculateDynamicStoreSupport에 정책 적용 로직 추가

---

## 정책 타입 확장성

### 현재 지원하는 정책 타입

1. **general**: 일반 별도정책 (기존 방식)
   - 단순히 addition/deduction만 적용
   - 조건 없이 항상 적용

2. **conditional**: 조건 기반 정책
   - 모델, 개통유형, 요금제군, 약정유형, 최소 대리점추가지원금 조건 설정 가능
   - 조건이 일치할 때만 적용

### 향후 확장 가능한 정책 타입

새로운 정책 타입을 추가하려면:
1. 조건JSON 구조에 새로운 타입 추가
2. OpeningInfoPage.js에 해당 타입 처리 로직 추가
3. PolicySettingsTab.js에 해당 타입 입력 UI 추가 (필요시)

**예시: 시간 기반 정책**:
```json
{
  "type": "timeBased",
  "conditions": [
    {
      "startDate": "2026-01-01",
      "endDate": "2026-01-31",
      "additionAmount": 10000
    }
  ]
}
```

---

## 구현 순서

### 1단계: 구글시트 구조 확장
1. `직영점_정책_별도` 시트에 컬럼 추가 (정책타입, 조건JSON)
2. 추가금액/차감금액 컬럼을 금액 하나로 통합
3. 기존 데이터 마이그레이션 (정책타입: 'general', 금액: addition - deduction, 조건JSON: '')

### 2단계: 서버 수정
1. HEADERS_POLICY_SPECIAL 확장
2. getPolicySettings 함수 수정 (조건JSON 파싱)
3. POST /api/direct/policy-settings 수정 (조건JSON 저장)

### 3단계: 프론트엔드 - 정책 설정 모달 수정
1. PolicySettingsTab.js에 정책명 입력 필드 추가 (사용자가 자유롭게 입력)
2. 금액 입력 필드 추가 (양수: 추가, 음수: 차감)
3. 정책 추가 버튼 및 정책 목록 표시 기능 구현
4. 정책 삭제 기능 구현
5. 정책 타입 선택 드롭다운 추가
6. conditional 타입 선택 시 조건 입력 UI 추가
   - 모델 검색 추가 기능 (Autocomplete with search)
   - 개통유형 검색 추가 기능 (Autocomplete with search)
   - 요금제군 검색 추가 기능 (Autocomplete with search)
7. 조건 추가/삭제 기능 구현
8. 저장 로직 수정 (조건JSON 생성, amount 필드 사용)

### 4단계: 프론트엔드 - 대리점추가지원금 계산 수정
1. OpeningInfoPage.js에 조건 기반 정책 적용 로직 추가
2. calculateDynamicStoreSupport에 정책 반영

### 5단계: 테스트
1. 정책 설정 모달에서 정책 추가/수정/삭제 테스트
2. 다양한 조건 조합 테스트
3. 통신사별 정책 독립 관리 테스트

---

## 주의사항

### 1. 하위 호환성
- 기존 별도정책은 `정책타입: 'general'`로 처리
- 조건JSON이 없으면 기존 방식대로 addition/deduction만 적용

### 2. 조건 매칭 로직
- 빈 배열은 "전체"를 의미
- 모델 매칭: `initialData?.model` 또는 `initialData?.petName`과 비교 (부분 일치도 지원)
- 개통유형 매칭: `formData.openingType`과 비교 (변환 필요 시 `convertOpeningType` 사용)
- 요금제군 매칭: `selectedPlanGroup` 또는 `initialData?.planGroup`과 비교
- 약정유형 매칭: `formData.contractType`과 비교
- 최소 대리점추가지원금: 현재 계산된 대리점추가지원금과 비교

### 3. 계산 순서 및 자동 적용
1. 기본 대리점추가지원금 계산 (부가서비스 반영)
2. 직접입력 추가금액 반영
3. **조건 기반 정책 자동 적용** (금액 합산: 양수면 추가, 음수면 차감)
   - 개통정보입력페이지에서 모델, 개통유형, 요금제군, 약정유형 등이 변경될 때마다
   - 설정된 정책의 조건을 자동으로 체크
   - 조건에 부합하는 정책이 있으면 해당 금액을 자동으로 계산에 반영
   - 사용자가 별도로 버튼을 누르거나 저장할 필요 없음
4. 최종 금액 = max(0, 기본값 + 직접입력 + 조건정책금액)

> 💡 **자동 계산 동작 방식**:
> - 정책 설정에서 조건을 설정하고 금액을 입력하면
> - 개통정보입력페이지에서 해당 조건에 맞는 경우 자동으로 금액이 반영됩니다
> - 예: "선택약정시 차감정책"에서 모델=SM-A166L, 개통유형=MNP, 요금제군=33군, 약정유형=선택약정, 금액=-30000으로 설정하면
> - 해당 조건에 맞는 개통 정보 입력 시 대리점추가지원금에서 자동으로 30,000원이 차감됩니다

### 4. 성능 고려
- 정책 조건 매칭은 useMemo로 최적화
- 정책 설정 변경 시에만 재계산

### 5. 유연성
- **정책명 자유 입력**: 정책명은 하드코딩되지 않고, 사용자가 텍스트 필드에 직접 입력하여 생성/삭제 가능
- **정책 추가/삭제**: 사용자가 원하는 정책을 추가하고, 필요 없어진 정책을 삭제할 수 있음
- **금액 입력 간소화**: 추가금액/차감금액을 분리하지 않고, 하나의 금액 필드로 통합 (양수: 추가, 음수: 차감)
- **검색 기반 조건 추가**: 모델, 개통유형, 요금제군을 검색하여 편리하게 추가
- **통신사별 독립 관리**: 각 통신사별로 정책을 독립적으로 관리
- **조건 조합**: 조건을 여러 개 추가하여 복잡한 정책 구성 가능

### 6. 자동 계산 및 적용
- **자동 조건 매칭**: 개통정보입력페이지에서 모델, 개통유형, 요금제군, 약정유형 등이 변경될 때마다 자동으로 조건을 체크
- **자동 금액 반영**: 조건에 부합하는 정책이 있으면 해당 금액을 대리점추가지원금에 자동으로 반영
- **실시간 계산**: 사용자가 개통 정보를 입력하거나 변경할 때마다 실시간으로 재계산
- **사용자 개입 불필요**: 별도로 버튼을 누르거나 저장할 필요 없이 자동으로 적용

---

## 구현 완료 및 검토 사항

### 구현 완료 상태 (2026-01-18)

#### ✅ 완료된 구현
1. **서버 수정**
   - ✅ `HEADERS_POLICY_SPECIAL` 확장 (5개 → 6개 컬럼)
   - ✅ `getPolicySettings` 수정 (기존 데이터 마이그레이션 포함)
   - ✅ `POST /api/direct/policy-settings` 수정 (조건JSON 저장)

2. **프론트엔드 - PolicySettingsTab.js**
   - ✅ 정책명 입력 필드 추가
   - ✅ 정책 타입 선택 드롭다운 추가
   - ✅ 금액 입력 필드 추가 (양수/음수)
   - ✅ 조건 입력 UI 추가 (모델/개통유형/요금제군 검색, 다중 선택)
   - ✅ 저장 로직 수정 (조건JSON 생성)
   - ✅ 기존 데이터 로드 시 변환 로직 추가

3. **프론트엔드 - OpeningInfoPage.js**
   - ✅ `policySettings` 상태 저장
   - ✅ `calculateConditionalPolicies` 함수 추가 (순환 참조 해결)
   - ✅ `calculateDynamicStoreSupport` 수정 (정책 적용)
   - ✅ 의존성 배열 정확성 확인

### 구현 시 해결한 문제점

#### 1. 순환 참조 문제 해결
- **문제**: `calculateConditionalPolicies`가 `calculateDynamicStoreSupport.current`를 참조하려 했으나 순환 참조 발생
- **해결**: `minStoreSupport` 체크를 별도로 처리하여 순환 참조 방지
  - `calculateConditionalPolicies`에서는 `minStoreSupport` 제외하고 계산
  - `calculateDynamicStoreSupport` 내부에서 `minStoreSupport` 조건이 있는 정책만 별도로 체크

#### 2. 기존 데이터 마이그레이션
- **구현**: `getPolicySettings`에서 기존 5개 컬럼 데이터를 6개 컬럼 형식으로 자동 변환
  - `policyType: 'general'` 기본값 설정
  - `amount = addition - deduction` 변환
  - `conditionsJson: null` 설정

#### 3. 하위 호환성 보장
- **구현**: PolicySettingsTab.js에서 기존 `addition`, `deduction` 필드도 처리
  - 로드 시 기존 데이터는 `amount`로 변환
  - 저장 시 `amount` 필드 사용
  - 기존 데이터 표시도 지원 (하위 호환)

### 확인된 사항

#### ✅ 확인 완료
1. **convertOpeningType 함수**: `src/utils/directStoreUtils.js`에 존재 확인
2. **모델 검색 데이터 소스**: `directStoreApiClient.getMobilesMaster()` 사용
3. **요금제군 검색 데이터 소스**: `directStoreApiClient.getPlansMaster()` 사용
4. **개통유형 목록**: ['010신규', 'MNP', '기변'] 하드코딩 사용

### 테스트 체크리스트

#### 필수 테스트 항목
- [ ] 기존 정책 데이터 로드 테스트 (하위 호환성)
- [ ] 새 정책 추가/수정/삭제 테스트
- [ ] 조건 매칭 테스트 (모델, 개통유형, 요금제군, 약정유형)
- [ ] 대리점추가지원금 계산 테스트 (정책 자동 적용)
- [ ] 여러 조건 조합 테스트
- [ ] 통신사별 정책 독립 관리 테스트
- [ ] minStoreSupport 조건 테스트

### 예상 리스크 및 대응

#### 리스크 평가
- **낮음**: 기존 기능에 영향 없음 (새 기능 추가)
- **낮음**: 순환 참조 문제 (해결 완료)
- **중간**: 기존 데이터 마이그레이션 실패 가능성
  - **대응**: 자동 변환 로직 구현 완료, 테스트 필요

### 구현 완료 요약

**구현 일자**: 2026-01-18  
**구현 상태**: ✅ 완료  
**테스트 상태**: 대기 중

**주요 기능**:
- 조건 기반 정책 시스템 구현
- 모델/개통유형/요금제군 다중 선택 지원
- 정책 자동 적용 (개통정보입력페이지)
- 하위 호환성 보장 (기존 데이터 자동 변환)

---

**작성일**: 2026-01-18  
**최종 수정일**: 2026-01-18  
**작성자**: AI Assistant  
**상태**: 구현 완료, 테스트 대기
