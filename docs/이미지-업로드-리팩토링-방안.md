# 이미지 업로드 리팩토링 방안

## 현재 상황 분석

### 1. 현재 이미지 업로드 구조

#### ✅ 휴대폰목록 페이지 (MobileListTab)
- **위치**: `src/components/direct/MobileListTab.js`
- **기능**: 이미지 업로드 기능 존재
- **구현 방식**:
  - `handleImageUploadClick`: 편집 아이콘 클릭 시 파일 선택 다이얼로그 열기
  - `handleFileChange`: 파일 선택 후 업로드 처리
  - `directStoreApi.uploadImage` 호출
  - 업로드 후 재로딩 및 이벤트 발생

#### ❌ 오늘의휴대폰 페이지 (TodaysMobileTab)
- **위치**: `src/components/direct/TodaysMobileTab.js`
- **기능**: 이미지 업로드 기능 없음
- **현재 상태**: 
  - `imageUploaded` 이벤트 리스너만 존재 (다른 페이지에서 업로드 시 재로딩)
  - 직접 업로드 UI/기능 없음

#### ❌ 오늘의휴대폰 제품 카드 (TodaysProductCard)
- **위치**: `src/components/direct/TodaysProductCard.js`
- **기능**: 이미지 업로드 기능 없음
- **현재 상태**: 이미지 표시만 함

### 2. 서버 API 구조

#### 이미지 업로드 API
- **엔드포인트**: `POST /api/direct/upload-image`
- **위치**: `server/index.js` (라인 4452)
- **현재 기능**:
  1. Discord에 이미지 업로드
  2. `직영점_모델이미지` 시트에 저장/업데이트
  3. 캐시 무효화

#### ⚠️ 중요 문제점 발견
- **`직영점_단말마스터` 시트는 업데이트되지 않음**
  - 현재 코드에서는 `직영점_모델이미지` 시트에만 저장
  - `직영점_단말마스터`의 `imageUrl` 컬럼은 `rebuildDeviceMaster` 실행 시에만 업데이트됨
  - 즉, 데이터 재빌드를 해야 `직영점_단말마스터`에 반영됨

#### 현재 데이터 흐름
1. **이미지 업로드** → `직영점_모델이미지` 시트에 저장
2. **`getMobileList` API** → `직영점_모델이미지` 시트를 읽어서 이미지 매핑
3. **`직영점_단말마스터`** → `rebuildDeviceMaster` 실행 시 `직영점_모델이미지`를 읽어서 `imageUrl` 업데이트

#### 사용자 요구사항
- **이미지 업로드 후 즉시 표시되어야 함**
- **데이터 재빌드 없이 바로 반영되어야 함**

### 3. 문제점 분석

#### 주요 문제점
1. **오늘의휴대폰 페이지에 업로드 기능 없음**
   - 사용자가 오늘의휴대폰 페이지에서 직접 이미지를 업로드할 수 없음
   - 다른 페이지에서 업로드 후 이벤트를 기다려야 함

2. **코드 중복 및 복잡성**
   - `MobileListTab`에 업로드 로직이 직접 구현되어 있음
   - 재로딩 로직이 복잡하고 중복됨
   - 에러 처리 및 상태 관리가 분산되어 있음

3. **일관성 부족**
   - 두 페이지의 이미지 업로드 방식이 다름
   - 공통 컴포넌트나 훅이 없음

4. **사용자 경험 문제**
   - 업로드 후 즉시 반영되지 않을 수 있음
   - 재시도 로직이 복잡함

## 리팩토링 방안

### 방안 1: 공통 이미지 업로드 훅 생성 (권장)

#### 구조
```
src/hooks/useImageUpload.js (기존 파일 개선)
src/components/direct/common/ImageUploadButton.js (새로 생성)
```

#### 구현 계획

##### 1단계: 공통 훅 개선 (`useImageUpload.js`)
```javascript
// 개선 사항:
// - 재로딩 로직 단순화
// - 에러 처리 개선
// - 상태 관리 개선
// - 이벤트 발생 로직 통일
```

##### 2단계: 공통 컴포넌트 생성 (`ImageUploadButton.js`)
```javascript
// 기능:
// - 파일 선택 버튼
// - 업로드 진행 상태 표시
// - 에러 메시지 표시
// - 재사용 가능한 UI 컴포넌트
```

##### 3단계: MobileListTab 리팩토링
```javascript
// 변경 사항:
// - useImageUpload 훅 사용
// - ImageUploadButton 컴포넌트 사용
// - 기존 복잡한 로직 제거
```

##### 4단계: TodaysProductCard에 업로드 기능 추가
```javascript
// 변경 사항:
// - 편집 아이콘 추가 (이미지 위에 hover 시 표시)
// - ImageUploadButton 통합
// - useImageUpload 훅 사용
```

##### 5단계: 서버 API 개선 (즉시 반영을 위한 핵심 수정)
```javascript
// server/index.js의 /api/direct/upload-image 엔드포인트 개선
// 변경 사항:
// - 직영점_모델이미지 저장 후
// - 직영점_단말마스터 시트의 imageUrl 컬럼도 직접 업데이트
// - 모델 매칭 로직 추가 (통신사 + 모델명 기준)
// - 즉시 반영을 위해 필수 작업
```

##### 6단계: TodaysMobileTab 업데이트
```javascript
// 변경 사항:
// - 이벤트 리스너 유지 (다른 페이지에서 업로드 시 재로딩)
// - 추가 작업 없음 (TodaysProductCard에서 처리)
```

### 방안 2: 완전히 새로운 구조로 재작성

#### 구조
```
src/components/direct/common/ImageUploadDialog.js (새로 생성)
src/utils/imageUploadService.js (새로 생성)
```

#### 구현 계획

##### 1단계: 이미지 업로드 서비스 생성
```javascript
// imageUploadService.js
// - 업로드 로직 분리
// - 재로딩 로직 분리
// - 에러 처리 통일
// - 이벤트 발생 통일
```

##### 2단계: 이미지 업로드 다이얼로그 생성
```javascript
// ImageUploadDialog.js
// - 모달 다이얼로그 형태
// - 파일 선택 및 미리보기
// - 업로드 진행 상태
// - 성공/실패 메시지
```

##### 3단계: 모든 페이지에 통합
```javascript
// MobileListTab, TodaysProductCard에 ImageUploadDialog 통합
// - 일관된 UI/UX
// - 공통 로직 사용
```

## 권장 방안: 방안 1 (공통 훅 + 컴포넌트 + 서버 API 개선)

### 이유
1. **점진적 개선**: 기존 코드를 완전히 버리지 않고 개선
2. **재사용성**: 공통 훅과 컴포넌트로 코드 중복 제거
3. **유지보수성**: 로직이 한 곳에 집중되어 관리 용이
4. **테스트 용이성**: 훅과 컴포넌트를 독립적으로 테스트 가능
5. **즉시 반영**: 서버 API 개선으로 재빌드 없이 바로 표시 가능

### 구현 단계별 상세 계획

#### Step 1: `useImageUpload` 훅 개선

**현재 문제점**:
- 재로딩 로직이 복잡함 (3초 대기, 재시도 등)
- 에러 처리가 분산되어 있음
- 상태 관리가 명확하지 않음

**개선 방안**:
```javascript
// src/hooks/useImageUpload.js

export const useImageUpload = (options = {}) => {
  const {
    onSuccess,      // 성공 콜백
    onError,        // 에러 콜백
    autoReload = true,  // 자동 재로딩 여부
    reloadDelay = 2000,  // 재로딩 대기 시간
    showAlert = true     // 알림 표시 여부
  } = options;

  const [uploading, setUploading] = useState(false);
  const [progress, setProgress] = useState(0);
  const [error, setError] = useState(null);

  const uploadImage = useCallback(async (file, modelId, carrier, modelName, petName) => {
    // 업로드 로직
    // - 상태 관리 개선
    // - 에러 처리 통일
    // - 재로딩 로직 단순화
  }, [onSuccess, onError, autoReload, reloadDelay, showAlert]);

  return {
    uploading,
    progress,
    error,
    uploadImage
  };
};
```

#### Step 2: `ImageUploadButton` 컴포넌트 생성

**기능**:
- 파일 선택 버튼
- 업로드 진행 상태 표시
- 에러 메시지 표시
- 성공 메시지 표시

**구현**:
```javascript
// src/components/direct/common/ImageUploadButton.js

const ImageUploadButton = ({
  modelId,
  carrier,
  modelName,
  petName,
  onUploadSuccess,
  onUploadError,
  ...props
}) => {
  const fileInputRef = useRef(null);
  const { uploading, error, uploadImage } = useImageUpload({
    onSuccess: onUploadSuccess,
    onError: onUploadError,
    showAlert: true
  });

  const handleClick = () => {
    fileInputRef.current?.click();
  };

  const handleFileChange = async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;

    await uploadImage(file, modelId, carrier, modelName, petName);
    
    // 파일 입력 초기화
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  return (
    <>
      <input
        ref={fileInputRef}
        type="file"
        accept="image/*"
        style={{ display: 'none' }}
        onChange={handleFileChange}
      />
      <IconButton
        onClick={handleClick}
        disabled={uploading}
        {...props}
      >
        {uploading ? <CircularProgress size={20} /> : <EditIcon />}
      </IconButton>
    </>
  );
};
```

#### Step 3: MobileListTab 리팩토링

**변경 사항**:
```javascript
// 기존 코드 제거:
// - handleImageUploadClick
// - handleFileChange
// - 복잡한 재로딩 로직

// 새 코드:
import { ImageUploadButton } from './common/ImageUploadButton';

// MobileListRow에 전달
<MobileListRow
  ...
  onImageUploadClick={(modelId) => {
    // ImageUploadButton이 자동으로 처리
  }}
/>
```

#### Step 4: TodaysProductCard에 업로드 기능 추가

**변경 사항**:
```javascript
// 이미지 영역에 hover 시 편집 아이콘 표시
// ImageUploadButton 통합

<Box sx={{ position: 'relative' }}>
  <CardMedia ... />
  <Box
    sx={{
      position: 'absolute',
      top: 8,
      right: 8,
      opacity: isHovered ? 1 : 0,
      transition: 'opacity 0.2s'
    }}
  >
    <ImageUploadButton
      modelId={product.modelId}
      carrier={product.carrier}
      modelName={product.model}
      petName={product.petName}
      onUploadSuccess={() => {
        // 재로딩 또는 로컬 상태 업데이트
      }}
    />
  </Box>
</Box>
```

#### Step 5: 서버 API 개선 (선택사항)

**개선 사항**:
- 응답 시간 단축
- 에러 메시지 개선
- 로깅 개선

## 마이그레이션 체크리스트

### Phase 1: 준비 단계
- [ ] `useImageUpload` 훅 개선
- [ ] `ImageUploadButton` 컴포넌트 생성
- [ ] 단위 테스트 작성

### Phase 2: MobileListTab 리팩토링
- [ ] 기존 업로드 로직 제거
- [ ] `ImageUploadButton` 통합
- [ ] 테스트 및 검증

### Phase 3: TodaysProductCard 개선
- [ ] 편집 아이콘 추가
- [ ] `ImageUploadButton` 통합
- [ ] hover 효과 추가
- [ ] 테스트 및 검증

### Phase 4: 통합 테스트
- [ ] 두 페이지 모두에서 업로드 테스트
- [ ] 재로딩 테스트
- [ ] 에러 처리 테스트
- [ ] 사용자 경험 검증

### Phase 5: 정리
- [ ] 사용하지 않는 코드 제거
- [ ] 문서 업데이트
- [ ] 코드 리뷰

## 서버 API 개선 상세 계획

### 문제점
현재 이미지 업로드 시:
- `직영점_모델이미지` 시트에만 저장
- `직영점_단말마스터`는 재빌드해야 업데이트됨
- 사용자는 업로드 후 즉시 표시되길 원함

### 해결 방안

#### Option 1: `직영점_단말마스터` 직접 업데이트 (권장)
```javascript
// server/index.js의 /api/direct/upload-image 엔드포인트에 추가

// 직영점_모델이미지 저장 후
if (sheetSaveSuccess) {
  // 직영점_단말마스터 시트도 업데이트
  try {
    // 1. 직영점_단말마스터 시트 읽기
    const masterResponse = await rateLimitedSheetsCall(() =>
      sheets.spreadsheets.values.get({
        spreadsheetId: SPREADSHEET_ID,
        range: '직영점_단말마스터!A:O' // imageUrl은 M 컬럼 (index 12)
      })
    );

    const masterValues = masterResponse.data.values || [];
    const masterRows = masterValues.slice(1); // 헤더 제외

    // 2. 모델 매칭 (통신사 + 모델명 기준)
    const existingMasterRowIndex = masterRows.findIndex(row => {
      const rowCarrier = (row[0] || '').trim();
      const rowModelId = (row[1] || '').trim();
      const rowModelName = (row[2] || '').trim();

      if (rowCarrier !== carrier) return false;

      // 정규화된 모델 코드로 매칭
      const normalizedRowModelId = normalizeModelCode(rowModelId);
      const normalizedRowModelName = normalizeModelCode(rowModelName);
      const normalizedModelId = normalizeModelCode(modelId);
      const normalizedModelName = normalizeModelCode(modelName);

      return (
        normalizedRowModelId === normalizedModelId ||
        normalizedRowModelId === normalizedModelName ||
        normalizedRowModelName === normalizedModelId ||
        normalizedRowModelName === normalizedModelName ||
        rowModelId === modelId ||
        rowModelName === modelName
      );
    });

    // 3. imageUrl 컬럼 업데이트 (M 컬럼, index 12)
    if (existingMasterRowIndex !== -1) {
      const targetRowNumber = existingMasterRowIndex + 2; // 데이터 시작이 2행
      const targetCell = `직영점_단말마스터!M${targetRowNumber}`;
      
      await rateLimitedSheetsCall(() =>
        sheets.spreadsheets.values.update({
          spreadsheetId: SPREADSHEET_ID,
          range: targetCell,
          valueInputOption: 'USER_ENTERED',
          resource: { values: [[imageUrl]] }
        })
      );
      
      console.log(`✅ [이미지 업로드] 직영점_단말마스터 시트 이미지URL 업데이트 성공: 행 ${targetRowNumber}`);
    } else {
      console.warn(`⚠️ [이미지 업로드] 직영점_단말마스터 시트에서 모델 ${modelId} (${carrier})을(를) 찾을 수 없어 이미지URL을 업데이트하지 못했습니다.`);
    }
  } catch (masterSheetError) {
    console.error('❌ [이미지 업로드] 직영점_단말마스터 시트 업데이트 오류:', masterSheetError);
    // 에러가 발생해도 이미지 업로드는 성공했으므로 계속 진행
  }
}
```

**장점**:
- 업로드 후 즉시 `직영점_단말마스터`에 반영
- 재빌드 없이 바로 표시 가능
- `getMobileList`와 `getMobilesMaster` 모두에서 즉시 반영

**단점**:
- 추가 API 호출 (성능 영향 미미)
- 모델 매칭 실패 시 업데이트 안 됨 (경고 로그만)

#### Option 2: `getMobileList`가 항상 `직영점_모델이미지` 우선 참조 (현재 방식)
- 현재 `getMobileList`는 이미 `직영점_모델이미지`를 참조
- 캐시 무효화 후 재로딩하면 즉시 반영됨
- 하지만 `직영점_단말마스터`는 여전히 재빌드 필요

**권장**: Option 1 (직접 업데이트)
- 사용자 요구사항(즉시 반영)을 완전히 만족
- 두 시트 모두 동기화 유지

## 예상 효과

### 코드 품질
- **코드 중복 제거**: 약 200줄 이상 감소 예상
- **유지보수성 향상**: 로직이 한 곳에 집중
- **테스트 용이성**: 훅과 컴포넌트를 독립적으로 테스트 가능

### 사용자 경험
- **일관된 UI/UX**: 두 페이지에서 동일한 업로드 경험
- **즉시 반영**: 업로드 후 즉시 이미지 표시 (재빌드 불필요) ⭐
- **명확한 피드백**: 진행 상태 및 에러 메시지 표시
- **데이터 일관성**: `직영점_모델이미지`와 `직영점_단말마스터` 동기화 ⭐

### 개발 생산성
- **재사용성**: 다른 페이지에서도 쉽게 사용 가능
- **확장성**: 새로운 기능 추가가 용이
- **디버깅**: 문제 발생 시 원인 파악이 쉬움

## 주의사항

1. **기존 기능 유지**: 리팩토링 중에도 기존 기능이 정상 작동해야 함
2. **점진적 마이그레이션**: 한 번에 모든 것을 바꾸지 않고 단계적으로 진행
3. **백업**: 리팩토링 전 현재 코드 백업
4. **테스트**: 각 단계마다 충분한 테스트 수행

## 다음 단계

1. 이 방안을 검토하고 승인
2. `useImageUpload` 훅 개선부터 시작
3. 단계별로 구현 및 테스트
4. 완료 후 문서 업데이트

