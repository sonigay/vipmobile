# 정책표 엑셀 파일 생성 및 다운로드 - 완벽 구현 가이드

## ✅ 구현 준비 완료 확인

### 참고 코드 분석 완료
- 제공된 참고 코드는 정상 작동하는 검증된 코드
- 모든 핵심 함수 로직 파악 완료
- 에러 처리 및 엣지 케이스 파악 완료

### 현재 프로젝트 구조 파악 완료
- 로컬 디스코드 봇 구조 확인 완료
- 서버 코드 구조 확인 완료
- 데이터 저장 구조 확인 완료
- 프론트엔드 구조 확인 완료

### 구현 방식 결정
- **방법**: Google Sheets API 방식만 사용 (안정성 우선)
- **필수 작업**: 각 정책표 Google Sheets에 서비스 계정을 "뷰어"로 공유

---

## 📋 구현 단계별 상세 가이드

### 1단계: 로컬 디스코드 봇 수정

#### 1-1. 패키지 추가
**파일**: `local-discord-bot/package.json`
**위치**: dependencies 섹션
**추가할 패키지**:
```json
"googleapis": "^126.0.1",
"xlsx": "^0.18.5"
```

**참고**: `exceljs`는 사용하지 않음 (XLSX만 사용)

**⚠️ 중요**: 패키지 추가 후 반드시 `npm install` 실행 필요

#### 1-2. 필요한 모듈 import 추가
**파일**: `local-discord-bot/bot.js`
**위치**: 파일 상단 (라인 1-3 이후)
**추가할 코드**:
```javascript
const { AttachmentBuilder } = require('discord.js');
const { google } = require('googleapis');
const XLSX = require('xlsx');
const fs = require('fs').promises;
const path = require('path');
```

#### 1-3. 참고 코드의 핵심 함수들 추가
**파일**: `local-discord-bot/bot.js`
**위치**: `client.once('ready')` 이전 (라인 22 이전)

**추가할 함수들**:

1. **`getGoogleAuth()`**
   - 참고 코드에서 그대로 복사
   - 환경 변수: `GOOGLE_SERVICE_ACCOUNT_EMAIL`, `GOOGLE_PRIVATE_KEY`
   - 스코프: `https://www.googleapis.com/auth/drive.readonly`, `https://www.googleapis.com/auth/spreadsheets.readonly`
   - **검증**: 함수가 정확히 복사되었는지 확인 (에러 메시지 포함)

2. **`downloadExcelWithAPI(spreadsheetId, filePath)`**
   - 참고 코드에서 복사하되, **userId 관련 코드 수정 필수**
   - **함수 시그니처 수정**: 
     - 원본: `downloadExcelWithAPI(spreadsheetId, filePath, userId)`
     - 수정: `downloadExcelWithAPI(spreadsheetId, filePath)` (userId 파라미터 제거)
   - **함수 내부 수정**:
     - `debugLog(userId, ...)` → `console.log(...)`로 변경
     - `debugError(userId, ...)` → `console.error(...)`로 변경
     - `debugWarn(userId, ...)` → `console.warn(...)`로 변경
     - 모든 `debugLog`, `debugError`, `debugWarn` 호출에서 첫 번째 파라미터(userId) 제거
   - Google Drive API로 원본 파일 다운로드
   - XLSX 라이브러리로 첫 번째 시트만 추출 및 수식 변환
   - **⚠️ 주의**: 참고 코드의 `debugLog`, `debugError`, `debugWarn` 함수는 복사하지 않음 (console.log로 대체)
   - **검증**: 
     - 함수 내부에 `userId` 변수를 참조하는 코드가 없는지 확인
     - 함수 내부에 `debugLog`, `debugError`, `debugWarn` 호출이 없는지 확인 (모두 console.log 등으로 변경)

#### 1-4. 이미지 생성 후 엑셀 파일 생성 로직 추가
**파일**: `local-discord-bot/bot.js`
**위치**: 이미지 업로드 후, 완료 신호 전송 전 (라인 152 이후, 154 이전)

**추가할 코드**:
```javascript
// ===== 엑셀 파일 생성 =====
let excelMessageId = null;
let excelBuffer = null;

try {
  console.log(`📊 [로컬PC봇] [${requestId}] 엑셀 파일 생성 시작...`);
  
  // excel 디렉토리 생성 (없으면)
  try {
    await fs.access('./excel');
  } catch {
    await fs.mkdir('./excel', { recursive: true });
  }
  
  // URL에서 spreadsheetId 추출
  const spreadsheetIdMatch = sheetUrl.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
  const spreadsheetId = spreadsheetIdMatch ? spreadsheetIdMatch[1] : null;
  
  if (!spreadsheetId) {
    throw new Error('Google Sheets URL에서 spreadsheetId를 추출할 수 없습니다.');
  }
  
  // 파일명 생성 (Windows에서 사용 불가능한 문자 제거)
  const safeName = policyTableName
    .replace(/[<>:"/\\|?*]/g, '_')
    .replace(/\s+/g, '_');
  const excelFilename = `${safeName}_${Date.now()}.xlsx`;
  const excelPath = path.join('./excel', excelFilename);
  
  // 엑셀 파일 다운로드 (Google Sheets API 사용)
  let downloadSuccess = false;
  
  try {
    // Google Sheets API 사용 (서비스 계정 권한 필요)
    await downloadExcelWithAPI(spreadsheetId, excelPath);
    await fs.access(excelPath);
    downloadSuccess = true;
    console.log(`✅ [로컬PC봇] [${requestId}] Google Sheets API로 엑셀 다운로드 완료`);
  } catch (apiError) {
    console.error(`❌ [로컬PC봇] [${requestId}] Google Sheets API 실패: ${apiError.message}`);
    console.error(`⚠️ [로컬PC봇] [${requestId}] 서비스 계정이 해당 시트에 접근 권한이 있는지 확인하세요.`);
    // API 실패 시 엑셀 파일 생성 실패로 처리 (이미지는 정상)
  }
  
  if (downloadSuccess) {
    // 파일을 버퍼로 읽기
    excelBuffer = await fs.readFile(excelPath);
    
    // 엑셀 파일을 디스코드에 업로드
    const excelAttachment = new AttachmentBuilder(excelBuffer, {
      name: `${safeName}.xlsx`
    });
    
    const excelMessage = await message.channel.send({
      content: `📊 **엑셀 파일**`,
      files: [excelAttachment]
    });
    
    excelMessageId = excelMessage.id;
    console.log(`📤 [로컬PC봇] [${requestId}] 엑셀 파일 디스코드 업로드 완료 (메시지 ID: ${excelMessageId})`);
    
    // 임시 파일 삭제
    await fs.unlink(excelPath).catch(() => {});
  } else {
    console.warn(`⚠️ [로컬PC봇] [${requestId}] 엑셀 파일 생성 실패 (이미지는 정상 생성됨)`);
  }
} catch (excelError) {
  console.error(`❌ [로컬PC봇] [${requestId}] 엑셀 파일 생성 오류:`, excelError);
  // 엑셀 파일 생성 실패해도 이미지는 정상이므로 계속 진행
}
```

**⚠️ 중요 사항**:
- 이 코드 블록은 이미지 업로드 후(`imageMessage` 생성 후), 완료 신호 전송 전에 추가해야 함
- `excelMessageId` 변수는 완료 신호 전송 부분에서 사용되므로 반드시 선언 필요
- 코드 블록의 시작과 끝 중괄호가 올바르게 닫혔는지 확인

#### 1-5. 완료 신호에 excelId 추가
**파일**: `local-discord-bot/bot.js`
**위치**: 라인 157 (완료 신호 전송 부분)

**수정 전**:
```javascript
const completeSignal = `!screenshot-complete commandId=${commandMessageId} imageId=${imageMessage.id}`;
await message.channel.send(completeSignal);
```

**수정 후**:
```javascript
let completeSignal = `!screenshot-complete commandId=${commandMessageId} imageId=${imageMessage.id}`;
if (excelMessageId) {
  completeSignal += ` excelId=${excelMessageId}`;
}
await message.channel.send(completeSignal);
```

**⚠️ 중요 사항**:
- `excelMessageId` 변수는 1-4 단계에서 선언됨 (`let excelMessageId = null;`)
- `excelMessageId`가 `null`이면 완료 신호에 excelId가 포함되지 않음 (정상 동작)
- 완료 신호 형식:
  - 엑셀 파일 성공: `!screenshot-complete commandId=... imageId=... excelId=...`
  - 엑셀 파일 실패: `!screenshot-complete commandId=... imageId=...` (excelId 없음)

---

### 2단계: 서버 코드 수정

#### 2-1. 완료 신호 필터 수정
**파일**: `server/policyTableRoutes.js`
**위치**: 라인 261-307 (filter 함수)

**수정 내용**:
- `hasImageId` 체크는 유지 (필수)
- `excelId`는 선택적이므로 필터에서 제외
- 필터는 `hasImageId`만 체크하도록 유지

**변경 없음** (excelId는 선택적이므로 필터에서 체크하지 않음)

#### 2-2. 완료 신호 파싱 로직 수정
**파일**: `server/policyTableRoutes.js`
**위치**: 라인 316-351 (collector.on('collect') 내부)

**수정 전** (라인 323-351):
```javascript
// 완료 신호에서 이미지 메시지 ID 추출
const imageIdMatch = completeSignalMsg.content.match(/imageId=(\d+)/);
if (!imageIdMatch) {
  reject(new Error('완료 신호에 이미지 메시지 ID가 없습니다.'));
  return;
}

const imageMessageId = imageIdMatch[1];
console.log(`🔍 [정책표] 이미지 메시지 ID 추출: ${imageMessageId}`);

// 이미지 메시지 가져오기
const imageMessage = await targetChannel.messages.fetch(imageMessageId);
if (!imageMessage) {
  reject(new Error(`이미지 메시지를 찾을 수 없습니다: ${imageMessageId}`));
  return;
}

const attachment = imageMessage.attachments.first();
if (!attachment || !attachment.contentType?.startsWith('image/')) {
  reject(new Error('이미지가 포함된 메시지를 찾을 수 없습니다.'));
  return;
}

const imageUrl = attachment.url;
const messageId = imageMessage.id;
const threadId = targetChannel.id; // 포스트/스레드 ID

console.log(`✅ [정책표] 스크린샷 생성 완료: ${imageUrl} (메시지 ID: ${messageId}, 스레드 ID: ${threadId})`);
resolve({ imageUrl, messageId, threadId });
```

**수정 후**:
```javascript
// 완료 신호에서 이미지 메시지 ID 추출
const imageIdMatch = completeSignalMsg.content.match(/imageId=(\d+)/);
if (!imageIdMatch) {
  reject(new Error('완료 신호에 이미지 메시지 ID가 없습니다.'));
  return;
}

const imageMessageId = imageIdMatch[1];
console.log(`🔍 [정책표] 이미지 메시지 ID 추출: ${imageMessageId}`);

// 이미지 메시지 가져오기
const imageMessage = await targetChannel.messages.fetch(imageMessageId);
if (!imageMessage) {
  reject(new Error(`이미지 메시지를 찾을 수 없습니다: ${imageMessageId}`));
  return;
}

const attachment = imageMessage.attachments.first();
if (!attachment || !attachment.contentType?.startsWith('image/')) {
  reject(new Error('이미지가 포함된 메시지를 찾을 수 없습니다.'));
  return;
}

const imageUrl = attachment.url;
const messageId = imageMessage.id;
const threadId = targetChannel.id; // 포스트/스레드 ID

// 엑셀 파일 메시지 ID 추출 (선택적)
let excelUrl = null;
let excelMessageId = null;
const excelIdMatch = completeSignalMsg.content.match(/excelId=(\d+)/);
if (excelIdMatch) {
  try {
    excelMessageId = excelIdMatch[1];
    console.log(`🔍 [정책표] 엑셀 파일 메시지 ID 추출: ${excelMessageId}`);
    
    const excelMessage = await targetChannel.messages.fetch(excelMessageId);
    if (excelMessage) {
      const excelAttachment = excelMessage.attachments.first();
      if (excelAttachment && excelAttachment.name && excelAttachment.name.endsWith('.xlsx')) {
        excelUrl = excelAttachment.url;
        console.log(`✅ [정책표] 엑셀 파일 URL 추출: ${excelUrl}`);
      } else {
        console.warn(`⚠️ [정책표] 엑셀 파일 메시지에 엑셀 파일이 없습니다: ${excelMessageId}`);
      }
    } else {
      console.warn(`⚠️ [정책표] 엑셀 파일 메시지를 찾을 수 없습니다: ${excelMessageId}`);
    }
  } catch (excelError) {
    console.warn(`⚠️ [정책표] 엑셀 파일 URL 추출 실패: ${excelError.message}`);
    // 엑셀 파일이 없어도 이미지는 정상이므로 계속 진행
  }
}

console.log(`✅ [정책표] 스크린샷 생성 완료: ${imageUrl} (메시지 ID: ${messageId}, 스레드 ID: ${threadId})${excelUrl ? `, 엑셀: ${excelUrl}` : ''}`);
resolve({ imageUrl, messageId, threadId, excelUrl, excelMessageId });
```

#### 2-3. HEADERS_POLICY_TABLE_LIST 수정
**파일**: `server/policyTableRoutes.js`
**위치**: 라인 463-479

**수정 전**:
```javascript
const HEADERS_POLICY_TABLE_LIST = [
  '정책표ID',           // 0: 고유 ID
  '정책표ID_설정',      // 1: 설정과 연결된 ID
  '정책표이름',         // 2
  '정책적용일시',       // 3
  '정책적용내용',       // 4
  '접근권한',           // 5
  '생성자',             // 6
  '생성일시',           // 7
  '디스코드메시지ID',   // 8
  '디스코드스레드ID',   // 9
  '이미지URL',          // 10
  '등록여부',           // 11
  '등록일시',           // 12
  '생성자ID',           // 13: 생성자ID (N열)
  '확인이력'            // 14: 확인이력 (JSON 배열 형식) (O열)
];
```

**수정 후**:
```javascript
const HEADERS_POLICY_TABLE_LIST = [
  '정책표ID',           // 0: 고유 ID
  '정책표ID_설정',      // 1: 설정과 연결된 ID
  '정책표이름',         // 2
  '정책적용일시',       // 3
  '정책적용내용',       // 4
  '접근권한',           // 5
  '생성자',             // 6
  '생성일시',           // 7
  '디스코드메시지ID',   // 8
  '디스코드스레드ID',   // 9
  '이미지URL',          // 10
  '등록여부',           // 11
  '등록일시',           // 12
  '생성자ID',           // 13: 생성자ID (N열)
  '확인이력',           // 14: 확인이력 (JSON 배열 형식) (O열)
  '엑셀파일URL'         // 15: 엑셀파일URL (P열)
];
```

#### 2-4. processPolicyTableGeneration 수정
**파일**: `server/policyTableRoutes.js`
**위치**: 라인 1227-1233 (captureSheetViaDiscordBot 호출 부분)

**수정 전**:
```javascript
const { imageUrl, messageId: discordMessageId, threadId } = await captureSheetViaDiscordBot(
  sheetUrl,
  policyTableName,
  creatorName,
  discordChannelId,
  creatorPermissions
);
```

**수정 후**:
```javascript
const { imageUrl, messageId: discordMessageId, threadId, excelUrl, excelMessageId } = await captureSheetViaDiscordBot(
  sheetUrl,
  policyTableName,
  creatorName,
  discordChannelId,
  creatorPermissions
);
```

**위치**: 라인 1255-1270 (newRow 배열)

**수정 전**:
```javascript
const newRow = [
  newRowId,                    // 0: 정책표ID (고유 ID)
  policyTableId,               // 1: 정책표ID (설정과 연결)
  policyTableName,             // 2: 정책표이름
  applyDate,                   // 3: 정책적용일시
  applyContent,                // 4: 정책적용내용
  accessGroupIdsJson,          // 5: 접근권한 (그룹ID 배열 JSON)
  creatorName || 'Unknown',  // 6: 생성자 (이름)
  createdAt,                   // 7: 생성일시
  messageId,                   // 8: 디스코드메시지ID
  threadId,                    // 9: 디스코드스레드ID
  imageUrl,                    // 10: 이미지URL
  'N',                         // 11: 등록여부
  '',                          // 12: 등록일시
  creatorId || ''              // 13: 생성자ID (새로 추가)
];
```

**수정 후**:
```javascript
const newRow = [
  newRowId,                    // 0: 정책표ID (고유 ID)
  policyTableId,               // 1: 정책표ID (설정과 연결)
  policyTableName,             // 2: 정책표이름
  applyDate,                   // 3: 정책적용일시
  applyContent,                // 4: 정책적용내용
  accessGroupIdsJson,          // 5: 접근권한 (그룹ID 배열 JSON)
  creatorName || 'Unknown',  // 6: 생성자 (이름)
  createdAt,                   // 7: 생성일시
  messageId,                   // 8: 디스코드메시지ID
  threadId,                    // 9: 디스코드스레드ID
  imageUrl,                    // 10: 이미지URL
  'N',                         // 11: 등록여부
  '',                          // 12: 등록일시
  creatorId || '',             // 13: 생성자ID
  '',                          // 14: 확인이력 (기존 데이터 호환성)
  excelUrl || ''               // 15: 엑셀파일URL
];
```

**위치**: 라인 1272-1279 (sheets.spreadsheets.values.append)

**수정 전**:
```javascript
await withRetry(async () => {
  return await sheets.spreadsheets.values.append({
    spreadsheetId: SPREADSHEET_ID,
    range: `${SHEET_POLICY_TABLE_LIST}!A:N`,
    valueInputOption: 'USER_ENTERED',
    resource: { values: [newRow] }
  });
});
```

**수정 후**:
```javascript
await withRetry(async () => {
  return await sheets.spreadsheets.values.append({
    spreadsheetId: SPREADSHEET_ID,
    range: `${SHEET_POLICY_TABLE_LIST}!A:P`,
    valueInputOption: 'USER_ENTERED',
    resource: { values: [newRow] }
  });
});
```

#### 2-5. 엑셀 파일 다운로드 API 엔드포인트 추가
**파일**: `server/policyTableRoutes.js`
**위치**: `setupPolicyTableRoutes()` 함수 내부 (라인 5000 이후, refresh-image 엔드포인트 다음)

**추가할 코드**:
```javascript
// GET /api/policy-tables/:id/download-excel
router.get('/policy-tables/:id/download-excel', async (req, res) => {
  setCORSHeaders(req, res);
  try {
    const { id } = req.params;
    const { sheets, SPREADSHEET_ID } = createSheetsClient();
    await ensureSheetHeaders(sheets, SPREADSHEET_ID, SHEET_POLICY_TABLE_LIST, HEADERS_POLICY_TABLE_LIST);

    const response = await withRetry(async () => {
      return await sheets.spreadsheets.values.get({
        spreadsheetId: SPREADSHEET_ID,
        range: `${SHEET_POLICY_TABLE_LIST}!A:P`
      });
    });

    const rows = response.data.values || [];
    const row = rows.find(r => r[0] === id);

    if (!row) {
      return res.status(404).json({ success: false, error: '정책표를 찾을 수 없습니다.' });
    }

    const excelUrl = row[15]; // 엑셀파일URL (15번 인덱스)
    if (!excelUrl) {
      return res.status(404).json({ success: false, error: '엑셀 파일이 없습니다.' });
    }

    // 엑셀 파일 URL을 직접 반환 (클라이언트에서 다운로드)
    // 또는 프록시를 통해 파일 전송 가능
    res.json({
      success: true,
      excelUrl: excelUrl
    });

  } catch (error) {
    console.error('❌ [정책표] 엑셀 파일 다운로드 오류:', error);
    res.status(500).json({
      success: false,
      error: '엑셀 파일 다운로드에 실패했습니다.',
      message: error.message
    });
  }
});
```

---

### 3단계: 프론트엔드 수정

#### 3-1. 엑셀 다운로드 버튼 추가
**파일**: `src/components/policy/PolicyTableListTab.js`
**위치**: 라인 1426-1442 (이미지 다운로드 버튼 옆)

**수정 전**:
```javascript
<Box sx={{ mb: 2, display: 'flex', gap: 1 }}>
  <Button
    variant="outlined"
    startIcon={<RefreshIcon />}
    onClick={handleRefreshImage}
    disabled={loading}
  >
    정책다시확인하기
  </Button>
  <Button
    variant="outlined"
    startIcon={/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ? <DownloadIcon /> : <ContentCopyIcon />}
    onClick={handleCopyImage}
  >
    {/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ? '이미지 다운로드' : '이미지복사하기'}
  </Button>
</Box>
```

**수정 후**:
```javascript
<Box sx={{ mb: 2, display: 'flex', gap: 1 }}>
  <Button
    variant="outlined"
    startIcon={<RefreshIcon />}
    onClick={handleRefreshImage}
    disabled={loading}
  >
    정책다시확인하기
  </Button>
  <Button
    variant="outlined"
    startIcon={/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ? <DownloadIcon /> : <ContentCopyIcon />}
    onClick={handleCopyImage}
  >
    {/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ? '이미지 다운로드' : '이미지복사하기'}
  </Button>
  {selectedPolicy?.excelFileUrl && (
    <Button
      variant="outlined"
      startIcon={<DownloadIcon />}
      onClick={handleDownloadExcel}
    >
      엑셀파일다운로드
    </Button>
  )}
</Box>
```

#### 3-2. handleDownloadExcel 함수 추가
**파일**: `src/components/policy/PolicyTableListTab.js`
**위치**: `handleCopyImage` 함수 다음 (라인 880 이후)

**추가할 코드**:
```javascript
const handleDownloadExcel = async () => {
  if (!selectedPolicy || !selectedPolicy.excelFileUrl) return;

  try {
    // 엑셀 파일 URL에서 직접 다운로드
    const response = await fetch(selectedPolicy.excelFileUrl, {
      mode: 'cors',
      credentials: 'omit'
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const blob = await response.blob();
    
    // 파일 다운로드
    const blobUrl = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = blobUrl;
    link.download = `정책표_${selectedPolicy.policyTableName || selectedPolicy.id}_${new Date().toISOString().split('T')[0]}.xlsx`;
    link.style.display = 'none';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // Blob URL 정리
    setTimeout(() => URL.revokeObjectURL(blobUrl), 100);
    
    alert('엑셀 파일이 다운로드되었습니다.');
  } catch (error) {
    console.error('엑셀 파일 다운로드 오류:', error);
    alert('엑셀 파일 다운로드에 실패했습니다.');
  }
};
```

#### 3-3. 정책표 목록 조회 API 수정 (서버)
**파일**: `server/policyTableRoutes.js`
**위치**: 라인 4143-4148 (정책표 목록 조회 API)

**수정 전**:
```javascript
const response = await withRetry(async () => {
  return await sheets.spreadsheets.values.get({
    spreadsheetId: SPREADSHEET_ID,
    range: `${SHEET_POLICY_TABLE_LIST}!A:O`
  });
});
```

**수정 후**:
```javascript
const response = await withRetry(async () => {
  return await sheets.spreadsheets.values.get({
    spreadsheetId: SPREADSHEET_ID,
    range: `${SHEET_POLICY_TABLE_LIST}!A:P`
  });
});
```

**위치**: 라인 4230-4246 (응답 객체 생성 부분)

**수정 전**:
```javascript
return {
  id: row[0] || '',
  policyTableId: row[1] || '',
  policyTableName: row[2] || '',
  applyDate: row[3] || '',
  applyContent: row[4] || '',
  accessGroupId: accessGroupId,
  accessGroupNames: accessGroupNames,
  creator: row[6] || '',
  creatorId: row[13] || '',
  createdAt: row[7] || '',
  messageId: row[8] || '',
  threadId: row[9] || '',
  imageUrl: row[10] || '',
  registeredAt: row[12] || '',
  viewHistory: viewHistory
};
```

**수정 후**:
```javascript
return {
  id: row[0] || '',
  policyTableId: row[1] || '',
  policyTableName: row[2] || '',
  applyDate: row[3] || '',
  applyContent: row[4] || '',
  accessGroupId: accessGroupId,
  accessGroupNames: accessGroupNames,
  creator: row[6] || '',
  creatorId: row[13] || '',
  createdAt: row[7] || '',
  messageId: row[8] || '',
  threadId: row[9] || '',
  imageUrl: row[10] || '',
  registeredAt: row[12] || '',
  viewHistory: viewHistory,
  excelFileUrl: row[15] || '' // 엑셀파일URL 추가
};
```

#### 3-4. 정책표 상세 조회 API 수정 (서버)
**파일**: `server/policyTableRoutes.js`
**위치**: 라인 4734-4739 (정책표 상세 조회 API)

**수정 전**:
```javascript
const response = await withRetry(async () => {
  return await sheets.spreadsheets.values.get({
    spreadsheetId: SPREADSHEET_ID,
    range: `${SHEET_POLICY_TABLE_LIST}!A:O`
  });
});
```

**수정 후**:
```javascript
const response = await withRetry(async () => {
  return await sheets.spreadsheets.values.get({
    spreadsheetId: SPREADSHEET_ID,
    range: `${SHEET_POLICY_TABLE_LIST}!A:P`
  });
});
```

**위치**: 라인 4975-4991 (정책표 상세 조회 API의 응답 객체 생성 부분)

**수정 전**:
```javascript
const policy = {
  id: row[0] || '',
  policyTableId: row[1] || '',
  policyTableName: row[2] || '',
  applyDate: row[3] || '',
  applyContent: row[4] || '',
  accessGroupId: accessGroupId,
  accessGroupNames: accessGroupNames,
  creator: row[6] || '',
  creatorId: row[13] || '',
  createdAt: row[7] || '',
  messageId: row[8] || '',
  threadId: row[9] || '',
  imageUrl: row[10] || '',
  registeredAt: row[12] || '',
  viewHistory: viewHistory
};
```

**수정 후**:
```javascript
const policy = {
  id: row[0] || '',
  policyTableId: row[1] || '',
  policyTableName: row[2] || '',
  applyDate: row[3] || '',
  applyContent: row[4] || '',
  accessGroupId: accessGroupId,
  accessGroupNames: accessGroupNames,
  creator: row[6] || '',
  creatorId: row[13] || '',
  createdAt: row[7] || '',
  messageId: row[8] || '',
  threadId: row[9] || '',
  imageUrl: row[10] || '',
  registeredAt: row[12] || '',
  viewHistory: viewHistory,
  excelFileUrl: row[15] || '' // 엑셀파일URL 추가
};
```

**⚠️ 확인**: 원본 코드에서 `policyTableName: row[2]`가 맞는지 확인 (라인 4978 확인됨)

---

## 🔍 구현 전 최종 확인 사항

### 환경 변수 확인
로컬 디스코드 봇의 `.env` 파일에 다음이 있어야 함:
- `GOOGLE_SERVICE_ACCOUNT_EMAIL`
- `GOOGLE_PRIVATE_KEY`

### ⚠️ 중요: Google Sheets 접근 권한 설정 (필수)

#### Google Sheets API 방식 사용 (서비스 계정 권한 필수)
**현재 구현 방식**: Google Sheets API만 사용 (`downloadExcelWithAPI`)
- **필요한 권한**: 각 정책표 Google Sheets에 서비스 계정을 "뷰어"로 공유 (필수)
- **작동 방식**: `downloadExcelWithAPI()` 사용
- **장점**: 
  - 안정적인 접근
  - 서식 보존 우수 (행 높이, 열 너비, 병합, 셀 스타일 등)
  - 첫 번째 시트만 추출 및 수식 변환 가능

#### 서비스 계정 권한 설정 방법 (필수 작업)

**1단계: 서비스 계정 이메일 확인**
- Google Cloud Console에서 서비스 계정 이메일 확인
- 환경 변수 `GOOGLE_SERVICE_ACCOUNT_EMAIL` 값 확인
- 예: `vip-service-account@project-id.iam.gserviceaccount.com`

**2단계: 각 정책표 Google Sheets에 서비스 계정 공유**
각 정책표 Google Sheets마다 다음 작업 수행:

1. 정책표 Google Sheets 열기
2. 우측 상단 "공유" 버튼 클릭
3. 서비스 계정 이메일 입력 (또는 붙여넣기)
4. 권한 선택: **"뷰어"** (읽기만 필요하므로)
5. "완료" 또는 "보내기" 클릭

**3단계: 권한 확인**
- 서비스 계정이 각 시트에 "뷰어" 권한으로 공유되었는지 확인
- 공유 목록에 서비스 계정 이메일이 표시되어야 함

**주의사항**:
- ⚠️ **서비스 계정 권한이 없으면 엑셀 파일 생성이 실패합니다**
- ⚠️ 각 정책표 시트마다 개별적으로 공유해야 합니다
- ⚠️ "편집자" 권한은 불필요합니다 (읽기만 필요)

### 디렉토리 권한 확인
- `./excel` 디렉토리 생성/쓰기 권한

### 패키지 설치
로컬 디스코드 봇 디렉토리에서:
```bash
npm install
```

---

## ✅ 구현 완료 확인 체크리스트 (상세 검증 포함)

### 로컬 디스코드 봇

#### 1-1. 패키지 추가
- [ ] `package.json`에 `googleapis` 추가 확인
- [ ] `package.json`에 `xlsx` 추가 확인
- [ ] `npm install` 실행 완료
- [ ] 패키지 설치 오류 없음 확인

#### 1-2. 모듈 import 추가
- [ ] `AttachmentBuilder` import 추가 확인
- [ ] `google` import 추가 확인
- [ ] `XLSX` import 추가 확인
- [ ] `fs.promises` import 추가 확인
- [ ] `path` import 추가 확인
- [ ] **검증**: 파일 상단에 모든 import가 정확히 추가되었는지 확인

#### 1-3. 참고 코드 함수 추가
- [ ] `getGoogleAuth()` 함수 추가 확인
  - [ ] 환경 변수 사용 확인 (`GOOGLE_SERVICE_ACCOUNT_EMAIL`, `GOOGLE_PRIVATE_KEY`)
  - [ ] 스코프 설정 확인 (`drive.readonly`, `spreadsheets.readonly`)
- [ ] `downloadExcelWithAPI()` 함수 추가 확인
  - [ ] userId 파라미터 제거 또는 console.log로 대체 확인
  - [ ] Google Drive API 사용 확인
  - [ ] XLSX 라이브러리 사용 확인
  - [ ] 첫 번째 시트만 추출 로직 확인
  - [ ] 수식 변환 로직 확인
- [ ] **검증**: 함수들이 정확히 복사되었고, userId 관련 코드가 모두 처리되었는지 확인

#### 1-4. 엑셀 파일 생성 로직 추가
- [ ] 이미지 업로드 후, 완료 신호 전송 전에 추가 확인
- [ ] excel 디렉토리 생성 로직 확인
- [ ] spreadsheetId 추출 로직 확인
- [ ] 파일명 생성 로직 확인 (특수문자 처리)
- [ ] `downloadExcelWithAPI()` 호출 확인
- [ ] 에러 처리 확인 (엑셀 실패해도 이미지는 정상)
- [ ] 디스코드 업로드 로직 확인
- [ ] 임시 파일 삭제 로직 확인
- [ ] **검증**: 코드 블록이 완전히 추가되었는지 확인 (중괄호, 세미콜론 등)

#### 1-5. 완료 신호에 excelId 추가
- [ ] `excelMessageId` 변수 선언 확인
- [ ] 완료 신호에 excelId 조건부 추가 확인
- [ ] **검증**: 완료 신호 형식이 `!screenshot-complete commandId=... imageId=... excelId=...` 또는 `!screenshot-complete commandId=... imageId=...` (excelId 없을 때)인지 확인

### 서버

#### 2-1. 완료 신호 파싱 로직 수정
- [ ] excelId 파싱 로직 추가 확인
- [ ] excelMessage 가져오기 로직 확인
- [ ] excelAttachment 확인 로직 확인 (`.xlsx` 확장자 체크)
- [ ] excelUrl 추출 로직 확인
- [ ] 에러 처리 확인 (excelId 없어도 정상 진행)
- [ ] 반환값에 `excelUrl`, `excelMessageId` 추가 확인
- [ ] **검증**: 이미지 URL 추출과 동일한 패턴으로 엑셀 URL도 추출되는지 확인

#### 2-2. HEADERS_POLICY_TABLE_LIST 수정
- [ ] '엑셀파일URL' 컬럼 추가 확인 (15번 인덱스)
- [ ] 주석 확인 (P열)
- [ ] **검증**: 배열 길이가 16인지 확인 (0-15)

#### 2-3. processPolicyTableGeneration 수정
- [ ] `captureSheetViaDiscordBot()` 호출 시 `excelUrl`, `excelMessageId` 구조 분해 할당 확인
- [ ] `newRow` 배열에 `excelUrl || ''` 추가 확인 (15번 인덱스)
- [ ] `newRow` 배열에 확인이력 빈 값 추가 확인 (14번 인덱스, 기존 데이터 호환성)
- [ ] `sheets.spreadsheets.values.append`의 range를 `A:P`로 변경 확인
- [ ] **검증**: newRow 배열 길이가 16인지 확인 (0-15)

#### 2-4. 정책표 목록 조회 API 수정
- [ ] range를 `A:O`에서 `A:P`로 변경 확인
- [ ] 응답 객체에 `excelFileUrl: row[15] || ''` 추가 확인
- [ ] **검증**: API 응답에 excelFileUrl 필드가 포함되는지 확인

#### 2-5. 정책표 상세 조회 API 수정
- [ ] range를 `A:O`에서 `A:P`로 변경 확인
- [ ] 응답 객체에 `excelFileUrl: row[15] || ''` 추가 확인
- [ ] **검증**: API 응답에 excelFileUrl 필드가 포함되는지 확인

#### 2-6. 엑셀 다운로드 API 엔드포인트 추가
- [ ] 엔드포인트 추가 확인 (`GET /api/policy-tables/:id/download-excel`)
- [ ] range를 `A:P`로 설정 확인
- [ ] excelUrl 조회 로직 확인 (row[15])
- [ ] 에러 처리 확인
- [ ] **검증**: 엔드포인트가 정확한 위치에 추가되었는지 확인

### 프론트엔드

#### 3-1. 엑셀 다운로드 버튼 추가
- [ ] 버튼이 이미지 다운로드 버튼 옆에 추가되었는지 확인
- [ ] `selectedPolicy?.excelFileUrl` 조건 확인
- [ ] 버튼이 excelFileUrl이 있을 때만 표시되는지 확인
- [ ] **검증**: UI에서 버튼이 올바른 위치에 표시되는지 확인

#### 3-2. handleDownloadExcel 함수 추가
- [ ] 함수가 `handleCopyImage` 다음에 추가되었는지 확인
- [ ] excelFileUrl 체크 로직 확인
- [ ] fetch 로직 확인
- [ ] Blob 다운로드 로직 확인
- [ ] 에러 처리 확인
- [ ] **검증**: 함수가 완전히 추가되었고, 모든 중괄호가 닫혔는지 확인

#### 3-3. 정책표 목록에서 excelFileUrl 포함 확인
- [ ] 서버 API가 excelFileUrl을 반환하는지 확인 (2-4에서 수정)
- [ ] 프론트엔드에서 excelFileUrl을 사용하는지 확인
- [ ] **검증**: 브라우저 개발자 도구에서 API 응답에 excelFileUrl이 포함되는지 확인

---

## 🔍 구현 후 검증 체크리스트

### 기능 검증
- [ ] 정책표 생성 시 엑셀 파일도 생성되는지 확인
- [ ] 디스코드에 엑셀 파일이 업로드되는지 확인
- [ ] 정책표 목록에 엑셀 다운로드 버튼이 표시되는지 확인 (엑셀 파일이 있는 경우)
- [ ] 엑셀 다운로드 버튼 클릭 시 파일이 다운로드되는지 확인
- [ ] 엑셀 파일이 없는 정책표는 버튼이 표시되지 않는지 확인

### 에러 시나리오 검증
- [ ] 서비스 계정 권한이 없을 때 엑셀 파일 생성 실패해도 이미지는 정상 생성되는지 확인
- [ ] 엑셀 파일 생성 실패 시 완료 신호에 excelId가 없는지 확인
- [ ] excelId가 없을 때 서버에서 빈 값으로 처리되는지 확인
- [ ] 엑셀 파일이 없는 정책표에서 버튼이 표시되지 않는지 확인

### 데이터 검증
- [ ] 구글시트에 엑셀파일URL 컬럼이 추가되었는지 확인
- [ ] 새로 생성된 정책표에 엑셀파일URL이 저장되는지 확인
- [ ] 정책표 목록 API 응답에 excelFileUrl이 포함되는지 확인
- [ ] 정책표 상세 API 응답에 excelFileUrl이 포함되는지 확인

### 코드 검증
- [ ] 모든 함수의 중괄호가 올바르게 닫혔는지 확인
- [ ] 모든 변수 선언이 올바른지 확인
- [ ] import 문이 모두 올바른지 확인
- [ ] 문법 오류가 없는지 확인 (linter 실행)

---

## 📋 최종 정리

### 구현 방식
- **방법**: Google Sheets API 방식만 사용 (안정성 우선)
- **필수 작업**: 각 정책표 Google Sheets에 서비스 계정을 "뷰어"로 공유

### 구현 전 필수 확인 사항

#### 1. 환경 변수 설정
로컬 디스코드 봇의 `.env` 파일:
```
GOOGLE_SERVICE_ACCOUNT_EMAIL=서비스계정이메일@프로젝트ID.iam.gserviceaccount.com
GOOGLE_PRIVATE_KEY="-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----\n"
```

#### 2. 서비스 계정 권한 설정 (필수)
각 정책표 Google Sheets마다:
1. 시트 열기
2. "공유" 버튼 클릭
3. 서비스 계정 이메일 추가
4. 권한: "뷰어" 선택
5. 저장

#### 3. 패키지 설치
```bash
cd local-discord-bot
npm install
```

### 구현 순서 요약

1. **로컬 디스코드 봇 수정** (5단계)
   - 패키지 추가
   - 모듈 import 추가
   - 참고 코드 함수 추가 (`getGoogleAuth`, `downloadExcelWithAPI`)
   - 엑셀 파일 생성 로직 추가
   - 완료 신호에 excelId 추가

2. **서버 코드 수정** (5단계)
   - 완료 신호 파싱 로직 수정
   - HEADERS_POLICY_TABLE_LIST 수정
   - processPolicyTableGeneration 수정
   - 엑셀 다운로드 API 엔드포인트 추가

3. **프론트엔드 수정** (3단계)
   - 엑셀 다운로드 버튼 추가
   - handleDownloadExcel 함수 추가
   - 정책표 목록에서 excelFileUrl 포함 확인

### 핵심 포인트

✅ **서비스 계정 권한 필수**: 각 정책표 시트에 서비스 계정을 "뷰어"로 공유해야 함  
✅ **안정적인 작동**: Google Sheets API를 통한 직접 접근으로 안정성 확보  
✅ **서식 보존**: 행 높이, 열 너비, 병합, 셀 스타일 등 모든 서식 정보 보존  
✅ **수식 변환**: 첫 번째 시트만 추출하고 수식을 값으로 변환  
✅ **에러 처리**: 엑셀 파일 생성 실패해도 이미지는 정상 생성

### 예상 작동 흐름

1. 정책표 생성 요청
2. 로컬 디스코드 봇이 이미지 생성
3. 로컬 디스코드 봇이 Google Sheets API로 엑셀 파일 다운로드
4. XLSX 라이브러리로 첫 번째 시트만 추출 및 수식 변환
5. 이미지와 엑셀 파일을 디스코드에 업로드
6. 완료 신호 전송 (imageId + excelId)
7. 서버에서 엑셀 파일 URL 저장
8. 프론트엔드에서 엑셀 다운로드 버튼 표시

---

## 🎯 구현 시작 준비 완료

### ✅ 모든 준비 완료 확인

1. **참고 코드 분석 완료**
   - 정상 작동하는 검증된 코드 기반
   - 모든 핵심 함수 로직 파악 완료
   - 에러 처리 및 엣지 케이스 파악 완료
   - userId 파라미터 제거 방법 명시 완료

2. **프로젝트 구조 파악 완료**
   - 로컬 디스코드 봇 구조 확인 완료
   - 서버 코드 구조 확인 완료
   - 데이터 저장 구조 확인 완료
   - 프론트엔드 구조 확인 완료
   - API 엔드포인트 위치 확인 완료

3. **구현 가이드 작성 완료**
   - 각 파일별 정확한 수정 위치 (라인 번호 포함)
   - 수정 전/후 코드 비교 (완전한 코드 블록 제공)
   - 단계별 상세 구현 방법
   - 구현 전 확인 사항
   - 구현 완료 체크리스트 (상세 검증 포함)
   - 구현 후 검증 체크리스트 추가

4. **구현 방식 결정 완료**
   - Google Sheets API 방식만 사용 (안정성 우선)
   - 서비스 계정 권한 설정 방법 명시
   - 모든 필요한 API 엔드포인트 수정 위치 확인 완료

5. **누락 방지 장치 완료**
   - 모든 수정 위치에 라인 번호 명시
   - 수정 전/후 코드 완전히 제공
   - 각 단계별 검증 항목 추가
   - 구현 후 검증 체크리스트 추가
   - 에러 시나리오 검증 항목 추가

### 🔧 구현 전 필수 작업 체크리스트

**로컬 디스코드 봇 환경 설정**:
- [ ] `.env` 파일에 `GOOGLE_SERVICE_ACCOUNT_EMAIL` 설정
- [ ] `.env` 파일에 `GOOGLE_PRIVATE_KEY` 설정
- [ ] 패키지 설치 (`npm install`)

**Google Sheets 권한 설정** (필수):
- [ ] 서비스 계정 이메일 확인
- [ ] 각 정책표 Google Sheets에 서비스 계정 "뷰어" 권한으로 공유
  - 정책표 1: [ ] 공유 완료
  - 정책표 2: [ ] 공유 완료
  - 정책표 3: [ ] 공유 완료
  - (각 정책표마다 체크)

### 📝 구현 순서

1. **로컬 디스코드 봇 수정** (5단계)
2. **서버 코드 수정** (5단계)
3. **프론트엔드 수정** (3단계)

각 단계별 상세 내용은 위의 "구현 단계별 상세 가이드" 섹션을 참고하세요.

---

## ✅ 최종 확인

**모든 정보가 정리되었고, 각 단계별로 정확한 수정 위치와 코드가 명시되어 있습니다.**

**구현 전 필수 작업을 완료한 후, 구현을 시작하세요!**

---

## ⚠️ 구현 시 주의사항 (버그 방지)

### 1. 코드 복사 시 주의사항
- **완전한 코드 블록 복사**: 중괄호, 세미콜론 등 모든 문법 요소 포함
- **변수명 일관성**: `excelMessageId`, `excelUrl` 등 변수명이 정확히 일치하는지 확인
- **함수 호출 파라미터**: 함수 시그니처와 호출 시 파라미터가 일치하는지 확인

### 2. userId 파라미터 제거 시 주의사항
- **함수 시그니처**: `downloadExcelWithAPI(spreadsheetId, filePath)` (userId 제거)
- **함수 내부**: 모든 `debugLog(userId, ...)` → `console.log(...)` 변경
- **검증**: 함수 내부에 `userId` 변수를 참조하는 코드가 없는지 확인

### 3. 배열 인덱스 확인
- **HEADERS_POLICY_TABLE_LIST**: 엑셀파일URL은 15번 인덱스 (P열)
- **newRow 배열**: 16개 요소 (0-15)
- **API range**: `A:P` (P열까지)
- **row[15]**: 엑셀파일URL 조회 시 사용

### 4. 완료 신호 형식 확인
- **성공 시**: `!screenshot-complete commandId=... imageId=... excelId=...`
- **실패 시**: `!screenshot-complete commandId=... imageId=...` (excelId 없음)
- **서버 파싱**: excelId가 없어도 정상 처리 (선택적)

### 5. 에러 처리 확인
- **엑셀 파일 생성 실패해도 이미지는 정상 생성**
- **excelId가 없어도 정책표 생성은 정상 완료**
- **프론트엔드에서 excelFileUrl이 없으면 버튼 숨김**

---

## ✅ 최종 확인

**모든 정보가 정리되었고, 각 단계별로 정확한 수정 위치와 코드가 명시되어 있습니다.**

**구현 전 필수 작업을 완료한 후, 구현을 시작하세요!**

**이제 구현을 시작해도 좋습니다!** 🚀
