# 정책영업그룹 및 일반정책모드 최종 구현 가이드

## 📋 목차
1. [핵심 이해](#핵심-이해)
2. [정책영업그룹 수정](#정책영업그룹-수정)
3. [일반정책모드 추가](#일반정책모드-추가)
4. [필터링 로직 상세](#필터링-로직-상세)
5. [데이터 구조](#데이터-구조)
6. [구현 체크리스트](#구현-체크리스트)
7. [최종 점검](#최종-점검)

---

## 🎯 핵심 이해

### 정책영업그룹의 목적과 역할

**정책영업그룹은 왜 필요한가?**
- 정책표 생성 시 매번 많은 업체나 담당자를 개별적으로 선택하기 어려움
- 미리 그룹으로 묶어두면 정책표 생성 시 그룹만 선택하면 됨
- 정책표 목록에서 필터링 기준으로 사용됨

**두 가지 사용 시나리오:**

1. **정책모드 (관리자 모드)**
   - **목적:** 담당자들이 자신이 담당하는 정책표만 확인할 수 있게 함
   - **필터링 기준:** 정책영업그룹의 `managerIds` (담당자 아이디 배열)
   - **로직:** 정책표의 접근권한(그룹ID) → 그룹의 `managerIds`에 현재 사용자 아이디가 포함되어 있으면 표시

2. **일반정책모드 (일반 모드)**
   - **목적:** 업체들이 자신의 업체와 관련된 정책표만 확인할 수 있게 함
   - **필터링 기준:** 정책영업그룹의 `companyNames` (업체명 배열)
   - **로직:** 정책표의 접근권한(그룹ID) → 그룹의 `companyNames`에 현재 사용자의 업체명이 포함되어 있으면 표시

**핵심 포인트:**
- 정책표에는 업체명이나 담당자 정보가 직접 저장되지 않음
- 정책표의 '접근권한' 필드에 정책영업그룹의 그룹ID만 저장됨
- 그룹ID를 통해 정책영업그룹을 찾고, 그룹의 `companyNames` 또는 `managerIds`로 필터링

---

## 📝 정책영업그룹 수정

### 1. 데이터 구조 변경

#### 1.1 기존 구조
- **시트:** `정책모드_일반사용자그룹`
- **저장 형식:** `row[2] = '["A", "B", "C"]'` (권한 레벨 배열)
- **문제점:** 권한 레벨만 저장되어 업체명과 담당자를 구분할 수 없음

#### 1.2 변경 후 구조
- **저장 형식:** `row[2] = '{"companyNames": ["업체1", "업체2"], "managerIds": ["01012345678", "01087654321"]}'`
- **업체명 필드:** `companyNames` (배열) - 일반모드권한관리 시트의 B열 업체명
- **담당자 필드:** `managerIds` (배열) - 일반모드권한관리 시트의 K열 담당자 아이디

#### 1.3 기존 데이터 처리
- 기존 `userIds` (권한 레벨 배열)는 무시
- 기존 그룹을 수정할 때 새로운 형식으로 초기화
- `companyNames`와 `managerIds`는 빈 배열로 시작 (사용자가 직접 선택)

### 2. 정책영업그룹 추가 모달 수정

#### 2.1 변경 사항
- **기존:** "일반사용자" 선택 (권한 레벨 기반)
- **변경:** "업체명" 선택 (업체명 기반)

#### 2.2 업체명 데이터 소스
- **시트:** `일반모드권한관리`
- **업체명 위치:** B열 (인덱스 1), 4행부터
- **선택 가능 조건:** I열 (인덱스 8)에 "O" 권한이 있는 업체명만
- **담당자 아이디 위치:** K열 (인덱스 10)

#### 2.3 자동 선택 로직
1. 현재 로그인한 사용자의 아이디 확인 (`loggedInStore?.contactId` 또는 `loggedInStore?.id`)
2. 일반모드권한관리 시트의 K열에서 해당 아이디가 있는 행 찾기
3. 해당 행의 B열 업체명을 자동으로 선택된 상태로 표시
4. 업체명을 선택하면 해당 업체의 K열 담당자 아이디를 자동으로 `managerIds`에 추가

### 3. API 변경사항

#### 3.1 정책영업그룹 API
- **GET /api/policy-table/user-groups:** `companyNames`와 `managerIds` 반환
- **POST /api/policy-table/user-groups:** `companyNames`와 `managerIds` 받아서 저장
- **PUT /api/policy-table/user-groups/:id:** 기존 `userIds` 형식이면 새로운 형식으로 변환
- **DELETE /api/policy-table/user-groups/:id:** 변경 없음

#### 3.2 정책표목록 API
- **GET /api/policy-tables:** 필터링 로직 변경
  - 정책모드: `managerIds` 기반 필터링
  - 일반정책모드: `companyNames` 기반 필터링 (새로 추가)

---

## 🆕 일반정책모드 추가

### 1. 모드 설정

#### 1.1 modeConfig.js 추가
```javascript
generalPolicy: {
  key: 'generalPolicy',
  title: '일반정책모드',
  description: '정책표를 확인하고 조회합니다.',
  features: [
    '정책표 목록 조회',
    '정책표 상세 보기',
    '검색 및 필터링'
  ],
  color: '#FF9800',  // TODO: 색상 결정 필요
  icon: PolicyIcon,  // TODO: 아이콘 결정 필요
  category: 'general',
  sheetRefs: {
    general: '일반모드권한관리!I열',  // I열 (인덱스 8) - 권한 체크
    updates: '어플업데이트!Z열'       // Z열 (인덱스 25) - 업데이트
  }
}
```

### 2. 권한 및 비밀번호

#### 2.1 일반모드권한관리 시트 구조
- **A열 (인덱스 0):** 사용자ID(POS코드)
- **B열 (인덱스 1):** 업체명
- **C열 (인덱스 2):** 그룹/영업담당
- **D열 (인덱스 3):** 기본 모드 권한
- **E열 (인덱스 4):** 온세일접수 모드 권한
- **F열 (인덱스 5):** 온세일접수 모드 비밀번호
- **G열 (인덱스 6):** 직영점 모드 권한
- **H열 (인덱스 7):** 직영점 모드 비밀번호
- **I열 (인덱스 8):** 일반정책모드 권한 ('O' 권한 있음) ⭐
- **J열 (인덱스 9):** 일반정책모드 비밀번호 ⭐
- **K열 (인덱스 10):** 담당자 아이디 ⭐

**중요:** 현재 코드는 A~H열만 읽음. I, J, K열을 읽으려면 범위를 A~K열로 확장 필요

#### 2.2 권한 체크 로직
- 로그인 시 일반모드권한관리 시트의 I열 확인
- I열에 "O" 권한이 있으면 `modePermissions.generalPolicy = true` 또는 `'O'` 설정

#### 2.3 비밀번호 확인
- **백엔드 API:** `/api/check-general-policy-permission`
- **로직:** 온세일접수모드와 동일한 패턴
  - 일반모드권한관리 시트에서 사용자 찾기 (A~K열 범위)
  - I열 권한 확인 (값이 "O"인지)
  - J열 비밀번호 확인
  - 헤더는 3행(인덱스 2), 데이터는 4행(인덱스 3)부터

### 3. 어플업데이트

#### 3.1 appUpdateService.js 수정
```javascript
const UPDATE_SHEET_COLUMNS = {
  // ...
  QUICK_SERVICE_MANAGEMENT: 24, // Y열: 퀵서비스 관리 모드
  GENERAL_POLICY: 25            // Z열: 일반정책모드 (추가)
};

const MODE_COLUMN_MAP = {
  // ...
  'generalPolicy': UPDATE_SHEET_COLUMNS.GENERAL_POLICY,  // 추가
  'general-policy': UPDATE_SHEET_COLUMNS.GENERAL_POLICY  // 별칭 추가
};
```

### 4. 컴포넌트 생성

#### 4.1 GeneralPolicyMode.js
- **참고:** `OnSaleReceptionMode.js`
- **구조:**
  - 비밀번호 입력 다이얼로그
  - 인증 상태 관리
  - 정책표 목록 탭 (정책모드의 `PolicyTableListTab`과 동일)

#### 4.2 App.js 수정
- `setIsGeneralPolicyMode(true)` 상태 추가
- `setCurrentMode('generalPolicy')` 설정
- 라우팅 추가

---

## 🔍 필터링 로직 상세

### 1. 정책모드 필터링 (기존 로직 변경)

#### 1.1 현재 로직 (변경 전)
```javascript
// 정책영업그룹의 userIds에 권한 레벨이 포함되어 있으면 표시
const userIds = userGroupsMap.get(accessGroupId) || [];
return userIds.includes(userRole); // userRole은 "A", "B", "C" 등
```

#### 1.2 변경 후 로직
```javascript
// 정책영업그룹의 managerIds에 현재 사용자 아이디가 포함되어 있으면 표시
const groupData = userGroupsMap.get(accessGroupId);
if (!groupData) return false;

// 새로운 형식: {"companyNames": [...], "managerIds": [...]}
const managerIds = groupData.managerIds || [];
const currentUserId = req.headers['x-user-id']; // 현재 사용자 아이디

return managerIds.includes(currentUserId);
```

#### 1.3 필터링 흐름
1. 정책표 목록 조회
2. 각 정책표의 '접근권한' 필드(row[5])에서 그룹ID 확인
3. 정책영업그룹 목록에서 해당 그룹 찾기
4. 그룹의 `managerIds`에 현재 사용자 아이디가 포함되어 있는지 확인
5. 포함되어 있으면 표시, 없으면 숨김

### 2. 일반정책모드 필터링 (새로 추가)

#### 2.1 필터링 로직
```javascript
// 1. 현재 사용자의 업체명 확인
// 일반모드권한관리 시트에서 현재 사용자 아이디가 있는 행 찾기
// A열(인덱스 0)에 사용자ID가 있거나, K열(인덱스 10)에 담당자 아이디가 있는 행 찾기
// 해당 행의 B열(인덱스 1) 업체명 가져오기
const currentUserId = req.headers['x-user-id'];
const generalModeSheet = await getGeneralModeSheet(); // A~K열 범위, 4행부터
const userRow = generalModeSheet.find(row => 
  row[0] === currentUserId || row[10] === currentUserId  // A열 또는 K열
);
const userCompanyName = userRow ? userRow[1] : null; // B열 업체명

if (!userCompanyName) {
  return false; // 업체명을 찾을 수 없으면 표시하지 않음
}

// 2. 정책표의 접근권한(그룹ID)으로 정책영업그룹 찾기
const groupData = userGroupsMap.get(accessGroupId);
if (!groupData) return false;

// 3. 그룹의 companyNames에 사용자 업체명이 포함되어 있는지 확인
const companyNames = groupData.companyNames || [];
return companyNames.includes(userCompanyName);
```

#### 2.2 필터링 흐름
1. 현재 로그인한 사용자의 아이디 확인
2. 일반모드권한관리 시트에서 해당 아이디 찾기
   - A열(인덱스 0)에 사용자ID가 있거나
   - K열(인덱스 10)에 담당자 아이디가 있는 행 찾기
3. 해당 행의 B열(인덱스 1)에서 업체명 가져오기
4. 정책표 목록 조회
5. 각 정책표의 '접근권한' 필드에서 그룹ID 확인
6. 정책영업그룹 목록에서 해당 그룹 찾기
7. 그룹의 `companyNames`에 사용자 업체명이 포함되어 있는지 확인
8. 포함되어 있으면 표시, 없으면 숨김

### 3. 필터링 비교표

| 구분 | 정책모드 | 일반정책모드 |
|------|---------|------------|
| **필터링 기준** | 담당자 아이디 | 업체명 |
| **데이터 소스** | 정책영업그룹의 `managerIds` | 정책영업그룹의 `companyNames` |
| **사용자 식별** | 현재 사용자 아이디 | 현재 사용자 아이디 → 업체명 변환 |
| **변환 필요** | 없음 | 일반모드권한관리 시트에서 K열 → B열 |
| **목적** | 담당자가 자신이 담당하는 정책만 확인 | 업체가 자신의 업체와 관련된 정책만 확인 |

---

## 💾 데이터 구조

### 1. 정책영업그룹 저장 구조

#### 1.1 시트 구조
- **시트명:** `정책모드_일반사용자그룹`
- **헤더:** ['그룹ID', '그룹이름', '일반사용자목록', '등록일시', '등록자']
- **row[2] 형식:**
  ```json
  {
    "companyNames": ["업체1", "업체2", "업체3"],
    "managerIds": ["01012345678", "01087654321", "01011111111"]
  }
  ```

#### 1.2 데이터 예시
```
그룹ID: UG_1234567890
그룹이름: "경수일반"
일반사용자목록: {"companyNames": ["경수통신", "경수대리점"], "managerIds": ["01012345678", "01087654321"]}
등록일시: 2025-12-30T10:00:00Z
등록자: 홍길동
```

### 2. 정책표 저장 구조

#### 2.1 시트 구조
- **시트명:** `정책모드_정책표목록`
- **주요 필드:**
  - row[5] = 접근권한 (그룹ID) - 정책영업그룹의 그룹ID
  - row[6] = 생성자 (이름) - 정책표를 생성한 사람의 이름 (표시용)

#### 2.2 데이터 예시
```
정책표ID: PT_1234567890
정책표ID_설정: PT_SETTING_001
정책표이름: "2025년 1월 정책"
정책적용일시: "2025-01-01"
정책적용내용: "신규 정책 적용"
접근권한: UG_1234567890  ← 정책영업그룹의 그룹ID
생성자: 홍길동
...
```

### 3. 일반모드권한관리 시트 구조

#### 3.1 컬럼 구조
- **A열 (0):** 사용자ID(POS코드)
- **B열 (1):** 업체명 ⭐
- **C열 (2):** 그룹/영업담당
- **D열 (3):** 기본 모드 권한
- **E열 (4):** 온세일접수 모드 권한
- **F열 (5):** 온세일접수 모드 비밀번호
- **G열 (6):** 직영점 모드 권한
- **H열 (7):** 직영점 모드 비밀번호
- **I열 (8):** 일반정책모드 권한 ⭐
- **J열 (9):** 일반정책모드 비밀번호 ⭐
- **K열 (10):** 담당자 아이디 ⭐

#### 3.2 데이터 예시
```
사용자ID: 01012345678
업체명: 경수통신
그룹: A그룹
기본모드: O
온세일접수모드: O
온세일접수비밀번호: 1234
직영점모드: 
직영점비밀번호: 
일반정책모드: O  ← I열
일반정책모드비밀번호: 5678  ← J열
담당자아이디: 01012345678  ← K열
```

---

## ✅ 구현 체크리스트

### 1. 정책영업그룹 수정

#### 1.1 프론트엔드
- [ ] `src/components/policy/PolicyTableCreationTab.js`
  - [ ] 업체명 선택 Autocomplete로 변경
  - [ ] 일반모드권한관리 시트에서 업체명 로드 (B열, I열="O" 조건)
  - [ ] 로그인 사용자 업체명 자동 선택 (K열 → B열)
  - [ ] 업체명 선택 시 K열 담당자 아이디 자동 추가
  - [ ] `companyNames`와 `managerIds` 저장

#### 1.2 백엔드
- [ ] `server/policyTableRoutes.js`
  - [ ] GET `/api/policy-table/user-groups`: 새로운 형식 파싱 및 반환
  - [ ] POST `/api/policy-table/user-groups`: `companyNames`와 `managerIds` 받아서 저장
  - [ ] PUT `/api/policy-table/user-groups/:id`: 기존 `userIds` 형식이면 새로운 형식으로 변환
  - [ ] 정책표목록 필터링 로직 변경 (정책모드: `managerIds` 기반)

### 2. 일반정책모드 추가

#### 2.1 프론트엔드
- [ ] `src/config/modeConfig.js`: 일반정책모드 추가
- [ ] `src/utils/appUpdateService.js`: Z열 인덱스 추가
- [ ] `src/components/GeneralPolicyMode.js`: 새 컴포넌트 생성
- [ ] `src/App.js`: 일반정책모드 라우팅 추가
- [ ] `src/components/meeting/ModeSelector.js`: 일반정책모드 추가

#### 2.2 백엔드
- [ ] `server/index.js`
  - [ ] 로그인 API: 일반모드권한관리 시트 읽기 범위를 A~K열로 확장
  - [ ] 로그인 API: I열 권한 체크 및 `modePermissions.generalPolicy` 설정
  - [ ] `/api/check-general-policy-permission` 엔드포인트 추가
- [ ] `server/policyTableRoutes.js`
  - [ ] GET `/api/policy-tables`: 일반정책모드 필터링 로직 추가
  - [ ] 사용자 업체명 확인 로직 추가 (일반모드권한관리 시트 K열 → B열)

### 3. 필터링 로직

#### 3.1 정책모드 필터링 (변경)
- [ ] 정책영업그룹 데이터 파싱 로직 변경 (`userIds` → `managerIds`)
- [ ] 현재 사용자 아이디로 필터링
- [ ] 기존 권한 레벨 기반 필터링 제거

#### 3.2 일반정책모드 필터링 (신규)
- [ ] 현재 사용자 아이디 확인
- [ ] 일반모드권한관리 시트에서 업체명 찾기 (K열 → B열)
- [ ] 정책영업그룹의 `companyNames`로 필터링
- [ ] API 엔드포인트에 모드 구분 파라미터 추가 (또는 별도 엔드포인트)

---

## 🔎 최종 점검

### 1. 핵심 로직 검증

#### 1.1 정책영업그룹의 역할
✅ **정책모드:** 담당자들이 자신이 담당하는 정책표만 확인
- 정책표 생성 시 그룹 선택 → 그룹의 `managerIds`에 담당자 아이디 저장
- 정책표 목록에서 그룹의 `managerIds`에 현재 사용자 아이디가 포함되어 있으면 표시

✅ **일반정책모드:** 업체들이 자신의 업체와 관련된 정책표만 확인
- 정책표 생성 시 그룹 선택 → 그룹의 `companyNames`에 업체명 저장
- 정책표 목록에서 그룹의 `companyNames`에 현재 사용자의 업체명이 포함되어 있으면 표시

#### 1.2 필터링 흐름 검증

**정책모드:**
1. 정책표의 접근권한(그룹ID) 확인 ✅
2. 정책영업그룹에서 그룹 찾기 ✅
3. 그룹의 `managerIds`에 현재 사용자 아이디 포함 여부 확인 ✅
4. 포함되어 있으면 표시 ✅

**일반정책모드:**
1. 현재 사용자 아이디 확인 ✅
2. 일반모드권한관리 시트에서 업체명 찾기 (A열 또는 K열로 사용자 찾기 → B열 업체명) ✅
3. 정책표의 접근권한(그룹ID) 확인 ✅
4. 정책영업그룹에서 그룹 찾기 ✅
5. 그룹의 `companyNames`에 사용자 업체명 포함 여부 확인 ✅
6. 포함되어 있으면 표시 ✅

### 2. 데이터 일관성 검증

#### 2.1 정책영업그룹 데이터
- ✅ `companyNames`: 일반모드권한관리 시트의 B열 업체명
- ✅ `managerIds`: 일반모드권한관리 시트의 K열 담당자 아이디
- ✅ 업체명 선택 시 해당 업체의 K열 담당자 아이디 자동 추가

#### 2.2 정책표 데이터
- ✅ 접근권한 필드에 그룹ID만 저장
- ✅ 업체명이나 담당자 정보는 직접 저장하지 않음
- ✅ 그룹ID를 통해 정책영업그룹을 찾아서 필터링

### 3. 잠재적 문제점 및 해결방안

#### 3.1 문제점 1: 기존 데이터 호환성
**문제:** 기존 그룹의 `userIds` 형식과 새로운 형식 혼재
**해결:** 
- 기존 그룹을 수정할 때 새로운 형식으로 자동 변환
- 파싱 시 `userIds` 형식이면 빈 배열로 초기화

#### 3.2 문제점 2: 일반모드권한관리 시트 범위
**문제:** 현재 코드는 A~H열만 읽음
**해결:**
- 로그인 API에서 A~K열로 범위 확장
- `/api/check-general-policy-permission`에서도 A~K열로 읽기

#### 3.3 문제점 3: 업체명 중복
**문제:** 같은 업체명이 여러 행에 있을 수 있음
**해결:**
- 업체명 선택 시 중복 제거
- 정책영업그룹 저장 시 중복 제거

#### 3.4 문제점 4: 담당자 아이디 중복
**문제:** 한 담당자가 여러 업체를 담당할 수 있음
**해결:**
- 업체명 선택 시 해당 업체의 K열 담당자 아이디만 추가
- `managerIds`에 중복 제거 로직 추가

### 4. 구현 순서 권장사항

1. **1단계: 정책영업그룹 데이터 구조 변경**
   - 백엔드 API 수정 (GET, POST, PUT)
   - 프론트엔드 모달 수정
   - 기존 데이터 변환 로직

2. **2단계: 정책모드 필터링 변경**
   - 정책영업그룹 파싱 로직 변경
   - `managerIds` 기반 필터링 구현
   - 테스트

3. **3단계: 일반정책모드 추가**
   - 모드 설정 추가
   - 권한 및 비밀번호 확인
   - 컴포넌트 생성

4. **4단계: 일반정책모드 필터링**
   - 사용자 업체명 확인 로직
   - `companyNames` 기반 필터링 구현
   - 테스트

---

## 📌 최종 확인 사항

### ✅ 핵심 이해 확인
- [x] 정책영업그룹의 목적: 정책표 생성 시 그룹 선택, 목록에서 필터링
- [x] 정책모드: 담당자(`managerIds`) 기반 필터링
- [x] 일반정책모드: 업체명(`companyNames`) 기반 필터링
- [x] 정책표에는 그룹ID만 저장, 업체명/담당자는 그룹에서 찾기

### ✅ 데이터 구조 확인
- [x] 정책영업그룹: `{"companyNames": [...], "managerIds": [...]}`
- [x] 정책표: 접근권한 필드에 그룹ID만 저장
- [x] 일반모드권한관리: I열 권한, J열 비밀번호, K열 담당자 아이디

### ✅ 필터링 로직 확인
- [x] 정책모드: 그룹의 `managerIds`에 사용자 아이디 포함 여부
- [x] 일반정책모드: 그룹의 `companyNames`에 사용자 업체명 포함 여부
- [x] 업체명 확인: 일반모드권한관리 시트에서 A열 또는 K열로 사용자 찾기 → B열 업체명

### ✅ 구현 준비 확인
- [x] 모든 요구사항 문서화 완료
- [x] 기존 코드 구조 확인 완료
- [x] 필터링 로직 이해 완료
- [x] 잠재적 문제점 파악 완료

---

**마지막 업데이트:** 2025-12-30
**상태:** ✅ 최종 점검 완료 - 구현 준비 완료

**다음 단계:** 구현 시작

