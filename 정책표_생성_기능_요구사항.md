# 정책표 생성 기능 요구사항

## 📋 개요
정책모드에 정책표 생성 기능을 추가합니다.

---

## 📝 요구사항

### 작성 규칙
- 사용자가 말하는 내용을 이 문서에 계속 추가/업데이트합니다
- 최종 정리 완료 후 "구현 시작해줘"라고 말하면 계획서를 바탕으로 구현을 시작합니다

---

## 🎯 기능 개요

### 탭 구조
정책모드 접속 시 상단에 다음 4개의 탭이 표시됩니다:
1. **추가정책** (첫 번째 탭, 기본 선택)
   - 현재 정책모드에 구현되어 있는 모든 기능이 이 탭에 포함됩니다
   - 담당자 선택, 정책 타입 선택 (무선/유선), 대상년월 선택
   - 정책 카테고리 목록 (구두정책, 연합정책, 요금제유형별정책, 부가추가지원정책, 부가차감지원정책, 그레이드정책, 개별소급정책)
   - 정책 목록 보기, 정책 추가/수정/승인/취소 기능
   - 공지사항 기능
2. **정책표목록** (두 번째 탭)
   - 접근 권한: `'A'`, `'B'`, `'C'`, `'D'`, `'E'`, `'F'` (일반 사용자), `'AA'`, `'BB'`, `'CC'`, `'DD'`, `'EE'`, `'FF'` (소속정책팀), `'S'` (정산팀), `'SS'` (총괄) 모두 접근 가능
   - 권한 확인 방법: `loggedInStore.userRole` 값을 확인
   - 권한 체크 로직:
     ```javascript
     const canAccessPolicyTableList = ['A', 'B', 'C', 'D', 'E', 'F', 'AA', 'BB', 'CC', 'DD', 'EE', 'FF', 'S', 'SS'].includes(loggedInStore?.userRole);
     ```
   - **기능**:
     - **정책표이름별 탭 구조**: 정책표이름별로 탭이 나뉘어 표시됨
       - 정책표생성설정에 등록된 각 정책표이름이 탭으로 표시됨
       - 각 탭을 클릭하면 해당 정책표의 목록만 표시됨
       - 정책표생성 탭에서도 정책표이름별로 생성 버튼이 나뉘어 있으므로, 목록에서도 동일하게 구분
     - **탭별 테이블**: 각 탭마다 해당 정책표의 데이터만 테이블로 표시
       - 테이블 컬럼: 정책적용일시, 생성자, 생성일시, 등록일시
       - 정책표이름은 탭으로 표시되므로 테이블 컬럼에서 제외
       - 정책적용일시별로 데이터가 계속 쌓임 (최신순 또는 적용일시순 정렬)
     - **권한별 필터링**: 사용자 권한에 따라 확인 가능한 정책표 탭만 표시
       - **자동 권한 부여**: 총괄(`'SS'`), 정산팀(`'S'`), 생성팀장(`'AA'`-`'FF'`)은 모든 정책표 확인 가능
       - **일반 사용자(`'A'`-`'F'`)**: 정책표생성 시 선택된 접근권한(일반사용자 그룹)에 포함된 경우만 확인 가능
         - 정책표생성 탭에서 선택한 일반사용자 그룹에 포함된 일반사용자만 해당 정책표 확인 가능
         - 예: "서울지역" 그룹에 A, B 사용자가 포함되어 있고, 정책표생성 시 "서울지역" 그룹을 선택했다면 A, B 사용자만 해당 정책표 확인 가능
       - **소속정책팀(`'AA'`, `'BB'` 등)**: 본인이 생성한 정책표 탭 및 하위 사용자들이 확인 가능한 정책표 탭 표시
       - **정산팀(`'S'`)**: 모든 정책표 탭 표시
       - **총괄(`'SS'`)**: 모든 정책표 탭 표시
     - **테이블 행 선택**: 테이블 행을 클릭하면 등록된 정책표를 확인할 수 있음
3. **정책표생성** (세 번째 탭)
   - 접근 권한: `'S'` (정산팀), `'AA'`, `'BB'`, `'CC'`, `'DD'`, `'EE'`, `'FF'` (소속정책팀)
   - 권한 확인 방법: `loggedInStore.userRole` 값을 확인
   - 권한이 없는 경우: 탭이 표시되지 않거나 접근 시 차단
   - 권한 체크 로직:
     ```javascript
     const canAccessPolicyTableCreation = ['S', 'AA', 'BB', 'CC', 'DD', 'EE', 'FF'].includes(loggedInStore?.userRole);
     ```
   - **기능**:
     - 정책표생성설정에서 설정된 권한 내용을 토대로 해당 권한자의 정책표별로 생성 버튼이 존재
     - **생성 버튼 클릭 시**:
       - 모달이 나타남
       - 모달 필드:
         - **정책적용일시** (입력필드): 정책이 적용되는 날짜/시간 입력
         - **정책적용내용** (입력필드): 정책 적용 내용 입력
         - **접근권한** (선택 필드): 일반사용자 그룹 선택
           - 일반사용자 그룹 드롭다운 또는 검색 가능한 선택 필드
           - 정책표생성설정에서 미리 생성한 일반사용자 그룹 목록 표시
           - 그룹 선택 시 해당 그룹에 포함된 일반사용자들이 자동으로 로드됨
           - 총괄(SS), 정산팀(S), 생성팀장(AA-FF)은 자동으로 권한 부여됨 (별도 선택 불필요)
       - 입력 완료 후 하단에 **정책표생성** 버튼 표시
       - 정책표생성 버튼 클릭 시 실제 생성 프로세스 시작
       - 생성중 화면이 나타나고 진행 상황을 보여줌
       - 정책표가 생성됨 (정책적용일시, 정책적용내용, 접근권한과 함께 저장)
     - **재생성 기능**:
       - 정책표가 마음에 들지 않으면 다시 생성 버튼을 누를 수 있음
       - 이전에 생성된 정책표는 초기화되고 마지막 생성된 정책표가 나타남
       - 재생성 시에도 정책적용일시, 정책적용내용, 접근권한을 다시 입력받음
     - **정책표 등록**:
       - 마음에 드는 정책표가 생성되면 "정책표등록" 버튼을 누름
       - 정책표등록 버튼을 누르면 정책표목록 페이지의 목록 테이블에 등록됨
       - 정책적용일시, 정책적용내용, 접근권한도 함께 등록됨
4. **정책표생성설정** (네 번째 탭)
   - 접근 권한: `'SS'` (총괄)만 접근 가능
   - 권한 확인 방법: `loggedInStore.userRole` 값을 확인
   - 권한이 없는 경우: 탭이 표시되지 않거나 접근 시 차단
   - 권한 체크 로직:
     ```javascript
     const canAccessPolicyTableSettings = loggedInStore?.userRole === 'SS';
     ```

### 권한 체크 구현 방법
- 권한 값은 `loggedInStore.userRole`에서 확인 (대리점아이디관리 시트의 R열(17번 인덱스) 값)
- 탭 렌더링 시 권한 체크하여 조건부로 탭 표시/숨김
- 탭 클릭 시에도 권한 재확인하여 무단 접근 방지
- 권한이 없는 사용자가 직접 URL로 접근 시도할 경우 차단 메시지 표시

---

## 📌 세부 요구사항

### 1. 기능 범위

#### 정책표생성설정 탭
- **정책표 추가 버튼**: 정책표를 추가할 수 있는 버튼 제공
- **정책표 추가 모달**: 버튼 클릭 시 모달 표시
  - **정책표이름** (입력필드): 정책표의 이름을 입력
  - **정책표링크** (입력필드): 정책표 구글시트 링크를 입력
  - **디스코드채널ID** (입력필드): 디스코드 채널 ID를 입력
  - **생성자적용권한** (검색 및 복수선택 가능)
    - 권한에 해당하는 이름이 나열됨
    - 연합정책추가 모달의 "연합대상하부점 * 선택"과 유사한 UI
    - 검색 기능 제공
    - 복수 선택 가능
- **일반사용자 그룹 관리 기능**:
  - **그룹 추가 버튼**: 일반사용자 그룹을 추가할 수 있는 버튼 제공
  - **그룹 추가 모달**: 버튼 클릭 시 모달 표시
    - **그룹이름** (입력필드): 그룹의 이름을 입력 (예: "서울지역", "부산지역" 등)
    - **일반사용자 선택** (검색 및 복수선택 가능)
      - 일반사용자(`'A'`, `'B'`, `'C'`, `'D'`, `'E'`, `'F'`) 목록 표시
      - 연합정책추가 모달의 "연합대상하부점 * 선택"과 유사한 UI
      - 검색 기능 제공
      - 복수 선택 가능
    - 저장 시 구글시트에 그룹 정보 저장
  - **그룹 목록 표시**: 생성된 그룹 목록을 테이블로 표시
    - 그룹이름, 포함된 일반사용자 수, 등록일시 등 표시
    - 그룹 수정/삭제 기능 제공
- **데이터 저장**: 구글시트에 정보 저장 (시트 이름은 추후 제공 예정)

#### 정책표생성 탭 - 생성 프로세스
- **생성 버튼 클릭 시 모달 표시**:
  - 정책표생성 버튼 클릭 시 모달이 나타남
  - 모달 필드:
    - **정책적용일시** (입력필드): 정책이 적용되는 날짜/시간 입력
    - **정책적용내용** (입력필드): 정책 적용 내용 입력
  - 입력 완료 후 하단에 **정책표생성** 버튼 표시
  - 정책표생성 버튼 클릭 시 실제 정책표 생성 프로세스 시작
- **구글 시트 캡쳐 방식**: 구글 시트를 캡쳐하여 이미지로 생성
- **참고 코드**: 제공된 Discord 봇 코드의 핵심 로직 참고

##### 구글 시트 캡쳐 핵심 로직 (정확한 위치 및 순서)
1. **구글 시트 URL 접근**
   ```javascript
   await driver.get(sheet.url); // 정책표생성설정에서 등록한 정책표링크
   ```

2. **iframe 찾기 및 전환** (핵심: 정확한 iframe 선택자)
   ```javascript
   // iframe을 찾아 그 안으로 포커스 전환
   const iframe = await driver.wait(
       until.elementLocated(By.css('#pageswitcher-content')),
       30000
   );
   await driver.switchTo().frame(iframe);
   ```
   - **중요**: `#pageswitcher-content` 선택자를 사용하여 iframe 찾기
   - iframe 내부로 전환하지 않으면 테이블 요소를 찾을 수 없음

3. **테이블 요소 찾기 및 대기**
   ```javascript
   // iframe 안에서 테이블 요소 탐색
   const table = await driver.wait(
       until.elementLocated(By.css('table')),
       30000
   );
   await driver.wait(
       until.elementIsVisible(table),
       30000
   );
   ```
   - iframe 내부에서 `table` 요소를 찾아야 함
   - 테이블이 완전히 로드되고 보일 때까지 대기

4. **테이블 위치 계산 및 스크린샷**
   ```javascript
   await driver.executeScript("arguments[0].scrollIntoView(true);", table);
   const rect = await table.getRect();
   const screenshot = await driver.takeScreenshot();
   ```
   - 테이블을 화면에 보이도록 스크롤
   - 테이블의 위치와 크기 정보 가져오기 (`getRect()`)
   - 전체 화면 스크린샷 촬영

5. **이미지 크롭** (정확한 영역만 추출)
   ```javascript
   const image = await Jimp.read(Buffer.from(screenshot, 'base64'));
   const x = Math.max(0, Math.floor(rect.x * 0.95));
   const y = Math.max(0, Math.floor(rect.y * 0.95));
   const width = Math.min(image.bitmap.width - x, Math.floor(rect.width * 1.01));
   const height = Math.min(image.bitmap.height - y, Math.floor(rect.height * 1.01));
   const cropped = image.crop(x, y, width, height);
   ```
   - **핵심**: `rect.x`, `rect.y`, `rect.width`, `rect.height`를 사용하여 정확한 테이블 영역만 크롭
   - 약간의 여유를 두기 위해 `0.95`와 `1.01` 배율 사용
   - 이미지 경계를 벗어나지 않도록 `Math.min`, `Math.max` 사용

6. **메인 페이지로 복귀**
   ```javascript
   await driver.switchTo().defaultContent();
   ```

##### Chrome 옵션 설정 (참고)
- Headless 모드: `--headless`
- 창 크기: `--window-size=2560,10000` (넓은 화면으로 캡쳐)
- 스크롤바 숨김: `--hide-scrollbars`
- 기타 성능 최적화 옵션들

##### 디스코드 연동
- 정책표생성설정에서 등록한 디스코드채널ID에 생성자 이름별로 스레드 채널 생성
- 생성된 이미지를 디스코드 스레드에 업로드하여 저장
- 이미지 URL을 불러와서 표시

##### 이미지 URL 만료 처리
- 직영점관리모드의 디스코드모니터링 탭과 동일한 방식으로 처리
- Discord 이미지 URL은 만료되므로 메시지ID를 통해 갱신 가능하도록 구현

#### 정책표목록 탭 - 이미지 확인 및 복사 기능
- **정책 상세 화면**:
  - 테이블 행을 클릭하여 정책 내용 상세 화면 진입
  - **상단 영역**: 정책적용일시와 정책적용내용 표시 (정책표생성 탭에서 입력한 내용)
  - **하단 영역**: 등록된 정책표 이미지 표시
  - 이미지 확인 및 복사 기능 제공

- **정책 다시 확인하기 버튼**:
  - 이미지가 보이지 않는 경우 (만료된 URL) "정책다시확인하기" 버튼 표시
  - 버튼 클릭 시 메시지ID를 통해 이미지를 개별적으로 갱신
  - 갱신된 이미지를 즉각적으로 표시

- **이미지 복사하기 버튼**:
  - 이미지 옆에 "이미지복사하기" 버튼 제공
  - 버튼 클릭 시 이미지를 원본으로 클립보드에 복사
  - 복사된 이미지는 카카오톡 등에 붙여넣기로 사용 가능
  - 복사 성공 시 사용자에게 알림 표시

### 2. UI/UX 요구사항
(사용자 요구사항 입력 대기 중...)

### 3. 데이터 구조

#### 정책표생성설정 데이터
- **정책표이름**: 문자열
- **정책표링크**: 구글 시트 URL (문자열)
- **디스코드채널ID**: 디스코드 채널 ID (문자열)
- **생성자적용권한**: 권한 목록 (배열)

#### 정책표 생성 결과 데이터
- **정책표ID**: 고유 식별자
- **생성자**: 생성자 이름 (권한 레벨)
- **생성일시**: 생성된 날짜/시간
- **디스코드메시지ID**: 디스코드에 업로드된 이미지의 메시지 ID
- **디스코드스레드ID**: 생성된 디스코드 스레드 ID
- **이미지URL**: Discord 이미지 URL (만료 가능)
- **등록여부**: 정책표목록에 등록되었는지 여부 (boolean)

#### 정책표목록 데이터
- **정책표ID**: 고유 식별자
- **정책표이름**: 정책표 이름
- **정책적용일시**: 정책이 적용되는 날짜/시간 (정책표생성 탭에서 입력)
- **정책적용내용**: 정책 적용 내용 (정책표생성 탭에서 입력)
- **접근권한**: 정책표 확인 가능한 일반사용자 그룹 (정책표생성 탭에서 선택)
  - 일반사용자 그룹 ID 또는 그룹이름 저장
  - 총괄(SS), 정산팀(S), 생성팀장(AA-FF)은 자동으로 권한 부여 (별도 저장 불필요)
- **생성자**: 생성자 이름
- **생성일시**: 생성된 날짜/시간
- **등록일시**: 정책표목록에 등록된 날짜/시간

### 4. API 요구사항

#### 정책표생성설정 관련 API

##### GET /api/policy-table-settings
- **설명**: 정책표 설정 목록 조회
- **권한**: SS (총괄)만 접근 가능
- **응답 형식**:
  ```json
  [
    {
      "id": "PT_1234567890",
      "policyTableName": "기본정책변동",
      "policyTableLink": "https://docs.google.com/spreadsheets/d/...",
      "discordChannelId": "1234567890123456789",
      "creatorPermissions": ["AA", "BB", "CC"],
      "registeredAt": "2024-01-01T00:00:00.000Z",
      "registeredBy": "홍기현"
    }
  ]
  ```
- **에러 응답**:
  - 403: 권한 없음
  - 500: 서버 오류

##### POST /api/policy-table-settings
- **설명**: 정책표 설정 추가
- **권한**: SS (총괄)만 접근 가능
- **요청 본문**:
  ```json
  {
    "policyTableName": "기본정책변동",
    "policyTableLink": "https://docs.google.com/spreadsheets/d/...",
    "discordChannelId": "1234567890123456789",
    "creatorPermissions": ["AA", "BB", "CC"]
  }
  ```
- **응답 형식**:
  ```json
  {
    "success": true,
    "id": "PT_1234567890",
    "message": "정책표 설정이 추가되었습니다."
  }
  ```
- **에러 응답**:
  - 400: 입력 데이터 오류
  - 403: 권한 없음
  - 500: 서버 오류

##### PUT /api/policy-table-settings/:id
- **설명**: 정책표 설정 수정
- **권한**: SS (총괄)만 접근 가능
- **요청 본문**: POST와 동일 (모든 필드 선택사항)
- **응답 형식**: POST와 동일
- **에러 응답**:
  - 404: 정책표 설정을 찾을 수 없음
  - 400: 입력 데이터 오류
  - 403: 권한 없음

##### DELETE /api/policy-table-settings/:id
- **설명**: 정책표 설정 삭제
- **권한**: SS (총괄)만 접근 가능
- **응답 형식**:
  ```json
  {
    "success": true,
    "message": "정책표 설정이 삭제되었습니다."
  }
  ```
- **에러 응답**:
  - 404: 정책표 설정을 찾을 수 없음
  - 403: 권한 없음
  - 500: 서버 오류

#### 정책표 생성 관련 API

##### POST /api/policy-table/generate
- **설명**: 정책표 생성 요청
- **권한**: S (정산팀), AA-FF (소속정책팀)
- **요청 본문**:
  ```json
  {
    "policyTableId": "PT_1234567890",
    "applyDate": "2024-01-15T00:00:00.000Z",
    "applyContent": "2024년 1월 기본정책 변동사항",
    "accessGroupId": "UG_9876543210"
  }
  ```
- **응답 형식** (즉시 반환):
  ```json
  {
    "success": true,
    "jobId": "JOB_1234567890_abc123",
    "status": "queued",
    "message": "정책표 생성이 시작되었습니다."
  }
  ```
- **에러 응답**:
  - 400: 입력 데이터 오류
  - 403: 권한 없음
  - 500: 서버 오류

##### GET /api/policy-table/generate/:jobId/status
- **설명**: 정책표 생성 상태 조회
- **권한**: 요청한 사용자 본인만 (작업 ID로 확인)
- **응답 형식**:
  ```json
  {
    "jobId": "JOB_1234567890_abc123",
    "status": "processing",
    "progress": 50,
    "message": "이미지 캡쳐 중...",
    "result": null
  }
  ```
- **상태 값**:
  - `queued`: 대기 중
  - `processing`: 진행 중
  - `completed`: 완료
  - `failed`: 실패
- **완료 시 응답**:
  ```json
  {
    "jobId": "JOB_1234567890_abc123",
    "status": "completed",
    "progress": 100,
    "message": "정책표 생성이 완료되었습니다.",
    "result": {
      "policyTableId": "PT_1234567890",
      "imageUrl": "https://cdn.discordapp.com/...",
      "messageId": "1234567890123456789",
      "threadId": "9876543210987654321"
    }
  }
  ```
- **실패 시 응답**:
  ```json
  {
    "jobId": "JOB_1234567890_abc123",
    "status": "failed",
    "progress": 0,
    "message": "구글 시트 접근에 실패했습니다.",
    "error": "시트 권한이 없습니다."
  }
  ```

#### 일반사용자 그룹 관련 API

##### GET /api/policy-table/user-groups
- **설명**: 일반사용자 그룹 목록 조회
- **권한**: SS (총괄)만 접근 가능
- **응답 형식**:
  ```json
  [
    {
      "id": "UG_1234567890",
      "groupName": "서울지역",
      "userIds": ["A", "B", "C"],
      "registeredAt": "2024-01-01T00:00:00.000Z",
      "registeredBy": "홍기현"
    }
  ]
  ```

##### POST /api/policy-table/user-groups
- **설명**: 일반사용자 그룹 추가
- **권한**: SS (총괄)만 접근 가능
- **요청 본문**:
  ```json
  {
    "groupName": "서울지역",
    "userIds": ["A", "B", "C"]
  }
  ```
- **응답 형식**:
  ```json
  {
    "success": true,
    "id": "UG_1234567890",
    "message": "일반사용자 그룹이 추가되었습니다."
  }
  ```

##### PUT /api/policy-table/user-groups/:id
- **설명**: 일반사용자 그룹 수정
- **권한**: SS (총괄)만 접근 가능
- **요청 본문**: POST와 동일

##### DELETE /api/policy-table/user-groups/:id
- **설명**: 일반사용자 그룹 삭제
- **권한**: SS (총괄)만 접근 가능

#### 정책표목록 관련 API
- **GET /api/policy-tables**: 정책표 목록 조회 (권한별 필터링, 검색/필터링 지원)
  - 쿼리 파라미터: `search`, `applyDateFrom`, `applyDateTo`, `creator`, `createDateFrom`, `createDateTo`
- **POST /api/policy-tables/:id/register**: 정책표 등록
- **GET /api/policy-tables/:id**: 정책표 상세 조회 (정책적용일시, 정책적용내용 포함)
- **POST /api/policy-tables/:id/refresh-image**: 정책표 이미지 갱신 (메시지ID를 통해)
- **DELETE /api/policy-tables/:id**: 정책표 삭제 (권한 체크: SS, AA-FF만 가능)

### 5. 비즈니스 로직

#### 정책표 생성 프로세스
1. 정책표생성 탭에서 정책표별 생성 버튼 클릭
2. **모달 표시**: 정책적용일시, 정책적용내용, 접근권한(일반사용자 그룹) 입력
3. 정책표생성 버튼 클릭 (모달 내)
4. 백엔드에서 구글 시트 접근 (Puppeteer 사용)
5. iframe 내부의 테이블 요소 찾기
6. 테이블 영역 스크린샷 캡쳐 및 이미지 크롭
7. 디스코드 채널에 스레드 생성 (생성자 이름별)
8. 생성된 이미지를 디스코드 스레드에 업로드
9. 메시지ID와 스레드ID 저장
10. 정책적용일시, 정책적용내용, 접근권한(일반사용자 그룹)과 함께 구글시트에 저장
11. 이미지 URL 반환하여 프론트엔드에 표시
12. 생성 진행 상황을 실시간으로 전달

#### 정책표 등록 프로세스
1. 생성된 정책표 확인 후 "정책표등록" 버튼 클릭
2. 정책표ID와 함께 등록 요청 (정책적용일시, 정책적용내용, 접근권한 포함)
3. 정책표목록 테이블에 등록
4. 등록일시 기록

#### 정책표목록 권한 필터링 프로세스
1. 사용자 로그인 정보 확인 (`loggedInStore.userRole`)
2. **자동 권한 부여 확인**:
   - 총괄(`'SS'`), 정산팀(`'S'`), 생성팀장(`'AA'`-`'FF'`): 모든 정책표 확인 가능
3. **일반 사용자(`'A'`-`'F'`) 권한 확인**:
   - 정책표의 접근권한 필드 확인
   - 접근권한에 저장된 일반사용자 그룹 정보 조회
   - 현재 사용자가 해당 그룹에 포함되어 있는지 확인
   - 포함되어 있으면 해당 정책표 확인 가능, 아니면 확인 불가
4. 권한이 있는 정책표만 탭 및 목록에 표시

#### 이미지 갱신 프로세스
1. 정책표목록에서 정책표 선택하여 상세 화면 진입
2. 이미지 로드 실패 시 (만료된 URL) "정책다시확인하기" 버튼 표시
3. 버튼 클릭 시 메시지ID를 통해 디스코드 API로 이미지 URL 갱신
4. 갱신된 이미지 URL로 즉각적으로 이미지 표시
5. 직영점관리모드의 디스코드모니터링 탭과 동일한 로직 사용

---

---

## ❓ 구현 전 확인 필요 사항

### 1. 데이터 저장 관련

#### ✅ 시트 이름 및 컬럼 헤더 정의

**Q1, Q2, Q3 답변:**

##### 1. 정책표생성설정 시트
- **시트 이름**: `정책모드_정책표설정`
- **컬럼 헤더**:
  ```
  ['정책표ID', '정책표이름', '정책표링크', '디스코드채널ID', '생성자적용권한', '등록일시', '등록자']
  ```
  - **정책표ID**: 고유 식별자 (자동 생성)
  - **정책표이름**: 정책표의 이름
  - **정책표링크**: 구글 시트 URL
  - **디스코드채널ID**: 디스코드 채널 ID
  - **생성자적용권한**: JSON 형태로 저장 (예: `["AA", "BB", "CC"]`)
  - **등록일시**: 등록된 날짜/시간
  - **등록자**: 등록한 사용자 이름

##### 2. 정책표 목록 시트 (생성 결과 포함)
- **시트 이름**: `정책모드_정책표목록`
- **컬럼 헤더**:
  ```
  ['정책표ID', '정책표이름', '정책적용일시', '정책적용내용', '접근권한', '생성자', '생성일시', '디스코드메시지ID', '디스코드스레드ID', '이미지URL', '등록여부', '등록일시']
  ```
  - **정책표ID**: 정책표생성설정의 정책표ID와 연결
  - **정책표이름**: 정책표 이름 (정책표생성설정에서 가져옴)
  - **정책적용일시**: 정책이 적용되는 날짜/시간 (정책표생성 탭에서 입력)
  - **정책적용내용**: 정책 적용 내용 (정책표생성 탭에서 입력)
  - **접근권한**: 일반사용자 그룹 ID 또는 그룹이름 (정책표생성 탭에서 선택)
    - JSON 형태로 저장 가능 (예: `"서울지역"` 또는 `["A", "B", "C"]`)
    - 총괄(SS), 정산팀(S), 생성팀장(AA-FF)은 자동 권한 부여 (별도 저장 불필요)

##### 3. 일반사용자 그룹 시트
- **시트 이름**: `정책모드_일반사용자그룹`
- **컬럼 헤더**:
  ```
  ['그룹ID', '그룹이름', '일반사용자목록', '등록일시', '등록자']
  ```
  - **그룹ID**: 고유 식별자 (자동 생성)
  - **그룹이름**: 그룹의 이름 (예: "서울지역", "부산지역")
  - **일반사용자목록**: JSON 형태로 저장 (예: `["A", "B", "C"]`)
  - **등록일시**: 등록된 날짜/시간
  - **등록자**: 등록한 사용자 이름
  - **생성자**: 생성자 이름 (권한 레벨, 예: "AA" 또는 "홍기현")
  - **생성일시**: 정책표가 생성된 날짜/시간
  - **디스코드메시지ID**: 디스코드에 업로드된 이미지의 메시지 ID
  - **디스코드스레드ID**: 생성된 디스코드 스레드 ID
  - **이미지URL**: Discord 이미지 URL (만료 가능)
  - **등록여부**: "Y" 또는 "N" (정책표목록에 등록되었는지 여부)
  - **등록일시**: 정책표목록에 등록된 날짜/시간 (등록여부가 "Y"일 때만 값 있음)

### 2. 디스코드 연동 관련

#### ✅ 디스코드 연동 설정 (Q4, Q5, Q6 답변)

**Q4 답변**: 디스코드 봇 토큰 관리
- **저장 위치**: 환경변수 `DISCORD_BOT_TOKEN` 사용
- **기존 코드 참고**: `server/meetingRoutes.js`, `server/index.js`, `server/monitor.js`에서 동일하게 사용
- **초기화 방법**:
  ```javascript
  const DISCORD_BOT_TOKEN = process.env.DISCORD_BOT_TOKEN;
  const discordBot = new Client({
    intents: [
      GatewayIntentBits.Guilds,
      GatewayIntentBits.GuildMessages,
      GatewayIntentBits.MessageContent
    ]
  });
  await discordBot.login(DISCORD_BOT_TOKEN);
  ```

**Q5 답변**: 디스코드 스레드 이름 규칙
- **형식**: `"{생성자이름}-{정책표이름}"`
- **예시**: 
  - "홍기현-기본정책변동"
  - "AA-공시지원금"
  - "홍기현-VIP홈정책"
- **구현 방법**:
  ```javascript
  const threadName = `${creatorName}-${policyTableName}`;
  const thread = await channel.threads.create({
    name: threadName,
    message: { content: `${threadName} 이미지 저장` }
  });
  ```

**Q6 답변**: 디스코드 API 재시도 로직
- **기존 로직 참고**: `server/directRoutes.js`의 `withRetry` 함수 사용
- **재시도 설정**:
  - 최대 재시도 횟수: 5회
  - 기본 지연 시간: 2000ms (2초)
  - 지수 백오프(Exponential Backoff) + Jitter 적용
  - Rate limit 에러 감지 및 처리
- **구현 방법**:
  ```javascript
  async function withRetry(fn, maxRetries = 5, baseDelay = 2000) {
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      try {
        return await fn();
      } catch (error) {
        const isRateLimitError = error.code === 429 || 
          (error.response && error.response.status === 429);
        
        if (isRateLimitError && attempt < maxRetries - 1) {
          const jitter = Math.random() * 1000; // 0~1초 랜덤
          const delay = baseDelay * Math.pow(2, attempt) + jitter;
          await new Promise(resolve => setTimeout(resolve, delay));
          continue;
        }
        throw error;
      }
    }
  }
  ```

### 3. 정책표 생성 관련

#### ✅ 정책표 생성 설정 (Q7, Q8, Q9 답변)

**Q7 답변**: 동시 생성 허용
- **여러 사용자가 동시에 정책표를 생성할 수 있어야 함**
- 동시성 처리 필요 (각 요청을 독립적으로 처리)
- 생성 작업은 비동기로 처리하여 다른 사용자에게 영향 없도록 구현

**Q8 답변**: 타임아웃 설정
- **타임아웃**: 5분 (300초)
- 5분 내에 생성이 완료되지 않으면 타임아웃 처리
- 타임아웃 시 사용자에게 명확한 에러 메시지 표시

**Q9 답변**: 에러 처리 및 진행 상황 표시
- **에러 메시지**: 팝업보다는 상세한 에러 내용 표시
  - 시트 권한 문제인지 디스코드 문제인지 구분하여 표시
  - 정확한 에러 원인을 사용자가 알 수 있도록 함
- **진행 상황 시각적 표시**:
  - 생성 중일 때 로딩 상태를 명확히 표시
  - 진행 단계별 상태 표시 (예: "구글 시트 접근 중...", "이미지 캡쳐 중...", "디스코드 업로드 중...")
  - 진행률 표시 (예: 진행 바 또는 단계별 체크 표시)

#### 📡 진행 상황 전달 방식 설명 (Q10)

**Q10**: 생성 진행 상황 전달 방식 선택

다음 3가지 방식 중 선택이 필요합니다:

##### 1. WebSocket 방식
- **설명**: 서버와 클라이언트 간 실시간 양방향 통신
- **장점**: 
  - 실시간으로 즉각적인 업데이트 가능
  - 서버에서 클라이언트로 직접 푸시 가능
  - 연결 유지로 오버헤드 적음
- **단점**: 
  - 서버에 WebSocket 서버 구현 필요
  - 연결 관리 복잡도 증가
  - 방화벽/프록시 환경에서 문제 발생 가능
- **구현 복잡도**: 높음

##### 2. Server-Sent Events (SSE) 방식
- **설명**: 서버에서 클라이언트로 단방향 실시간 스트리밍
- **장점**: 
  - 실시간 업데이트 가능
  - HTTP 기반이라 구현이 상대적으로 간단
  - 자동 재연결 지원
- **단점**: 
  - 서버에서 클라이언트로만 통신 가능 (단방향)
  - 일부 프록시에서 스트리밍 차단 가능
- **구현 복잡도**: 중간

##### 3. 폴링(Polling) 방식
- **설명**: 클라이언트가 주기적으로 서버에 상태를 요청
- **장점**: 
  - 구현이 가장 간단
  - 모든 환경에서 동작 보장
  - 기존 HTTP 인프라 그대로 사용
- **단점**: 
  - 실시간성이 떨어짐 (요청 간격에 따라 지연 발생)
  - 서버 부하 증가 (주기적 요청)
  - 불필요한 네트워크 트래픽 발생
- **구현 복잡도**: 낮음
- **권장 간격**: 1-2초마다 상태 확인

**권장 사항**: 
- 빠른 구현이 필요하면 **폴링 방식** (1-2초 간격)
- 더 나은 사용자 경험이 필요하면 **Server-Sent Events (SSE) 방식**

#### 🔄 대안: 하이브리드 방식 (권장)

기존 방식들의 단점을 보완한 하이브리드 접근법:

##### 하이브리드 폴링 (스마트 폴링)
- **기본 원리**: 
  - 작업 상태가 변경되지 않으면 긴 간격으로 폴링 (5-10초)
  - 작업이 진행 중이면 짧은 간격으로 폴링 (1-2초)
  - 작업이 완료되면 폴링 중단
- **장점**:
  - 서버 부하 최소화 (상태 변화 없을 때는 긴 간격)
  - 실시간성 확보 (진행 중일 때는 짧은 간격)
  - 모든 환경에서 동작 보장
  - 구현이 간단함
- **구현 방법**:
  ```javascript
  let pollInterval = 10000; // 기본 10초
  const pollStatus = async () => {
    const status = await fetchStatus();
    if (status.state === 'processing') {
      pollInterval = 2000; // 진행 중이면 2초
    } else if (status.state === 'completed' || status.state === 'failed') {
      clearInterval(intervalId); // 완료되면 중단
    } else {
      pollInterval = 10000; // 대기 중이면 10초
    }
  };
  ```

##### Long Polling 방식
- **기본 원리**: 
  - 클라이언트가 서버에 요청을 보내면, 서버는 상태가 변경될 때까지 응답을 지연
  - 상태가 변경되면 즉시 응답하고, 클라이언트는 바로 다음 요청을 보냄
- **장점**:
  - 실시간성 향상 (상태 변경 시 즉시 알림)
  - 폴링보다 서버 부하 적음 (연결 유지)
  - HTTP 기반이라 모든 환경에서 동작
- **단점**:
  - 서버에서 연결을 유지해야 함 (타임아웃 설정 필요)
  - 구현이 폴링보다 약간 복잡
- **구현 방법**:
  ```javascript
  // 서버: 상태가 변경될 때까지 대기 (최대 30초)
  app.get('/api/policy-table/generate/:id/status', async (req, res) => {
    const startTime = Date.now();
    const maxWait = 30000; // 30초
    
    const checkStatus = async () => {
      const status = await getStatus(req.params.id);
      if (status.changed || Date.now() - startTime > maxWait) {
        return res.json(status);
      }
      setTimeout(checkStatus, 1000);
    };
    checkStatus();
  });
  ```

##### 백그라운드 작업 + 상태 저장 방식 (최종 권장)
- **기본 원리**:
  1. 클라이언트가 생성 요청을 보내면 서버는 즉시 작업 ID 반환
  2. 서버는 백그라운드에서 작업을 실행하고 진행 상태를 메모리/DB에 저장
  3. 클라이언트는 작업 ID로 상태를 주기적으로 확인 (하이브리드 폴링 또는 Long Polling)
- **장점**:
  - 서버 타임아웃 문제 해결 (요청이 즉시 완료되므로)
  - 여러 작업을 동시에 처리 가능
  - 작업 실패 시에도 상태 확인 가능
  - 서버 재시작 시에도 작업 상태 복구 가능 (DB 저장 시)
- **구현 방법**:
  ```javascript
  // 1. 생성 요청 (즉시 응답)
  POST /api/policy-table/generate
  → { jobId: "job-123", status: "queued" }
  
  // 2. 상태 확인 (하이브리드 폴링 또는 Long Polling)
  GET /api/policy-table/generate/:jobId/status
  → { status: "processing", progress: 50, message: "이미지 캡쳐 중..." }
  
  // 3. 백그라운드 작업 실행
  async function processPolicyTableGeneration(jobId) {
    updateStatus(jobId, { status: "processing", progress: 0 });
    // 구글 시트 접근
    updateStatus(jobId, { progress: 25, message: "구글 시트 접근 중..." });
    // 이미지 캡쳐
    updateStatus(jobId, { progress: 50, message: "이미지 캡쳐 중..." });
    // 디스코드 업로드
    updateStatus(jobId, { progress: 75, message: "디스코드 업로드 중..." });
    // 완료
    updateStatus(jobId, { status: "completed", progress: 100, result: {...} });
  }
  ```

**최종 권장**: **백그라운드 작업 + 하이브리드 폴링 방식**
- 서버 부하 최소화
- 실시간성 확보
- 모든 환경에서 동작 보장
- 구현 복잡도 적절

#### 🔧 브라우저 자동화 도구 확인 (Q11)

**Q11 확인 결과**: 
- **현재 상태**: Selenium WebDriver는 설치되어 있지 않음
- **대신 Puppeteer가 설치되어 있음** (`server/package.json` 확인)
- **Puppeteer**: Chrome/Chromium 브라우저 자동화 도구 (Selenium과 유사한 기능)
- **기존 사용 사례**: 회의모드에서 Excel/PPT를 이미지로 변환할 때 Puppeteer 사용 중

**선택**: **Puppeteer 사용 (확정)**

##### Puppeteer 사용 결정
- **이미 설치되어 있음**: `server/package.json`에 `puppeteer` 패키지 포함
- **기존 사용 사례**: 회의모드에서 Excel/PPT를 이미지로 변환할 때 Puppeteer 사용 중
- **장점**: 
  - 추가 설치 불필요
  - 더 가볍고 빠름
  - Chrome 전용이지만 구글 시트 캡쳐에는 충분
  - 기존 코드베이스와 일관성 유지

##### Selenium → Puppeteer 변환 가이드

참고 코드의 Selenium 로직을 Puppeteer로 변환:

**1. 브라우저 실행 (Selenium → Puppeteer)**
```javascript
// Selenium
const options = new chrome.Options();
options.addArguments('--headless', '--window-size=2560,10000', '--hide-scrollbars');
const driver = await new Builder()
  .forBrowser('chrome')
  .setChromeOptions(options)
  .build();

// Puppeteer
const puppeteer = require('puppeteer');
const browser = await puppeteer.launch({
  headless: true,
  args: [
    '--no-sandbox',
    '--disable-setuid-sandbox',
    '--disable-dev-shm-usage',
    '--disable-gpu',
    '--window-size=2560,10000',
    '--hide-scrollbars'
  ]
});
```

**2. 페이지 접근 및 iframe 찾기**
```javascript
// Selenium
await driver.get(sheetUrl);
const iframe = await driver.wait(
  until.elementLocated(By.css('#pageswitcher-content')),
  30000
);
await driver.switchTo().frame(iframe);

// Puppeteer
const page = await browser.newPage();
await page.goto(sheetUrl, { waitUntil: 'networkidle0', timeout: 30000 });
// iframe 찾기 (여러 방법 시도)
let frame = null;
await page.waitForSelector('#pageswitcher-content', { timeout: 30000 });
const frameElement = await page.$('#pageswitcher-content');
if (frameElement) {
  frame = await frameElement.contentFrame();
}
// 또는 frames()로 찾기
if (!frame) {
  frame = await page.frames().find(f => 
    f.url().includes('pageswitcher') || 
    f.name() === 'pageswitcher-content'
  );
}
```

**3. 테이블 요소 찾기 및 위치 계산**
```javascript
// Selenium
const table = await driver.wait(
  until.elementLocated(By.css('table')),
  30000
);
await driver.wait(until.elementIsVisible(table), 30000);
await driver.executeScript("arguments[0].scrollIntoView(true);", table);
const rect = await table.getRect();
const screenshot = await driver.takeScreenshot();

// Puppeteer (크롭 방식 사용 - 요소 단위 스크린샷은 정확한 위치를 캡쳐하지 못할 수 있음)
await frame.waitForSelector('table', { timeout: 30000, visible: true });
const table = await frame.$('table');
await table.scrollIntoViewIfNeeded();
// 테이블의 정확한 위치와 크기 정보 가져오기
const boundingBox = await table.boundingBox();
if (!boundingBox) {
  throw new Error('테이블 위치를 찾을 수 없습니다.');
}
```

**4. 전체 페이지 스크린샷 및 이미지 크롭**
```javascript
// Selenium + Jimp
const image = await Jimp.read(Buffer.from(screenshot, 'base64'));
const x = Math.max(0, Math.floor(rect.x * 0.95));
const y = Math.max(0, Math.floor(rect.y * 0.95));
const width = Math.min(image.bitmap.width - x, Math.floor(rect.width * 1.01));
const height = Math.min(image.bitmap.height - y, Math.floor(rect.height * 1.01));
const cropped = image.crop(x, y, width, height);

// Puppeteer + Sharp (크롭 방식 - 정확한 위치 캡쳐)
const sharp = require('sharp'); // 이미 설치되어 있음
// 전체 페이지 스크린샷
const fullScreenshot = await page.screenshot({ 
  type: 'png',
  encoding: 'binary',
  fullPage: true
});
// boundingBox 정보로 정확한 영역만 크롭
const x = Math.max(0, Math.floor(boundingBox.x * 0.95));
const y = Math.max(0, Math.floor(boundingBox.y * 0.95));
const width = Math.floor(boundingBox.width * 1.01);
const height = Math.floor(boundingBox.height * 1.01);
const cropped = await sharp(fullScreenshot)
  .extract({
    left: x,
    top: y,
    width: width,
    height: height
  })
  .png()
  .toBuffer();

// 또는 Jimp 사용 (선택 가능)
// const Jimp = require('jimp');
// const image = await Jimp.read(fullScreenshot);
// const cropped = image.crop(x, y, width, height);
// const croppedBuffer = await cropped.getBufferAsync(Jimp.MIME_PNG);
```

**⚠️ 중요**: 요소 단위 스크린샷(`table.screenshot()`)은 정확한 위치를 캡쳐하지 못할 수 있으므로, **전체 페이지 스크린샷 후 크롭 방식**을 사용하는 것을 권장합니다.

**5. 브라우저 종료**
```javascript
// Selenium
await driver.quit();

// Puppeteer
await browser.close();
```

**핵심 차이점**:
- Puppeteer는 요소 단위 스크린샷을 직접 지원하므로 크롭 로직이 더 간단함
- iframe 접근 방식이 다름 (Puppeteer는 `contentFrame()` 또는 `page.frames()` 사용)
- 요소 선택은 CSS 선택자로 동일하지만 API가 다름 (`$`, `$$` 사용)
- 대기 함수: `waitForSelector`, `waitForFunction` 등 사용

### 4. 정책표생성설정 탭 관련

#### ✅ 정책표생성설정 기능 (Q12, Q13 답변)

**Q12 답변**: 수정/삭제 기능
- **수정/삭제 가능**: 정책표생성설정에서 등록된 정책표를 수정/삭제할 수 있어야 함
- **수정 기능**: 
  - 정책표 목록에서 수정 버튼 클릭 시 모달 표시
  - 기존 데이터를 폼에 채워서 표시
  - 수정 후 저장 시 구글시트에 업데이트
- **삭제 기능**:
  - 정책표 목록에서 삭제 버튼 클릭
  - 삭제 확인 다이얼로그 표시
  - 삭제 시 구글시트에서 해당 행 제거

**Q13 답변**: 수정 시 영향 범위
- **기존 생성된 정책표에는 영향 없음**:
  - 이미 생성된 이미지는 디스코드에 저장되어 있음
  - 기존 정책표목록의 데이터는 그대로 유지
- **다음 생성될 정책표에만 영향**:
  - 구글시트의 정책표생성설정 데이터가 수정됨
  - 다음에 생성되는 정책표부터 수정된 설정이 적용됨
- **구현 시 고려사항**:
  - 정책표생성설정 수정 시 기존 생성된 정책표와의 연결 관계는 유지
  - 정책표ID는 변경되지 않음 (정책표이름, 링크, 디스코드채널ID, 생성자적용권한만 수정 가능)

### 5. 정책표목록 탭 관련

#### ✅ 정책표목록 기능 (Q14, Q15, Q16 답변)

**Q14 답변**: 정책표목록 테이블 컬럼
- **탭 구조**: 정책표이름별로 탭이 나뉘어 표시됨
  - 정책표생성설정에 등록된 각 정책표이름이 탭으로 표시됨
  - 각 탭을 클릭하면 해당 정책표의 목록만 표시됨
  - 정책표이름은 탭으로 표시되므로 테이블 컬럼에서 제외
- **탭별 테이블 컬럼**:
  1. **정책적용일시** (정책표생성 탭에서 입력한 적용일시)
  2. **생성자**
  3. **생성일시**
  4. **등록일시**
- **정책표생성 탭 개선**:
  - 생성 버튼 클릭 시 모달 표시
  - 모달 필드:
    - **정책적용일시** (입력필드): 정책이 적용되는 날짜/시간
    - **정책적용내용** (입력필드): 정책 적용 내용
  - 입력 완료 후 하단에 **정책표생성** 버튼 표시
  - 정책표생성 버튼 클릭 시 실제 생성 프로세스 시작
- **정책표목록 상세 화면**:
  - 테이블 행 선택 시 상세 화면 표시
  - **상단**: 정책적용일시와 정책적용내용 표시
  - **하단**: 생성된 정책표 이미지 표시

**Q15 답변**: 검색/필터링 기능
- **탭 구조로 인한 변경**: 정책표이름은 탭으로 구분되므로 검색에서 제외
- **탭 내부 검색/필터링**: 각 탭 내부의 테이블에서 검색/필터링
- **검색 필드**:
  - 생성자
  - 생성일시 (날짜 범위)
  - **정책적용일시** (날짜 범위)
- **전역 검색** (선택사항): 모든 탭을 통합하여 검색하는 기능도 고려 가능

**Q16 답변**: 삭제 기능 및 권한
- **삭제 기능 필요**: 정책표목록에서 정책표 삭제 가능
- **삭제 권한**:
  - **삭제 가능**: `'SS'` (총괄), `'AA'`-`'FF'` (팀장)
  - **삭제 불가**: `'A'`-`'F'` (일반 사용자)
- **권한 체크 로직**:
  ```javascript
  const canDelete = loggedInStore?.userRole === 'SS' || 
                    ['AA', 'BB', 'CC', 'DD', 'EE', 'FF'].includes(loggedInStore?.userRole);
  ```
- **삭제 기능**:
  - 각 탭 내부의 테이블에서 삭제 버튼 표시 (권한 있는 사용자만)
  - 삭제 확인 다이얼로그 표시
  - 삭제 시 구글시트에서 해당 행 제거
  - 디스코드의 이미지는 삭제하지 않음 (구글시트 데이터만 삭제)
  - 삭제 후 해당 탭의 테이블에서 즉시 제거

### 6. 권한 및 보안 관련

#### ✅ 권한 및 보안 관련 (Q17, Q18 답변)

**Q17 답변**: 생성자적용권한 선택 가능한 권한 목록
- **데이터 소스**: 대리점아이디관리 시트에서 팀장 권한자만 필터링
- **선택 가능한 권한**: 팀장 권한자만 선택 가능 (`'AA'`, `'BB'`, `'CC'`, `'DD'`, `'EE'`, `'FF'`)
- **이유**: 정책표생성 탭 접근 권한이 팀장(`'AA'`-`'FF'`)과 정산팀(`'S'`)만 가능하므로, 생성자적용권한도 팀장 권한자만 선택 가능하도록 제한
- **구현 방법**:
  ```javascript
  // 대리점아이디관리 시트에서 R열(17번 인덱스)이 'AA', 'BB', 'CC', 'DD', 'EE', 'FF'인 사용자만 필터링
  const teamLeaders = agents.filter(agent => 
    ['AA', 'BB', 'CC', 'DD', 'EE', 'FF'].includes(agent[17])
  );
  ```

**Q18 답변**: 정책표 생성 시 생성자 정보 식별
- **기존 로직과 동일**: 정책모드의 연장정책 추가 모달에서 소속정책팀을 선택하는 로직과 동일
- **구현 방법**:
  - `loggedInStore.userRole` (R열, 17번 인덱스)로 권한 레벨 확인
  - `loggedInStore.name` 또는 `loggedInStore.target`로 사용자 이름 확인
  - 정책모드의 `PolicyInputModal`에서 사용하는 `teams` 배열과 동일한 방식으로 팀 정보 로드
  - `/api/teams` 엔드포인트에서 팀 목록 가져오기
  - Autocomplete 컴포넌트를 사용하여 검색 가능한 드롭다운으로 구현
- **참고 코드**: `src/components/PolicyInputModal.js`의 소속정책팀 선택 로직 참고

### 7. 이미지 복사 기능 관련

#### ✅ 이미지 복사 기능 관련 (Q19, Q20 답변)

**Q19 답변**: 이미지 복사 실패 시 처리
- **복사 방식**: 클립보드 API를 사용하여 이미지를 클립보드에 복사
- **복사 실패 가능성**: 브라우저 권한 거부, 보안 정책 등으로 인해 실패할 수 있음
- **처리 방법**:
  - 복사 성공 시: 성공 메시지 표시 (예: "이미지가 클립보드에 복사되었습니다")
  - 복사 실패 시: 에러 메시지 표시 및 대안 제공
    - 에러 메시지: "이미지 복사에 실패했습니다. 브라우저 권한을 확인해주세요."
    - 대안: 이미지 다운로드 버튼 제공 또는 이미지 URL 표시
- **구현 방법**:
  ```javascript
  // Clipboard API 사용
  try {
    const response = await fetch(imageUrl);
    const blob = await response.blob();
    await navigator.clipboard.write([
      new ClipboardItem({ [blob.type]: blob })
    ]);
    // 성공 메시지 표시
  } catch (error) {
    // 실패 시 에러 메시지 표시 및 대안 제공
  }
  ```

**Q20 답변**: 모바일 브라우저에서 이미지 복사
- **모바일 지원 필요**: 모바일 브라우저에서도 이미지 복사가 가능해야 함
- **기술적 근거**: 디스코드에서 직접 생성한 이미지도 복사가 가능하므로, URL로 로드한 이미지도 동일하게 복사 가능할 것으로 예상
- **구현 방법**:
  - Clipboard API는 모던 브라우저(Chrome, Safari, Firefox 등)에서 지원
  - 모바일 브라우저에서도 Clipboard API 지원 확인 필요
  - 미지원 브라우저의 경우 대안 제공 (이미지 다운로드, 이미지 URL 표시 등)

### 8. 기타

#### ✅ 기타 사항 (Q21, Q22, Q23 답변)

**Q21 답변**: 구글 시트가 매우 큰 경우 처리
- **미리보기 기능**: 기본적으로 축소된 이미지를 미리보기로 표시
- **원본 이미지 보기**: 사용자가 이미지를 선택(클릭)하면 원본 이미지로 보여주는 창(모달 또는 다이얼로그) 띄우기
- **구현 방법**:
  - 정책표생성 탭에서 생성된 이미지를 썸네일(축소) 형태로 표시
  - 이미지 클릭 시 모달 또는 다이얼로그를 띄워 원본 이미지 표시
  - 원본 이미지 창에서 확대/축소 기능 제공 (선택사항)
- **장점**: 
  - 큰 이미지도 빠르게 로드 가능
  - 필요 시 원본 이미지 확인 가능
  - 사용자 경험 개선

**Q22 답변**: 브라우저 종료 또는 페이지 이탈 시 처리
- **백그라운드 작업 지속**: 브라우저를 닫거나 페이지를 이탈해도 정책표 생성은 계속 진행되어야 함
- **재로그인 시 결과 확인**: 사용자가 다시 로그인했을 때 이전에 내린 명령의 결과물이 표시되어야 함
- **구현 방법**:
  - 백그라운드 작업 + 상태 저장 방식 사용 (이미 문서에 명시됨)
  - 작업 ID를 구글시트에 저장하여 작업 상태 추적
  - 재로그인 시 미완료 작업 확인 및 결과 표시
  - 작업 완료 여부를 구글시트에 저장하여 재로그인 시 확인 가능하도록 구현
- **사용자 경험**:
  - 정책표생성 탭 진입 시 진행 중인 작업 또는 완료된 작업 결과 표시
  - 작업 상태에 따라 "생성 중", "생성 완료", "생성 실패" 등 표시

**Q23 답변**: 생성된 정책표 이미지의 최대 크기 제한
- **현재 상황**: 디스코드에서 이미 사용 중이므로 크기 제한은 큰 무리 없음
- **참고**: 제공된 참고 코드는 이전에 디스코드에서 사용 중이던 코드 로직
- **디스코드 업로드 제한**: 
  - 일반적으로 8MB 제한 (이미지 파일)
  - 참고 코드에서 이미 사용 중이므로 해당 제한 내에서 작동 중
- **구현 시 고려사항**:
  - 참고 코드의 이미지 크기 처리 로직 그대로 사용
  - 필요 시 이미지 압축 또는 리사이징 로직 추가 (현재는 불필요)
  - 디스코드 업로드 실패 시 에러 처리 및 재시도 로직 구현

---

## 🔧 구현 상세 가이드 (누락 방지 체크리스트)

### ⚠️ 구현 전 필수 확인 사항

#### 1. 환경 변수 확인 ✅ **구현 완료 (사용자 확인 필요)**
- [x] `DISCORD_BOT_TOKEN`: 디스코드 봇 토큰이 설정되어 있는지 확인 (코드에서 사용)
- [x] `GOOGLE_SHEETS_SPREADSHEET_ID`: 구글 시트 스프레드시트 ID 확인 (코드에서 `SHEET_ID` 사용)
- [x] Google Sheets API 인증 정보 확인 (서비스 계정 키 파일) (코드에서 사용)

#### 2. 구글 시트 시트 생성 확인 ✅ **구현 완료 (시트 자동 생성)**
- [x] `정책모드_정책표설정` 시트 생성 및 헤더 확인 (`ensureSheetHeaders`로 자동 생성)
- [x] `정책모드_정책표목록` 시트 생성 및 헤더 확인 (`ensureSheetHeaders`로 자동 생성)
- [x] `정책모드_일반사용자그룹` 시트 생성 및 헤더 확인 (`ensureSheetHeaders`로 자동 생성)
- [x] 각 시트의 헤더가 정확히 일치하는지 확인 (코드에서 정의됨)

#### 3. 의존성 패키지 확인 ✅ **구현 완료 (이미 설치됨)**
- [x] `puppeteer`: 이미 설치되어 있는지 확인 (코드에서 사용)
- [x] `sharp`: 이미 설치되어 있는지 확인 (코드에서 사용)
- [x] `discord.js`: 디스코드 봇 라이브러리 확인 (코드에서 사용)
- [x] `googleapis`: Google Sheets API 클라이언트 확인 (코드에서 사용)

---

### 📋 기능별 상세 구현 체크리스트

#### 1. 정책표생성설정 탭 구현

##### 1.1 정책표 추가 기능 ✅ **완료**
- [x] **UI 구성**
  - [x] "정책표 추가" 버튼 생성
  - [x] 모달 컴포넌트 생성 (Material-UI Dialog 사용)
  - [x] 모달 필드:
    - [x] 정책표이름 (TextField)
    - [x] 정책표링크 (TextField, URL 유효성 검사)
    - [x] 디스코드채널ID (TextField)
    - [x] 생성자적용권한 (Autocomplete, 검색 및 복수선택)
      - [x] 대리점아이디관리 시트에서 팀장 권한자만 필터링
      - [x] 검색 기능 구현
      - [x] 복수 선택 가능 (Chip 형태로 표시)
  
- [x] **백엔드 API 구현**
  - [x] `GET /api/policy-table-settings`: 정책표 설정 목록 조회
    - [x] 구글시트에서 데이터 읽기
    - [x] JSON 파싱 (생성자적용권한)
    - [x] 권한 체크 (SS만 접근 가능)
  - [x] `POST /api/policy-table-settings`: 정책표 설정 추가
    - [x] 입력 데이터 검증
    - [x] 정책표ID 자동 생성 (예: `PT_${Date.now()}`)
    - [x] 생성자적용권한을 JSON 문자열로 변환
    - [x] 등록일시, 등록자 정보 추가
    - [x] `ensureSheetHeaders` 호출
    - [x] 구글시트에 데이터 추가
  - [x] `PUT /api/policy-table-settings/:id`: 정책표 설정 수정
    - [x] 기존 데이터 조회
    - [x] 수정된 데이터로 업데이트
    - [x] 정책표ID는 변경 불가 (검증 추가)
  - [x] `DELETE /api/policy-table-settings/:id`: 정책표 설정 삭제
    - [x] 권한 체크 (SS만 가능)
    - [x] 삭제 확인 (기존 생성된 정책표와의 연결 확인)
    - [x] 구글시트에서 행 삭제

##### 1.2 일반사용자 그룹 관리 기능 ✅ **완료**
- [x] **UI 구성**
  - [x] "그룹 추가" 버튼 생성
  - [x] 그룹 추가 모달:
    - [x] 그룹이름 (TextField)
    - [x] 일반사용자 선택 (Autocomplete, 검색 및 복수선택)
      - [x] 대리점아이디관리 시트에서 일반사용자(A-F)만 필터링
      - [x] 검색 기능 구현
      - [x] 복수 선택 가능 (Chip 형태로 표시)
  - [x] 그룹 목록 테이블:
    - [x] 그룹이름, 포함된 일반사용자 수, 등록일시 표시
    - [x] 수정 버튼 (모달에 기존 데이터 로드)
    - [x] 삭제 버튼 (확인 다이얼로그)

- [x] **백엔드 API 구현**
  - [x] `GET /api/policy-table/user-groups`: 그룹 목록 조회
    - [x] 구글시트에서 데이터 읽기
    - [x] JSON 파싱 (일반사용자목록)
    - [x] 권한 체크 (SS만 접근 가능)
  - [x] `POST /api/policy-table/user-groups`: 그룹 추가
    - [x] 입력 데이터 검증
    - [x] 그룹ID 자동 생성 (예: `UG_${Date.now()}`)
    - [x] 일반사용자목록을 JSON 문자열로 변환
    - [x] 등록일시, 등록자 정보 추가
    - [x] `ensureSheetHeaders` 호출
    - [x] 구글시트에 데이터 추가
  - [x] `PUT /api/policy-table/user-groups/:id`: 그룹 수정
  - [x] `DELETE /api/policy-table/user-groups/:id`: 그룹 삭제
    - [x] 삭제 전 사용 중인 정책표 확인 (선택사항)

#### 2. 정책표생성 탭 구현

##### 2.1 생성 버튼 및 모달 ✅ **완료**
- [x] **UI 구성**
  - [x] 정책표생성설정에서 권한에 맞는 정책표별 생성 버튼 표시
  - [x] 생성 버튼 클릭 시 모달 표시
  - [x] 모달 필드:
    - [x] 정책적용일시 (DateTimePicker 또는 TextField with type="datetime-local")
    - [x] 정책적용내용 (TextField, multiline)
    - [x] 접근권한 (일반사용자 그룹 선택)
      - [x] 드롭다운 또는 Autocomplete
      - [x] 그룹 목록 로드 (`GET /api/policy-table/user-groups`)
      - [x] 선택 시 해당 그룹의 일반사용자 목록 미리보기 (선택사항)
  - [x] "정책표생성" 버튼 (모달 하단)
  - [x] 입력 유효성 검사 (필수 필드 확인)

##### 2.2 정책표 생성 프로세스 ✅ **완료**
- [x] **프론트엔드 구현**
  - [x] 생성 요청 전송 (`POST /api/policy-table/generate`)
  - [x] 작업 ID 수신 및 저장
  - [x] 진행 상황 폴링 시작 (하이브리드 폴링)
  - [x] 진행 상황 UI 표시:
    - [x] 로딩 스피너
    - [x] 진행 단계 표시 (예: "구글 시트 접근 중...", "이미지 캡쳐 중...")
    - [x] 진행률 표시 (LinearProgress)
  - [x] 완료 시 결과 표시:
    - [x] 생성된 이미지 미리보기 (썸네일)
    - [x] 이미지 클릭 시 원본 이미지 모달 표시
    - [x] "정책표등록" 버튼 표시

- [x] **백엔드 구현**
  - [x] `POST /api/policy-table/generate`: 생성 요청 처리
    - [x] 입력 데이터 검증
    - [x] 작업 ID 생성 (예: `JOB_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`)
    - [x] 작업 상태 초기화 (메모리)
    - [x] 백그라운드 작업 시작 (비동기)
    - [x] 즉시 작업 ID 반환
  - [x] 백그라운드 작업 함수:
    - [x] 단계 1: 구글 시트 접근
      - [x] Puppeteer 브라우저 실행
      - [x] 정책표링크로 이동
      - [x] iframe 찾기 (`#pageswitcher-content`)
      - [x] 상태 업데이트: `{ progress: 25, message: "구글 시트 접근 중..." }`
    - [x] 단계 2: 테이블 찾기 및 스크린샷
      - [x] iframe 내부에서 테이블 요소 찾기
      - [x] 테이블이 보이도록 스크롤
      - [x] `boundingBox()`로 위치 계산
      - [x] 전체 페이지 스크린샷
      - [x] Sharp로 테이블 영역만 크롭
      - [x] 상태 업데이트: `{ progress: 50, message: "이미지 캡쳐 중..." }`
    - [x] 단계 3: 디스코드 업로드
      - [x] 디스코드 봇 준비 확인
      - [x] 채널 가져오기 (디스코드채널ID)
      - [x] 스레드 찾기 또는 생성
        - [x] 스레드 이름: `"{생성자이름}-{정책표이름}"`
        - [x] 기존 스레드가 있으면 재사용, 없으면 생성
      - [x] 이미지 업로드
      - [x] 메시지ID, 스레드ID, 이미지URL 저장
      - [x] 상태 업데이트: `{ progress: 75, message: "디스코드 업로드 중..." }`
    - [x] 단계 4: 데이터 저장
      - [x] 정책표ID, 정책표이름, 정책적용일시, 정책적용내용, 접근권한 저장
      - [x] 생성자 정보 저장 (creatorName 또는 creatorRole)
      - [x] 생성일시 저장
      - [x] 디스코드메시지ID, 디스코드스레드ID, 이미지URL 저장
      - [x] 등록여부: "N" (초기값)
      - [x] 상태 업데이트: `{ progress: 100, status: "completed", result: {...} }`
    - [x] 에러 처리:
      - [x] 각 단계에서 try-catch로 에러 처리
      - [x] 상태 업데이트: `{ status: "failed", error: "에러 메시지" }`
      - [x] 브라우저 종료 보장 (finally 블록)
  - [x] `GET /api/policy-table/generate/:jobId/status`: 상태 조회
    - [x] 작업 ID로 상태 조회
    - [x] 상태 반환 (진행률, 메시지, 결과 등)

##### 2.3 재생성 기능 ✅ **완료**
- [x] **프론트엔드 구현**
  - [x] "다시 생성" 버튼 표시
  - [x] 클릭 시 모달 다시 표시 (기존 입력값 유지 또는 초기화)
  - [x] 이전 생성 결과 초기화
  - [x] 새로운 생성 프로세스 시작

##### 2.4 정책표 등록 기능 ✅ **완료**
- [x] **프론트엔드 구현**
  - [x] "정책표등록" 버튼 표시
  - [x] 클릭 시 등록 요청 (`POST /api/policy-tables/:id/register`)
  - [x] 등록 성공 시 알림 표시
  - [x] 정책표목록 탭으로 이동 (선택사항)

- [x] **백엔드 구현**
  - [x] `POST /api/policy-tables/:id/register`: 정책표 등록
    - [x] 정책표ID로 데이터 조회
    - [x] 등록여부를 "Y"로 변경
    - [x] 등록일시 저장
    - [x] 구글시트 업데이트

#### 3. 정책표목록 탭 구현

##### 3.1 탭 구조 ✅ **완료**
- [x] **프론트엔드 구현**
  - [x] 정책표이름별 탭 생성
    - [x] `GET /api/policy-tables/tabs`로 탭 목록 조회
    - [x] 권한 필터링 적용
    - [x] Material-UI Tabs 컴포넌트 사용
  - [x] 탭 클릭 시 해당 정책표의 목록만 표시
  - [x] 권한이 없는 탭은 숨김 처리

##### 3.2 테이블 표시 ✅ **완료**
- [x] **프론트엔드 구현**
  - [x] 테이블 컬럼: 정책적용일시, 생성자, 생성일시, 등록일시
  - [x] 정렬 기능 (정책적용일시 기준, 최신순 또는 오름차순)
  - [x] 페이지네이션 (선택사항)
  - [x] 검색/필터링:
    - [x] 생성자 검색
    - [x] 생성일시 범위 필터
    - [x] 정책적용일시 범위 필터

- [x] **백엔드 구현**
  - [x] `GET /api/policy-tables/tabs`: 탭 목록 조회
    - [x] 정책표생성설정에서 정책표이름 목록 가져오기
    - [x] 권한 필터링:
      - [x] SS, S, AA-FF: 모든 탭 반환
      - [x] A-F: 접근권한에 포함된 탭만 반환 (일반사용자 그룹 확인)
  - [x] `GET /api/policy-tables`: 정책표 목록 조회
    - [x] 쿼리 파라미터: `policyTableName` (필수), `applyDateFrom`, `applyDateTo`, `creator`, `createDateFrom`, `createDateTo`
    - [x] 권한 필터링 적용 (일반 사용자는 접근권한 그룹 확인)
    - [x] 등록여부가 "Y"인 데이터만 반환
    - [x] 정렬 (정책적용일시 기준)

##### 3.3 상세 화면 ✅ **완료**
- [x] **프론트엔드 구현**
  - [x] 테이블 행 클릭 시 상세 화면 표시
  - [x] 상단 영역:
    - [x] 정책적용일시 표시
    - [x] 정책적용내용 표시
  - [x] 하단 영역:
    - [x] 이미지 표시 (이미지 로드 실패 시 처리)
    - [x] "정책다시확인하기" 버튼 (이미지 로드 실패 시 표시)
    - [x] "이미지복사하기" 버튼
  - [x] 모달 또는 사이드 패널로 표시

- [x] **백엔드 구현**
  - [x] `GET /api/policy-tables/:id`: 정책표 상세 조회
    - [x] 정책표ID로 데이터 조회
    - [x] 권한 체크 (접근 가능한 사용자인지 확인, 일반 사용자는 그룹 확인)
    - [x] 정책적용일시, 정책적용내용, 이미지URL 등 반환
  - [x] `POST /api/policy-tables/:id/refresh-image`: 이미지 갱신
    - [x] 메시지ID로 디스코드 API 호출
    - [x] 새로운 이미지URL 가져오기
    - [x] 구글시트 업데이트
    - [x] 직영점관리모드의 디스코드모니터링 탭과 동일한 로직 사용

##### 3.4 이미지 복사 기능 ✅ **완료**
- [x] **프론트엔드 구현**
  - [x] Clipboard API 사용
  - [x] 이미지 URL에서 이미지 가져오기 (`fetch`)
  - [x] Blob으로 변환
  - [x] `navigator.clipboard.write()`로 복사
  - [x] 성공/실패 메시지 표시
  - [x] 실패 시 대안 제공 (이미지 다운로드 버튼)

##### 3.5 삭제 기능 ✅ **완료**
- [x] **프론트엔드 구현**
  - [x] 삭제 버튼 표시 (권한 있는 사용자만)
  - [x] 삭제 확인 다이얼로그
  - [x] 삭제 요청 (`DELETE /api/policy-tables/:id`)
  - [x] 삭제 후 테이블에서 제거

- [x] **백엔드 구현**
  - [x] `DELETE /api/policy-tables/:id`: 정책표 삭제
    - [x] 권한 체크 (SS, AA-FF만 가능)
    - [x] 구글시트에서 행 삭제
    - [x] 디스코드 이미지는 삭제하지 않음

#### 4. 권한 체크 구현

##### 4.1 프론트엔드 권한 체크 ✅ **완료**
- [x] 탭 렌더링 시 권한 체크
  - [x] `loggedInStore.userRole` 확인
  - [x] 권한이 없으면 탭 숨김 또는 비활성화
- [x] API 호출 전 권한 재확인
- [x] 직접 URL 접근 시도 차단

##### 4.2 백엔드 권한 체크 ✅ **완료**
- [x] 모든 API 엔드포인트에 권한 체크 미들웨어 추가
- [x] 대리점아이디관리 시트에서 사용자 정보 조회
- [x] C열(2번 인덱스): contactId로 사용자 ID 매칭
- [x] A열(0번 인덱스): 사용자 이름
- [x] R열(17번 인덱스)로 권한 레벨 확인
- [x] 권한이 없으면 403 Forbidden 반환
- [x] checkPermission 함수에서 사용자 정보 정확히 조회하도록 구현

##### 4.3 정책표목록 권한 필터링 ✅ **완료**
- [x] 일반 사용자(A-F) 권한 확인:
  - [x] 정책표의 접근권한 필드 확인
  - [x] 일반사용자 그룹 정보 조회
  - [x] 현재 사용자가 그룹에 포함되어 있는지 확인
  - [x] 탭 목록 조회 시 권한 필터링 적용
  - [x] 정책표 목록 조회 시 권한 필터링 적용
  - [x] 정책표 상세 조회 시 권한 체크 적용
- [x] 자동 권한 부여 (SS, S, AA-FF) 확인

---

### 🔍 데이터 검증 규칙

#### 1. 정책표생성설정 데이터 검증
- [ ] 정책표이름: 필수, 최대 100자
- [ ] 정책표링크: 필수, 유효한 URL 형식
- [ ] 디스코드채널ID: 필수, 숫자 문자열
- [ ] 생성자적용권한: 필수, 배열, 최소 1개 이상
- [ ] 중복 정책표이름 방지 (선택사항)

#### 2. 일반사용자 그룹 데이터 검증
- [ ] 그룹이름: 필수, 최대 50자, 중복 방지
- [ ] 일반사용자목록: 필수, 배열, 최소 1개 이상, A-F만 허용

#### 3. 정책표 생성 데이터 검증
- [ ] 정책적용일시: 필수, 유효한 날짜/시간 형식
- [ ] 정책적용내용: 필수, 최대 1000자
- [ ] 접근권한: 선택, 유효한 그룹ID 또는 null

---

### 🛠️ 에러 처리 시나리오

#### 1. 구글 시트 접근 실패
- [ ] 시트 권한 문제: "구글 시트 접근 권한이 없습니다. 시트 공유 설정을 확인해주세요."
- [ ] 시트가 존재하지 않음: "정책표 시트를 찾을 수 없습니다."
- [ ] 네트워크 오류: "구글 시트에 접근할 수 없습니다. 네트워크 연결을 확인해주세요."

#### 2. Puppeteer 관련 에러
- [ ] 브라우저 실행 실패: "브라우저를 실행할 수 없습니다. 서버 설정을 확인해주세요."
- [ ] iframe 찾기 실패: "정책표를 찾을 수 없습니다. 시트 URL을 확인해주세요."
- [ ] 테이블 찾기 실패: "정책표 테이블을 찾을 수 없습니다."
- [ ] 타임아웃: "정책표 로딩 시간이 초과되었습니다. 시트 크기를 확인해주세요."

#### 3. 디스코드 관련 에러
- [ ] 봇 토큰 오류: "디스코드 봇 연결에 실패했습니다."
- [ ] 채널 찾기 실패: "디스코드 채널을 찾을 수 없습니다. 채널 ID를 확인해주세요."
- [ ] 이미지 업로드 실패: "이미지 업로드에 실패했습니다. 디스코드 서버 상태를 확인해주세요."
- [ ] Rate Limit: 재시도 로직 적용 (withRetry 함수 사용)

#### 4. 이미지 처리 에러
- [ ] 스크린샷 실패: "이미지 캡쳐에 실패했습니다."
- [ ] 크롭 실패: "이미지 처리에 실패했습니다."
- [ ] 이미지 크기 초과: "이미지 크기가 너무 큽니다. (최대 8MB)"

#### 5. 구글시트 저장 에러
- [ ] 시트 쓰기 권한 없음: "구글 시트에 저장할 권한이 없습니다."
- [ ] 네트워크 오류: "데이터 저장에 실패했습니다. 네트워크 연결을 확인해주세요."

---

### 📐 UI 컴포넌트 상세 스펙

#### 1. 정책표생성설정 탭
- **레이아웃**: 
  - 상단: "정책표 추가" 버튼, "그룹 추가" 버튼
  - 중간: 정책표 목록 테이블, 그룹 목록 테이블 (탭으로 구분 가능)
  - 테이블 컬럼: 정책표이름, 정책표링크, 디스코드채널ID, 생성자적용권한, 등록일시, 수정/삭제 버튼

#### 2. 정책표생성 탭
- **레이아웃**:
  - 상단: 정책표별 생성 버튼 (카드 형태 또는 그리드)
  - 각 버튼: 정책표이름 표시
- **생성 모달**:
  - 제목: "정책표 생성"
  - 필드: 정책적용일시, 정책적용내용, 접근권한
  - 버튼: 취소, 정책표생성
- **생성 결과 화면**:
  - 진행 상황 표시 영역
  - 생성된 이미지 미리보기 (썸네일)
  - "다시 생성" 버튼
  - "정책표등록" 버튼

#### 3. 정책표목록 탭
- **레이아웃**:
  - 상단: 정책표이름별 탭
  - 중간: 검색/필터링 영역
  - 하단: 테이블 (정책적용일시, 생성자, 생성일시, 등록일시)
- **상세 화면** (모달 또는 사이드 패널):
  - 상단: 정책적용일시, 정책적용내용
  - 하단: 이미지, "정책다시확인하기" 버튼, "이미지복사하기" 버튼

---

### 🔐 보안 고려사항

#### 1. 입력 데이터 검증
- [ ] 모든 사용자 입력 검증 (서버 사이드)
- [ ] SQL Injection 방지 (구글시트 API 사용 시 자동 방지)
- [ ] XSS 방지 (프론트엔드에서 사용자 입력 이스케이프)

#### 2. 권한 체크
- [ ] 모든 API 엔드포인트에 권한 체크
- [ ] 프론트엔드 권한 체크는 UI용일 뿐, 백엔드에서 반드시 재확인
- [ ] 직접 URL 접근 시도 차단

#### 3. 에러 메시지
- [ ] 민감한 정보 노출 방지 (에러 메시지에 시스템 정보 포함하지 않음)
- [ ] 사용자 친화적인 에러 메시지 제공

---

### 🧪 테스트 시나리오

#### 1. 정책표생성설정 탭 테스트
- [ ] 정책표 추가 (성공)
- [ ] 정책표 추가 (중복 이름)
- [ ] 정책표 수정
- [ ] 정책표 삭제
- [ ] 일반사용자 그룹 추가/수정/삭제
- [ ] 권한 없는 사용자 접근 차단

#### 2. 정책표생성 탭 테스트
- [ ] 정책표 생성 (성공)
- [ ] 정책표 생성 (구글 시트 접근 실패)
- [ ] 정책표 생성 (디스코드 업로드 실패)
- [ ] 재생성 기능
- [ ] 정책표 등록
- [ ] 권한 없는 사용자 접근 차단

#### 3. 정책표목록 탭 테스트
- [ ] 탭 목록 조회 (권한별 필터링)
- [ ] 정책표 목록 조회 (탭별)
- [ ] 검색/필터링
- [ ] 상세 화면 표시
- [ ] 이미지 복사 (성공/실패)
- [ ] 이미지 갱신
- [ ] 정책표 삭제
- [ ] 권한 없는 사용자 접근 차단

---

### 📝 주의사항 및 함정

#### 1. Puppeteer 사용 시 주의사항
- [ ] 브라우저 인스턴스는 반드시 `finally` 블록에서 종료
- [ ] 타임아웃 설정 (5분)
- [ ] 메모리 누수 방지 (브라우저 인스턴스 재사용 고려)
- [ ] iframe 접근 시 `contentFrame()` 또는 `page.frames()` 사용
- [ ] 요소 단위 스크린샷 대신 전체 페이지 스크린샷 후 크롭 사용

#### 2. 디스코드 API 사용 시 주의사항
- [ ] Rate Limit 처리 (withRetry 함수 사용)
- [ ] 봇이 준비될 때까지 대기 (`discordBot.isReady()`)
- [ ] 스레드 이름 중복 방지 (생성자 이름 + 정책표이름 조합)
- [ ] 메시지ID 저장 (이미지 URL 갱신용)

#### 3. 구글시트 사용 시 주의사항
- [ ] `ensureSheetHeaders` 호출 필수 (시트 생성 및 헤더 확인)
- [ ] JSON 데이터는 문자열로 저장, 읽을 때 파싱
- [ ] 날짜/시간 형식 통일 (ISO 8601 형식 권장)
- [ ] 대량 데이터 처리 시 배치 처리 고려

#### 4. 권한 체크 주의사항
- [ ] 프론트엔드 권한 체크는 UI용일 뿐
- [ ] 백엔드에서 반드시 권한 재확인
- [ ] 일반 사용자 권한 체크 시 그룹 정보 확인 필수
- [ ] 권한 레벨 비교 시 대소문자 구분 주의

#### 5. 상태 관리 주의사항
- [ ] 백그라운드 작업 상태는 구글시트 또는 메모리에 저장
- [ ] 작업 ID는 고유해야 함 (타임스탬프 + 랜덤 문자열)
- [ ] 작업 완료 후 상태 정리 (메모리 사용량 관리)

---

### 🚀 구현 순서 권장사항

1. **1단계: 기반 구조 구축** ✅ **완료**
   - [x] 구글시트 시트 생성 및 헤더 확인
   - [x] API 라우트 구조 생성
   - [x] 권한 체크 미들웨어 구현
   - [x] 대리점아이디관리 시트에서 사용자 ID 매칭 로직 구현 (C열: contactId 사용)

2. **2단계: 정책표생성설정 탭** ✅ **완료**
   - [x] 정책표 추가/수정/삭제 기능
   - [x] 일반사용자 그룹 관리 기능
   - [x] UI 구현

3. **3단계: 정책표생성 탭 (백엔드)** ✅ **완료**
   - [x] Puppeteer를 사용한 구글 시트 캡쳐
   - [x] 디스코드 이미지 업로드
   - [x] 백그라운드 작업 처리
   - [x] 하이브리드 폴링 방식으로 진행 상황 전달

4. **4단계: 정책표생성 탭 (프론트엔드)** ✅ **완료**
   - [x] 생성 모달 UI
   - [x] 진행 상황 표시
   - [x] 결과 표시 및 등록 기능

5. **5단계: 정책표목록 탭** ✅ **완료**
   - [x] 탭 구조 구현
   - [x] 테이블 및 검색/필터링
   - [x] 상세 화면 및 이미지 복사
   - [x] 일반 사용자(A-F) 접근권한 필터링 로직 완성

6. **6단계: 통합 테스트 및 버그 수정** ⚠️ **테스트 필요**
   - [ ] 전체 플로우 테스트
   - [ ] 에러 처리 확인
   - [ ] 권한 체크 확인

---

## 📝 변경 이력
- 2024-XX-XX: 초기 문서 생성
- 2024-XX-XX: 구현 전 확인 필요 사항 추가
- 2024-XX-XX: 구현 상세 가이드 및 체크리스트 추가
- 2024-XX-XX: **구현 완료** - 모든 기능 구현 및 체크리스트 업데이트
  - ✅ 백엔드 권한 체크 함수: 대리점아이디관리 시트에서 C열(contactId)로 사용자 ID 매칭 로직 구현 완료
  - ✅ 정책표목록 권한 필터링: 일반 사용자(A-F)의 접근권한 필터링 로직 완성
  - ✅ 모든 탭 및 기능 구현 완료
  - ✅ PolicyMode.js에 메인 탭 추가 및 통합 완료

## ✅ 구현 완료 요약

### 구현된 파일 목록
1. **백엔드**:
   - `server/policyTableRoutes.js`: 정책표 생성 관련 모든 API 엔드포인트 (약 1,500줄)
   - `server/index.js`: 라우트 등록 추가

2. **프론트엔드**:
   - `src/components/policy/PolicyTableSettingsTab.js`: 정책표생성설정 탭 (약 650줄)
   - `src/components/policy/PolicyTableCreationTab.js`: 정책표생성 탭 (약 450줄)
   - `src/components/policy/PolicyTableListTab.js`: 정책표목록 탭 (약 455줄)
   - `src/components/PolicyMode.js`: 메인 탭 추가 및 통합

### 주요 구현 사항
- ✅ **권한 체크**: 대리점아이디관리 시트에서 C열(contactId)로 사용자 ID 매칭
- ✅ **정책표목록 권한 필터링**: 일반 사용자(A-F)의 접근권한 그룹 기반 필터링 완성
- ✅ **Puppeteer 이미지 캡쳐**: 구글 시트 전체 페이지 스크린샷 후 Sharp로 테이블 영역만 크롭
- ✅ **Discord 연동**: 스레드 생성 및 이미지 업로드, 메시지ID/스레드ID 저장
- ✅ **백그라운드 작업**: 하이브리드 폴링 방식으로 진행 상황 전달
- ✅ **이미지 복사**: Clipboard API 사용, 실패 시 에러 메시지 및 대안 제공
- ✅ **정책표이름별 탭 구조**: 정책표목록에서 정책표이름별로 탭 분리
- ✅ **일반사용자 그룹 관리**: 그룹 추가/수정/삭제 기능

### 테스트 필요 사항
- ⚠️ 실제 환경에서 전체 플로우 테스트 필요
- ⚠️ 권한 체크 동작 확인 필요 (특히 일반 사용자 접근권한 필터링)
- ⚠️ 에러 처리 시나리오 테스트 필요
- ⚠️ Puppeteer 브라우저 실행 환경 확인 필요

