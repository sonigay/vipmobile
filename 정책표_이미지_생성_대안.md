# 정책표 이미지 생성 대안 분석

## 현재 상황
- **현재 방식**: Google Sheets API로 데이터와 포맷 정보를 가져와서 Canvas로 수동 렌더링
- **문제점**: 
  - 브라우저에서 보이는 것과 정확히 일치하지 않음
  - 조건부 서식, 병합된 셀, 복잡한 스타일이 완벽하게 반영되지 않음
  - 폰트, 간격, 정렬 등이 실제 Google Sheets와 다를 수 있음

## 목표
Google Sheets가 브라우저에서 보이는 것과 **정확히 동일한** 이미지 생성

---

## 대안 1: Puppeteer/Playwright를 사용한 스크린샷 ⭐ (추천)

### 방법
1. Google Sheets 공개 링크를 사용하여 브라우저로 열기
2. Puppeteer/Playwright로 페이지 로드 후 스크린샷 캡처
3. 필요한 영역만 크롭

### 장점
- ✅ 브라우저에서 보이는 것과 **100% 동일**한 이미지
- ✅ 모든 스타일, 조건부 서식, 병합 셀 등 완벽 반영
- ✅ Google Sheets의 모든 기능 지원 (차트, 이미지 등도 포함 가능)
- ✅ 구현이 비교적 간단

### 단점
- ⚠️ Chrome/Chromium 설치 필요 (이전에 문제가 있었음)
- ⚠️ 메모리 사용량이 큼
- ⚠️ 처리 시간이 다소 걸림 (2-5초)

### 구현 방법
```javascript
const puppeteer = require('puppeteer');

async function captureSheetAsImage(sheetUrl) {
  const browser = await puppeteer.launch({
    headless: true,
    args: ['--no-sandbox', '--disable-setuid-sandbox']
  });
  const page = await browser.newPage();
  
  // Google Sheets 공개 링크로 이동
  await page.goto(sheetUrl, { waitUntil: 'networkidle0' });
  
  // 특정 영역 선택 (또는 전체 시트)
  const element = await page.$('.grid-container'); // 또는 특정 셀 범위
  const screenshot = await element.screenshot({ type: 'png' });
  
  await browser.close();
  return screenshot;
}
```

### Chrome 설치 문제 해결 방안
- **옵션 1**: Docker 이미지에 Chrome 포함 (권장)
- **옵션 2**: Cloudtype Build Variables에서 Chrome 설치 보장
- **옵션 3**: Playwright 사용 (Chrome 포함 버전)

---

## 대안 2: Google Drive API를 사용한 PDF 내보내기 후 이미지 변환

### 방법
1. Google Drive API로 Google Sheets를 PDF로 내보내기
2. PDF의 첫 페이지를 이미지로 변환 (pdfjs-dist 또는 pdf-poppler)
3. 필요한 영역만 크롭

### 장점
- ✅ Google Sheets의 공식 내보내기 기능 사용
- ✅ 스타일이 대부분 반영됨
- ✅ Chrome 설치 불필요

### 단점
- ⚠️ PDF 변환 시 일부 스타일 손실 가능 (폰트, 색상 등)
- ⚠️ PDF를 이미지로 변환하는 추가 단계 필요
- ⚠️ 이전에 pdfjs-dist와 Node.js Canvas 호환성 문제가 있었음

### 구현 방법
```javascript
const { google } = require('googleapis');
const pdfjsLib = require('pdfjs-dist/legacy/build/pdf.js');

async function exportSheetAsPDF(spreadsheetId, sheetId) {
  const drive = google.drive({ version: 'v3', auth });
  
  // PDF로 내보내기
  const response = await drive.files.export({
    fileId: spreadsheetId,
    mimeType: 'application/pdf',
    // 특정 시트만 내보내기 옵션
  }, { responseType: 'stream' });
  
  // PDF를 이미지로 변환
  // ... (pdfjs-dist 사용)
}
```

---

## 대안 3: Google Sheets Export API (공개 링크 활용)

### 방법
1. Google Sheets를 공개 링크로 공유
2. Export API를 사용하여 PNG/PDF로 직접 내보내기
3. URL: `https://docs.google.com/spreadsheets/d/{ID}/export?format=png&gid={GID}`

### 장점
- ✅ 매우 간단한 구현
- ✅ Chrome 설치 불필요
- ✅ 빠른 처리 속도

### 단점
- ⚠️ 공개 링크 필요 (보안 고려)
- ⚠️ 내보내기 옵션이 제한적 (해상도, 범위 등)
- ⚠️ 일부 스타일이 반영되지 않을 수 있음

### 구현 방법
```javascript
async function exportSheetAsImage(spreadsheetId, sheetId) {
  const exportUrl = `https://docs.google.com/spreadsheets/d/${spreadsheetId}/export?format=png&gid=${sheetId}&size=0&fzr=true&portrait=false&fitw=true&gridlines=false&printtitle=false&sheetnames=false&pagenumbers=false&attachment=false`;
  
  const response = await fetch(exportUrl);
  const imageBuffer = await response.buffer();
  return imageBuffer;
}
```

---

## 대안 4: 로컬 PC를 스크린샷 서버로 활용 ⭐⭐ (새로운 아이디어)

### 방법
1. 남는 PC에 간단한 웹 서버 구축 (Node.js + Express + Puppeteer)
2. 스크린샷 API 엔드포인트 제공
3. 클라우드 서버에서 로컬 PC의 API를 호출하여 스크린샷 요청
4. 로컬 PC에서 Chrome으로 스크린샷 생성 후 이미지 반환

### 장점
- ✅ **Chrome 설치 문제 완전 해결** (로컬 PC에 Chrome 설치)
- ✅ 서버 리소스 부담 없음 (클라우드 서버는 API 호출만)
- ✅ 외부 서비스 비용 없음
- ✅ 완전한 제어 가능 (보안, 설정 등)
- ✅ 고품질 스크린샷 (Puppeteer 사용)
- ✅ 브라우저에서 보는 것과 100% 동일

### 단점
- ⚠️ 로컬 PC가 항상 켜져 있어야 함
- ⚠️ 네트워크 설정 필요 (포트 포워딩, 동적 DNS 등)
- ⚠️ 인터넷 연결 필요
- ⚠️ 로컬 PC의 전력 소비

### 구현 방법

#### 1. 로컬 PC에 스크린샷 서버 구축

```javascript
// local-screenshot-server.js
const express = require('express');
const puppeteer = require('puppeteer');
const app = express();

app.use(express.json());

let browser = null;

// 브라우저 미리 시작 (성능 향상)
async function initBrowser() {
  browser = await puppeteer.launch({
    headless: true,
    args: ['--no-sandbox', '--disable-setuid-sandbox']
  });
  console.log('✅ 브라우저가 준비되었습니다.');
}

// 스크린샷 API
app.post('/screenshot', async (req, res) => {
  try {
    const { url, selector, waitTime = 2000 } = req.body;
    
    if (!browser) {
      await initBrowser();
    }
    
    const page = await browser.newPage();
    await page.setViewport({ width: 1920, height: 1080 });
    await page.goto(url, { waitUntil: 'networkidle0' });
    
    // 추가 대기 시간 (시트 로딩 완료 대기)
    await page.waitForTimeout(waitTime);
    
    let screenshot;
    if (selector) {
      // 특정 영역만 캡처
      const element = await page.$(selector);
      screenshot = await element.screenshot({ type: 'png' });
    } else {
      // 전체 페이지 캡처
      screenshot = await page.screenshot({ type: 'png', fullPage: true });
    }
    
    await page.close();
    
    res.setHeader('Content-Type', 'image/png');
    res.send(screenshot);
  } catch (error) {
    console.error('스크린샷 오류:', error);
    res.status(500).json({ error: error.message });
  }
});

// 헬스 체크
app.get('/health', (req, res) => {
  res.json({ status: 'ok', browser: browser ? 'ready' : 'not ready' });
});

const PORT = 3000;
app.listen(PORT, () => {
  console.log(`스크린샷 서버가 포트 ${PORT}에서 실행 중입니다.`);
  initBrowser();
});
```

#### 2. 클라우드 서버에서 로컬 PC API 호출

```javascript
// server/policyTableRoutes.js
async function captureSheetFromLocalServer(sheetUrl) {
  const LOCAL_SCREENSHOT_SERVER = process.env.LOCAL_SCREENSHOT_SERVER_URL || 'http://your-pc-ip:3000';
  
  try {
    const response = await fetch(`${LOCAL_SCREENSHOT_SERVER}/screenshot`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        url: sheetUrl,
        selector: '.grid-container', // Google Sheets 그리드 선택자
        waitTime: 3000 // 3초 대기
      })
    });
    
    if (!response.ok) {
      throw new Error(`스크린샷 서버 오류: ${response.status}`);
    }
    
    const imageBuffer = await response.buffer();
    return imageBuffer;
  } catch (error) {
    console.error('로컬 스크린샷 서버 호출 실패:', error);
    throw error;
  }
}
```

#### 3. 네트워크 설정

**옵션 A: 포트 포워딩 (라우터 설정)**
- 로컬 PC의 IP를 고정 IP로 설정
- 라우터에서 포트 포워딩 설정 (예: 외부 포트 3000 → 로컬 PC:3000)
- 클라우드 서버에서 공인 IP로 접근

**옵션 B: 동적 DNS (DDNS)**
- No-IP, DuckDNS 등 서비스 사용
- 도메인으로 접근 가능 (예: `your-pc.ddns.net:3000`)

**옵션 C: VPN/터널링**
- ZeroTier, Tailscale 등 사용
- 보안 강화 가능

**옵션 D: ngrok (개발/테스트용)**
- 간단한 터널링 서비스
- 프로덕션에는 부적합 (무료 버전 제한)

### 보안 고려사항
- API 키 인증 추가
- HTTPS 사용 (Let's Encrypt 등)
- 방화벽 설정 (특정 IP만 허용)
- 요청 제한 (Rate Limiting)

### 패키지 설치
```bash
# 로컬 PC에서
npm install express puppeteer
```

### 환경 변수
```env
# 클라우드 서버 .env
LOCAL_SCREENSHOT_SERVER_URL=http://your-pc-ip:3000
# 또는
LOCAL_SCREENSHOT_SERVER_URL=https://your-pc.ddns.net:3000
```

---

## 대안 4-1: 디스코드 봇 명령어를 통한 로컬 PC 스크린샷 ⭐⭐⭐⭐ (더 나은 방법!)

> 📖 **상세 구현 가이드**: [정책표_이미지_생성_디스코드봇_구현가이드.md](./정책표_이미지_생성_디스코드봇_구현가이드.md) 참조

### 방법
1. 로컬 PC에 디스코드 봇 구축 (Discord.js + Puppeteer)
2. 디스코드 슬래시 명령어 또는 메시지 명령어로 스크린샷 요청
3. 봇이 Google Sheets URL을 받아서 스크린샷 생성
4. 생성된 이미지를 디스코드 채널에 직접 업로드
5. 클라우드 서버는 디스코드 메시지에서 이미지 URL만 가져오기

### 장점
- ✅ **네트워크 설정 불필요** (디스코드만 연결되면 됨)
- ✅ **보안 강화** (외부 API 노출 없음, 디스코드 인증만 필요)
- ✅ **구현 간단** (포트 포워딩, DDNS 등 설정 불필요)
- ✅ Chrome 설치 문제 완전 해결
- ✅ 브라우저에서 보는 것과 100% 동일
- ✅ 클라우드 서버는 디스코드 API만 호출하면 됨

### 단점
- ⚠️ 로컬 PC가 항상 켜져 있어야 함
- ⚠️ 디스코드 봇 토큰 필요
- ⚠️ 디스코드 메시지에서 이미지 URL 추출 필요

### 구현 방법

#### 1. 로컬 PC에 디스코드 봇 구축

```javascript
// local-discord-bot.js
const { Client, GatewayIntentBits, SlashCommandBuilder, REST, Routes } = require('discord.js');
const puppeteer = require('puppeteer');

const DISCORD_BOT_TOKEN = process.env.DISCORD_BOT_TOKEN;
const CLIENT_ID = process.env.DISCORD_CLIENT_ID;

const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent
  ]
});

let browser = null;

// 브라우저 미리 시작
async function initBrowser() {
  browser = await puppeteer.launch({
    headless: true,
    args: ['--no-sandbox', '--disable-setuid-sandbox']
  });
  console.log('✅ 브라우저가 준비되었습니다.');
}

// 스크린샷 함수
async function captureSheetAsImage(sheetUrl) {
  if (!browser) {
    await initBrowser();
  }
  
  const page = await browser.newPage();
  await page.setViewport({ width: 1920, height: 1080 });
  
  try {
    await page.goto(sheetUrl, { waitUntil: 'networkidle0' });
    await page.waitForTimeout(3000); // 시트 로딩 대기
    
    // Google Sheets 그리드 영역 찾기
    const gridElement = await page.$('.grid-container') || await page.$('.grid-viewport');
    let screenshot;
    
    if (gridElement) {
      screenshot = await gridElement.screenshot({ type: 'png' });
    } else {
      // 전체 페이지 캡처
      screenshot = await page.screenshot({ type: 'png', fullPage: true });
    }
    
    return screenshot;
  } finally {
    await page.close();
  }
}

// 슬래시 명령어 등록
const commands = [
  new SlashCommandBuilder()
    .setName('screenshot')
    .setDescription('Google Sheets 스크린샷 생성')
    .addStringOption(option =>
      option.setName('url')
        .setDescription('Google Sheets URL')
        .setRequired(true)
    )
];

const rest = new REST({ version: '10' }).setToken(DISCORD_BOT_TOKEN);

(async () => {
  try {
    console.log('슬래시 명령어 등록 중...');
    await rest.put(
      Routes.applicationCommands(CLIENT_ID),
      { body: commands }
    );
    console.log('✅ 슬래시 명령어 등록 완료');
  } catch (error) {
    console.error('❌ 슬래시 명령어 등록 실패:', error);
  }
})();

// 슬래시 명령어 처리
client.on('interactionCreate', async interaction => {
  if (!interaction.isChatInputCommand()) return;
  
  if (interaction.commandName === 'screenshot') {
    await interaction.deferReply();
    
    try {
      const sheetUrl = interaction.options.getString('url');
      
      // 스크린샷 생성
      const imageBuffer = await captureSheetAsImage(sheetUrl);
      
      // 디스코드에 업로드
      await interaction.editReply({
        content: '✅ 스크린샷 생성 완료',
        files: [{
          attachment: imageBuffer,
          name: `screenshot_${Date.now()}.png`
        }]
      });
    } catch (error) {
      console.error('스크린샷 오류:', error);
      await interaction.editReply({
        content: `❌ 오류 발생: ${error.message}`
      });
    }
  }
});

// 메시지 명령어 (대안)
client.on('messageCreate', async message => {
  // 봇 메시지 무시
  if (message.author.bot) return;
  
  // 명령어 형식: !screenshot <URL>
  if (message.content.startsWith('!screenshot ')) {
    const sheetUrl = message.content.replace('!screenshot ', '').trim();
    
    const loadingMsg = await message.reply('📸 스크린샷 생성 중...');
    
    try {
      const imageBuffer = await captureSheetAsImage(sheetUrl);
      
      await loadingMsg.edit({
        content: '✅ 스크린샷 생성 완료',
        files: [{
          attachment: imageBuffer,
          name: `screenshot_${Date.now()}.png`
        }]
      });
    } catch (error) {
      console.error('스크린샷 오류:', error);
      await loadingMsg.edit({
        content: `❌ 오류 발생: ${error.message}`
      });
    }
  }
});

client.once('ready', () => {
  console.log(`✅ 디스코드 봇이 준비되었습니다: ${client.user.tag}`);
  initBrowser();
});

client.login(DISCORD_BOT_TOKEN);
```

#### 2. 클라우드 서버에서 디스코드 봇 명령어 호출

```javascript
// server/policyTableRoutes.js
async function captureSheetViaDiscordBot(sheetUrl, channelId) {
  const DISCORD_BOT_TOKEN = process.env.DISCORD_BOT_TOKEN;
  const { Client, GatewayIntentBits } = require('discord.js');
  
  // 디스코드 봇 클라이언트 (또는 기존 봇 사용)
  const bot = new Client({
    intents: [GatewayIntentBits.Guilds, GatewayIntentBits.GuildMessages]
  });
  
  await bot.login(DISCORD_BOT_TOKEN);
  
  const channel = await bot.channels.fetch(channelId);
  
  // 봇에게 명령어 전송 (DM 또는 특정 채널)
  const commandMessage = await channel.send(`!screenshot ${sheetUrl}`);
  
  // 봇의 응답 메시지 대기 (이미지 포함)
  const filter = (msg) => msg.author.bot && msg.attachments.size > 0;
  const collector = channel.createMessageCollector({ filter, time: 30000, max: 1 });
  
  return new Promise((resolve, reject) => {
    collector.on('collect', (msg) => {
      const imageUrl = msg.attachments.first().url;
      resolve(imageUrl);
    });
    
    collector.on('end', (collected) => {
      if (collected.size === 0) {
        reject(new Error('디스코드 봇 응답 시간 초과'));
      }
    });
  });
}
```

#### 3. 더 간단한 방법: 웹훅 사용

```javascript
// 로컬 PC에서 디스코드 웹훅으로 이미지 전송
async function sendScreenshotToWebhook(webhookUrl, imageBuffer) {
  const FormData = require('form-data');
  const fetch = require('node-fetch');
  
  const form = new FormData();
  form.append('file', imageBuffer, {
    filename: `screenshot_${Date.now()}.png`,
    contentType: 'image/png'
  });
  
  const response = await fetch(webhookUrl, {
    method: 'POST',
    body: form
  });
  
  const data = await response.json();
  return data.attachments[0].url; // 이미지 URL 반환
}
```

### 워크플로우

1. **클라우드 서버**: 정책표 생성 요청 받음
2. **클라우드 서버**: 디스코드 채널에 명령어 메시지 전송 (`!screenshot <URL>`)
3. **로컬 PC 봇**: 명령어 감지 → Puppeteer로 스크린샷 생성 → 디스코드에 업로드
4. **클라우드 서버**: 봇의 응답 메시지에서 이미지 URL 추출
5. **클라우드 서버**: 이미지 URL을 정책표 데이터에 저장

### 패키지 설치
```bash
# 로컬 PC에서
npm install discord.js puppeteer
```

### 환경 변수
```env
# 로컬 PC .env
DISCORD_BOT_TOKEN=your_bot_token
DISCORD_CLIENT_ID=your_client_id
```

### 장점 비교 (대안 4 vs 4-1)

| 항목 | 대안 4 (API 서버) | 대안 4-1 (디스코드 봇) |
|------|------------------|----------------------|
| 네트워크 설정 | 포트 포워딩 필요 | 불필요 (디스코드만 연결) |
| 보안 | API 노출 위험 | 디스코드 인증만 |
| 구현 복잡도 | 중간 | 낮음 |
| 외부 접근 | 공인 IP 필요 | 불필요 |

---

## 대안 5: 외부 스크린샷 서비스 활용

### 방법
1. Google Sheets 공개 링크를 외부 스크린샷 서비스에 전달
2. 서비스에서 스크린샷 생성 후 이미지 반환

### 장점
- ✅ Chrome 설치 불필요
- ✅ 서버 리소스 부담 없음
- ✅ 고품질 스크린샷

### 단점
- ⚠️ 외부 서비스 의존성
- ⚠️ 비용 발생 가능
- ⚠️ API 제한 및 속도 제한

### 서비스 예시
- htmlcsstoimage.com
- screenshotapi.net
- urlbox.io

---

## 대안 6: 현재 방식 개선 (Canvas 렌더링 고도화)

### 방법
1. Google Sheets API에서 더 많은 포맷 정보 가져오기
2. Canvas 렌더링 로직 개선
3. 폰트, 간격, 정렬 등을 더 정확하게 반영

### 장점
- ✅ Chrome 설치 불필요
- ✅ 빠른 처리 속도
- ✅ 기존 코드 기반으로 개선 가능

### 단점
- ⚠️ 완벽한 일치 달성 어려움
- ⚠️ 복잡한 스타일 구현 필요
- ⚠️ Google Sheets 업데이트 시 유지보수 필요

---

## 추천 순위

1. **대안 4-1 (디스코드 봇 명령어)** ⭐⭐⭐⭐ (최고 추천!)
   - 네트워크 설정 불필요 (디스코드만 연결)
   - 보안 강화 (외부 API 노출 없음)
   - 구현 간단
   - Chrome 설치 문제 완전 해결
   - 브라우저에서 보는 것과 100% 동일

2. **대안 4 (로컬 PC 스크린샷 서버)** ⭐⭐⭐
   - Chrome 설치 문제 완전 해결
   - 가장 정확한 결과 (Puppeteer 사용)
   - 비용 없음, 완전한 제어
   - 네트워크 설정 필요 (포트 포워딩 등)

3. **대안 1 (Puppeteer/Playwright)** ⭐⭐⭐
   - 가장 정확한 결과
   - Chrome 설치 문제만 해결하면 완벽
   - 로컬 PC가 없을 때 대안

4. **대안 3 (Export API)** ⭐⭐
   - 간단하고 빠름
   - 공개 링크만 있으면 바로 사용 가능
   - 품질이 약간 떨어질 수 있음

5. **대안 2 (PDF 내보내기)** ⭐
   - 중간 품질
   - PDF 변환 이슈 해결 필요

6. **대안 5 (외부 서비스)** ⭐
   - 비용 및 의존성 고려 필요

7. **대안 6 (현재 방식 개선)** ⭐
   - 완벽한 일치 어려움

---

## 다음 단계

1. **대안 선택**: 위 대안 중 하나 선택
2. **구현 계획**: 선택한 대안의 상세 구현 계획 수립
3. **테스트**: 실제 Google Sheets로 테스트하여 품질 확인
4. **배포**: 프로덕션 환경에 적용

---

## 질문

어떤 대안을 선택하시겠습니까? 또는 다른 아이디어가 있으시면 알려주세요.

