# 정책표 이미지 생성 - 디스코드 봇 구현 가이드

## 개요

로컬 PC에 디스코드 봇을 구축하여 Google Sheets 스크린샷을 생성하고, 클라우드 서버에서 봇 명령어를 호출하여 이미지를 받는 방식입니다.

> 📖 **워크플로우 상세 예시**: [정책표_이미지_생성_워크플로우_예시.md](./정책표_이미지_생성_워크플로우_예시.md) 참조

## 아키텍처

```
[클라우드 서버] 
    ↓ (디스코드 메시지 전송)
[디스코드 채널]
    ↓ (명령어 감지)
[로컬 PC 봇]
    ↓ (Puppeteer로 스크린샷)
[디스코드 채널] (이미지 업로드)
    ↓ (이미지 URL 추출)
[클라우드 서버] (이미지 URL 저장)
```

## 전체 워크플로우 상세 설명

### 1단계: 클라우드 서버에서 명령어 생성 및 전송

**클라우드 서버 (어플)**가 정책표 생성 요청을 받으면:

```javascript
// 예시: 정책표 생성 요청
{
  policyTableId: "PT_1234567890",
  applyDate: "2025-01-01",
  applyContent: "신규 정책 적용",
  creatorName: "홍길동"
}
```

**클라우드 서버**가 다음과 같은 명령어를 생성:

```
!screenshot https://docs.google.com/spreadsheets/d/1abc...xyz/edit#gid=0 policyTableName=경수일반 userName=홍길동
```

이 명령어를 **디스코드 채널에 메시지로 전송**

### 2단계: 로컬 PC 봇이 명령어 감지

**로컬 PC 봇**이 디스코드 채널을 모니터링하다가 `!screenshot`으로 시작하는 메시지를 발견

### 3단계: 로컬 PC 봇이 스크린샷 생성

**로컬 PC 봇**이:
1. 명령어에서 URL 추출: `https://docs.google.com/spreadsheets/d/1abc...xyz/edit#gid=0`
2. Puppeteer로 해당 URL 열기
3. 페이지 로딩 대기 (3초)
4. Google Sheets 그리드 영역 캡처
5. PNG 이미지 생성

### 4단계: 로컬 PC 봇이 이미지를 디스코드에 업로드

**로컬 PC 봇**이 생성한 이미지를 디스코드 채널에 업로드:

```
✅ 스크린샷 생성 완료
📋 정책표: 경수일반
👤 생성자: 홍길동
[이미지 첨부]
```

### 5단계: 클라우드 서버가 이미지 URL 추출

**클라우드 서버**가:
1. 봇이 업로드한 메시지 감지 (이미지 첨부 포함)
2. 이미지 URL 추출: `https://cdn.discordapp.com/attachments/.../screenshot.png`
3. 이 URL을 정책표 데이터에 저장

---

## 명령어 형식 상세

### 기본 명령어 형식

```
!screenshot <Google_Sheets_URL> [옵션들]
```

### 명령어 예시

#### 예시 1: 기본 명령어
```
!screenshot https://docs.google.com/spreadsheets/d/1abc123xyz/edit#gid=0
```

#### 예시 2: 정책표 이름과 사용자 정보 포함
```
!screenshot https://docs.google.com/spreadsheets/d/1abc123xyz/edit#gid=0 policyTableName=경수일반 userName=홍길동
```

#### 예시 3: 추가 옵션 포함
```
!screenshot https://docs.google.com/spreadsheets/d/1abc123xyz/edit#gid=0 policyTableName=경수일반 userName=홍길동 waitTime=5000 viewportWidth=2560
```

### 명령어 파라미터

| 파라미터 | 필수 | 설명 | 예시 |
|---------|------|------|------|
| URL | ✅ | Google Sheets URL | `https://docs.google.com/spreadsheets/d/...` |
| policyTableName | ❌ | 정책표 이름 (로깅용) | `policyTableName=경수일반` |
| userName | ❌ | 생성자 이름 (로깅용) | `userName=홍길동` |
| waitTime | ❌ | 페이지 로딩 대기 시간 (ms) | `waitTime=5000` |
| viewportWidth | ❌ | 브라우저 뷰포트 너비 | `viewportWidth=1920` |
| viewportHeight | ❌ | 브라우저 뷰포트 높이 | `viewportHeight=1080` |
| selector | ❌ | 특정 영역 선택자 | `selector=.grid-container` |
| fullPage | ❌ | 전체 페이지 캡처 여부 | `fullPage=true` |

---

## 1. 로컬 PC 디스코드 봇 구현

### 1.1 프로젝트 구조

```
local-discord-bot/
├── package.json
├── .env
├── ecosystem.config.js  (PM2 설정 파일)
├── bot.js
├── screenshot.js
└── logs/                (PM2 로그 폴더)
    ├── error.log
    └── out.log
```

### 1.2 package.json

```json
{
  "name": "local-discord-screenshot-bot",
  "version": "1.0.0",
  "description": "Google Sheets 스크린샷 생성 디스코드 봇",
  "main": "bot.js",
  "scripts": {
    "start": "node bot.js",
    "pm2:start": "pm2 start ecosystem.config.js",
    "pm2:stop": "pm2 stop discord-screenshot-bot",
    "pm2:restart": "pm2 restart discord-screenshot-bot",
    "pm2:logs": "pm2 logs discord-screenshot-bot",
    "pm2:status": "pm2 status"
  },
  "dependencies": {
    "discord.js": "^14.14.1",
    "puppeteer": "^21.6.1",
    "dotenv": "^16.3.1"
  }
}
```

### 1.3 .env 파일

```env
# 디스코드 봇 토큰
DISCORD_BOT_TOKEN=your_bot_token_here

# 디스코드 클라이언트 ID (슬래시 명령어 등록용)
DISCORD_CLIENT_ID=your_client_id_here

# 디스코드 채널 ID (명령어를 받을 채널)
DISCORD_CHANNEL_ID=your_channel_id_here

# 브라우저 옵션
PUPPETEER_HEADLESS=true
PUPPETEER_ARGS=--no-sandbox,--disable-setuid-sandbox
```

### 1.4 screenshot.js (스크린샷 생성 모듈)

```javascript
const puppeteer = require('puppeteer');

let browser = null;

// 브라우저 초기화 (한 번만 실행)
async function initBrowser() {
  if (browser) {
    return browser;
  }
  
  const args = process.env.PUPPETEER_ARGS 
    ? process.env.PUPPETEER_ARGS.split(',')
    : ['--no-sandbox', '--disable-setuid-sandbox'];
  
  browser = await puppeteer.launch({
    headless: process.env.PUPPETEER_HEADLESS !== 'false',
    args: args
  });
  
  console.log('✅ 브라우저가 준비되었습니다.');
  return browser;
}

// Google Sheets 스크린샷 생성
async function captureSheetAsImage(sheetUrl, options = {}) {
  const {
    waitTime = 3000,        // 페이지 로딩 대기 시간 (ms)
    viewportWidth = 1920,   // 뷰포트 너비
    viewportHeight = 1080,  // 뷰포트 높이
    selector = null,        // 특정 영역 선택자 (null이면 전체)
    fullPage = false        // 전체 페이지 캡처 여부
  } = options;
  
  if (!browser) {
    await initBrowser();
  }
  
  const page = await browser.newPage();
  
  try {
    // 뷰포트 설정
    await page.setViewport({ 
      width: viewportWidth, 
      height: viewportHeight 
    });
    
    // Google Sheets URL로 이동
    console.log(`📸 스크린샷 생성 중: ${sheetUrl}`);
    await page.goto(sheetUrl, { 
      waitUntil: 'networkidle0',
      timeout: 30000 
    });
    
    // 추가 대기 시간 (시트 로딩 완료 대기)
    await page.waitForTimeout(waitTime);
    
    let screenshot;
    
    if (selector) {
      // 특정 영역만 캡처
      console.log(`🎯 선택자로 캡처: ${selector}`);
      const element = await page.$(selector);
      if (!element) {
        throw new Error(`선택자를 찾을 수 없습니다: ${selector}`);
      }
      screenshot = await element.screenshot({ 
        type: 'png',
        encoding: 'binary'
      });
    } else if (fullPage) {
      // 전체 페이지 캡처
      console.log('📄 전체 페이지 캡처');
      screenshot = await page.screenshot({ 
        type: 'png', 
        fullPage: true,
        encoding: 'binary'
      });
    } else {
      // Google Sheets 그리드 영역 찾기
      const gridSelectors = [
        '.grid-container',
        '.grid-viewport',
        '[role="grid"]',
        '.sheets-grid-container'
      ];
      
      let gridElement = null;
      for (const sel of gridSelectors) {
        try {
          gridElement = await page.$(sel);
          if (gridElement) {
            console.log(`✅ 그리드 영역 찾음: ${sel}`);
            break;
          }
        } catch (e) {
          // 선택자 찾기 실패, 다음 시도
        }
      }
      
      if (gridElement) {
        screenshot = await gridElement.screenshot({ 
          type: 'png',
          encoding: 'binary'
        });
      } else {
        // 그리드를 찾지 못하면 전체 페이지 캡처
        console.log('⚠️ 그리드 영역을 찾지 못해 전체 페이지 캡처');
        screenshot = await page.screenshot({ 
          type: 'png',
          fullPage: true,
          encoding: 'binary'
        });
      }
    }
    
    console.log('✅ 스크린샷 생성 완료');
    return screenshot;
    
  } catch (error) {
    console.error('❌ 스크린샷 생성 오류:', error);
    throw error;
  } finally {
    await page.close();
  }
}

// 브라우저 종료
async function closeBrowser() {
  if (browser) {
    await browser.close();
    browser = null;
    console.log('🔒 브라우저가 종료되었습니다.');
  }
}

module.exports = {
  initBrowser,
  captureSheetAsImage,
  closeBrowser
};
```

### 1.5 bot.js (디스코드 봇 메인 파일)

```javascript
require('dotenv').config();
const { Client, GatewayIntentBits, EmbedBuilder } = require('discord.js');
const { initBrowser, captureSheetAsImage, closeBrowser } = require('./screenshot');

const DISCORD_BOT_TOKEN = process.env.DISCORD_BOT_TOKEN;
const DISCORD_CHANNEL_ID = process.env.DISCORD_CHANNEL_ID;

if (!DISCORD_BOT_TOKEN) {
  console.error('❌ DISCORD_BOT_TOKEN이 설정되지 않았습니다.');
  process.exit(1);
}

const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent
  ]
});

// 봇 준비 완료
client.once('ready', async () => {
  console.log(`✅ 디스코드 봇이 준비되었습니다: ${client.user.tag}`);
  console.log(`📡 채널 ID: ${DISCORD_CHANNEL_ID || '모든 채널'}`);
  
  // 브라우저 초기화
  await initBrowser();
});

// 메시지 명령어 처리
client.on('messageCreate', async (message) => {
  // 봇 메시지 무시
  if (message.author.bot) return;
  
  // 특정 채널만 처리 (설정된 경우)
  if (DISCORD_CHANNEL_ID && message.channel.id !== DISCORD_CHANNEL_ID) {
    return;
  }
  
  // 명령어 형식: !screenshot <URL> [옵션]
  // 예: !screenshot https://docs.google.com/spreadsheets/d/... policyTableName=경수일반 userName=홍길동
  if (message.content.startsWith('!screenshot ')) {
    const commandText = message.content.replace('!screenshot ', '').trim();
    
    // URL과 옵션 파싱
    const parts = commandText.split(' ');
    const sheetUrl = parts[0];
    
    // 옵션 파싱
    const options = {};
    for (let i = 1; i < parts.length; i++) {
      const part = parts[i];
      if (part.includes('=')) {
        const [key, value] = part.split('=');
        options[key] = decodeURIComponent(value);
      }
    }
    
    const policyTableName = options.policyTableName || '정책표';
    const userName = options.userName || 'Unknown';
    
    // 로딩 메시지
    const loadingMsg = await message.reply({
      content: `📸 **스크린샷 생성 중...**\n` +
               `📋 정책표: ${policyTableName}\n` +
               `👤 사용자: ${userName}\n` +
               `🔗 URL: ${sheetUrl.substring(0, 50)}...`
    });
    
    try {
      // 스크린샷 생성
      const imageBuffer = await captureSheetAsImage(sheetUrl, {
        waitTime: 3000,
        viewportWidth: 1920,
        viewportHeight: 1080
      });
      
      // 성공 메시지와 이미지 업로드
      const embed = new EmbedBuilder()
        .setTitle('✅ 스크린샷 생성 완료')
        .setDescription(`**정책표**: ${policyTableName}\n**생성자**: ${userName}`)
        .setColor(0x00FF00)
        .setTimestamp();
      
      await loadingMsg.edit({
        content: '',
        embeds: [embed],
        files: [{
          attachment: imageBuffer,
          name: `정책표_${policyTableName}_${Date.now()}.png`
        }]
      });
      
      console.log(`✅ 스크린샷 생성 완료: ${policyTableName} (${userName})`);
      
    } catch (error) {
      console.error('❌ 스크린샷 생성 오류:', error);
      
      const errorEmbed = new EmbedBuilder()
        .setTitle('❌ 스크린샷 생성 실패')
        .setDescription(`오류: ${error.message}`)
        .setColor(0xFF0000)
        .setTimestamp();
      
      await loadingMsg.edit({
        content: '',
        embeds: [errorEmbed]
      });
    }
  }
  
  // 헬스 체크 명령어
  if (message.content === '!health') {
    const embed = new EmbedBuilder()
      .setTitle('🤖 봇 상태')
      .setDescription('✅ 정상 작동 중')
      .setColor(0x00FF00)
      .setTimestamp();
    
    await message.reply({ embeds: [embed] });
  }
});

// 에러 처리
client.on('error', (error) => {
  console.error('❌ 디스코드 봇 오류:', error);
});

// 프로세스 종료 시 브라우저 종료
process.on('SIGINT', async () => {
  console.log('\n🛑 봇 종료 중...');
  await closeBrowser();
  client.destroy();
  process.exit(0);
});

// 봇 로그인
client.login(DISCORD_BOT_TOKEN).catch(error => {
  console.error('❌ 디스코드 봇 로그인 실패:', error);
  process.exit(1);
});
```

---

## 2. 클라우드 서버 구현

### 2.1 policyTableRoutes.js 수정

기존 `processPolicyTableGeneration` 함수에서 Canvas 렌더링 부분을 디스코드 봇 명령어 호출로 변경합니다.

```javascript
// server/policyTableRoutes.js

const { Client, GatewayIntentBits } = require('discord.js');

// 디스코드 봇 클라이언트 (이미 초기화된 봇 사용 또는 새로 생성)
let discordBotForCommands = null;

// 디스코드 봇 초기화 (명령어 전송용)
async function initDiscordBotForCommands() {
  if (discordBotForCommands && discordBotForCommands.isReady()) {
    return discordBotForCommands;
  }
  
  const DISCORD_BOT_TOKEN = process.env.DISCORD_BOT_TOKEN;
  if (!DISCORD_BOT_TOKEN) {
    throw new Error('DISCORD_BOT_TOKEN이 설정되지 않았습니다.');
  }
  
  discordBotForCommands = new Client({
    intents: [
      GatewayIntentBits.Guilds,
      GatewayIntentBits.GuildMessages,
      GatewayIntentBits.MessageContent
    ]
  });
  
  await discordBotForCommands.login(DISCORD_BOT_TOKEN);
  
  // 봇이 준비될 때까지 대기
  return new Promise((resolve, reject) => {
    discordBotForCommands.once('ready', () => {
      console.log('✅ 디스코드 봇 (명령어 전송용) 준비 완료');
      resolve(discordBotForCommands);
    });
    
    setTimeout(() => {
      reject(new Error('디스코드 봇 준비 시간 초과'));
    }, 30000);
  });
}

// 디스코드 봇 명령어를 통한 스크린샷 생성
async function captureSheetViaDiscordBot(sheetUrl, policyTableName, userName, channelId) {
  try {
    // 봇 초기화
    const bot = await initDiscordBotForCommands();
    
    // 채널 가져오기
    const channel = await bot.channels.fetch(channelId);
    if (!channel) {
      throw new Error(`디스코드 채널을 찾을 수 없습니다: ${channelId}`);
    }
    
    // ===== 1단계: 명령어 생성 (동적) =====
    // 정책표 이름과 사용자 정보를 URL 인코딩하여 명령어 생성
    const command = `!screenshot ${sheetUrl} policyTableName=${encodeURIComponent(policyTableName)} userName=${encodeURIComponent(userName)}`;
    
    console.log(`📤 [클라우드서버] 디스코드 명령어 전송:`);
    console.log(`   명령어: ${command.substring(0, 100)}...`);
    console.log(`   정책표: ${policyTableName}`);
    console.log(`   사용자: ${userName}`);
    
    // ===== 2단계: 명령어 메시지 전송 =====
    // 디스코드 채널에 명령어를 메시지로 전송
    // 로컬 PC 봇이 이 메시지를 감지하고 처리함
    const commandMessage = await channel.send(command);
    console.log(`✅ [클라우드서버] 명령어 메시지 전송 완료 (메시지 ID: ${commandMessage.id})`);
    
    // ===== 3단계: 봇의 응답 메시지 대기 =====
    // 로컬 PC 봇이 스크린샷을 생성하고 이미지를 업로드할 때까지 대기
    const filter = (msg) => {
      // 필터 조건:
      // 1. 같은 채널
      // 2. 봇이 보낸 메시지 (로컬 PC 봇)
      // 3. 이미지가 포함되어 있음
      // 4. 명령어 메시지 이후에 온 메시지
      return msg.channel.id === channelId &&
             msg.author.bot &&
             msg.attachments.size > 0 &&
             msg.createdTimestamp > commandMessage.createdTimestamp;
    };
    
    // 최대 60초 대기, 최대 1개 메시지 수집
    const collector = channel.createMessageCollector({ 
      filter, 
      time: 60000, 
      max: 1 
    });
    
    console.log(`⏳ [클라우드서버] 로컬 PC 봇의 응답 대기 중... (최대 60초)`);
    
    return new Promise((resolve, reject) => {
      collector.on('collect', (msg) => {
        console.log(`📥 [클라우드서버] 봇 응답 메시지 수신 (메시지 ID: ${msg.id})`);
        
        const attachment = msg.attachments.first();
        if (attachment && attachment.contentType?.startsWith('image/')) {
          const imageUrl = attachment.url;
          console.log(`✅ [클라우드서버] 스크린샷 이미지 URL 추출 성공:`);
          console.log(`   URL: ${imageUrl}`);
          resolve(imageUrl);
        } else {
          reject(new Error('이미지가 포함된 메시지를 찾을 수 없습니다.'));
        }
      });
      
      collector.on('end', (collected) => {
        if (collected.size === 0) {
          console.error(`❌ [클라우드서버] 디스코드 봇 응답 시간 초과 (60초)`);
          reject(new Error('디스코드 봇 응답 시간 초과 (60초)'));
        }
      });
    });
    
  } catch (error) {
    console.error('❌ [클라우드서버] 디스코드 봇 명령어 실행 오류:', error);
    throw error;
  }
}

// processPolicyTableGeneration 함수 수정
async function processPolicyTableGeneration(jobId, params) {
  const { policyTableId, applyDate, applyContent, accessGroupId, creatorName, creatorRole } = params;

  try {
    // ... (기존 코드: 정책표 설정 조회 등)
    
    const policyTableName = settingsRow[1];
    const policyTableLink = settingsRow[3];
    const discordChannelId = settingsRow[5];
    
    // ... (기존 코드)
    
    // 2. 디스코드 봇을 통한 스크린샷 생성 (Canvas 렌더링 대체)
    updateJobStatus(jobId, {
      status: 'processing',
      progress: 50,
      message: '디스코드 봇으로 스크린샷 생성 중...'
    });
    
    // Google Sheets 공개 링크 생성 (또는 편집 링크 사용)
    const sheetUrl = policyTablePublicLink || policyTableLink;
    
    // 디스코드 봇 명령어로 스크린샷 생성
    const imageUrl = await captureSheetViaDiscordBot(
      sheetUrl,
      policyTableName,
      creatorName,
      discordChannelId
    );
    
    // 3. 디스코드에 이미지 업로드 (기존 로직 유지 또는 제거)
    // 이미 imageUrl을 받았으므로 추가 업로드 불필요할 수 있음
    // 하지만 기존 워크플로우를 유지하려면 아래 코드 사용
    
    updateJobStatus(jobId, {
      status: 'processing',
      progress: 75,
      message: '디스코드 업로드 중...'
    });
    
    // 디스코드 채널에 이미지 URL을 메시지로 전송 (선택사항)
    // 또는 imageUrl을 그대로 사용
    
    const messageId = null; // 봇이 이미 업로드했으므로 null
    const threadId = null;  // 필요시 스레드 ID 추출
    
    // 4. 구글시트에 저장
    updateJobStatus(jobId, {
      status: 'processing',
      progress: 90,
      message: '데이터 저장 중...'
    });
    
    // ... (기존 저장 로직)
    
    const newRow = [
      newRowId,
      policyTableId,
      policyTableName,
      applyDate,
      applyContent,
      accessGroupId || '',
      creatorName || 'Unknown',
      createdAt,
      messageId,      // null 또는 봇 메시지 ID
      threadId,       // null 또는 스레드 ID
      imageUrl,       // 디스코드 봇이 생성한 이미지 URL
      'N',
      ''
    ];
    
    // ... (나머지 코드)
    
  } catch (error) {
    // 에러 처리
    console.error('[정책표] 생성 오류:', error);
    updateJobStatus(jobId, {
      status: 'failed',
      progress: 0,
      message: `오류: ${error.message}`
    });
    throw error;
  }
}
```

### 2.2 환경 변수 추가

```env
# server/.env
DISCORD_BOT_TOKEN=your_bot_token_here
DISCORD_CHANNEL_ID=your_channel_id_here
```

---

## 3. 동적 명령어 생성 예시

### 3.1 정책표 이름과 사용자 정보 포함

```javascript
// 클라우드 서버에서
function generateScreenshotCommand(sheetUrl, policyTableName, userName) {
  // URL 인코딩하여 특수문자 처리
  const encodedTableName = encodeURIComponent(policyTableName);
  const encodedUserName = encodeURIComponent(userName);
  
  return `!screenshot ${sheetUrl} policyTableName=${encodedTableName} userName=${encodedUserName}`;
}

// 사용 예시
const command = generateScreenshotCommand(
  'https://docs.google.com/spreadsheets/d/...',
  '경수일반',
  '홍길동'
);
// 결과: !screenshot https://... policyTableName=%EA%B2%BD%EC%88%98%EC%9D%BC%EB%B0%98 userName=%ED%99%8D%EA%B8%B8%EB%8F%99
```

### 3.2 추가 옵션 포함

```javascript
function generateScreenshotCommandWithOptions(sheetUrl, options) {
  const {
    policyTableName,
    userName,
    waitTime = 3000,
    viewportWidth = 1920,
    viewportHeight = 1080
  } = options;
  
  let command = `!screenshot ${sheetUrl}`;
  
  if (policyTableName) {
    command += ` policyTableName=${encodeURIComponent(policyTableName)}`;
  }
  if (userName) {
    command += ` userName=${encodeURIComponent(userName)}`;
  }
  if (waitTime) {
    command += ` waitTime=${waitTime}`;
  }
  if (viewportWidth) {
    command += ` viewportWidth=${viewportWidth}`;
  }
  if (viewportHeight) {
    command += ` viewportHeight=${viewportHeight}`;
  }
  
  return command;
}
```

---

## 4. 설치 및 실행

### 4.1 로컬 PC에서

```bash
# 프로젝트 폴더 생성
mkdir local-discord-bot
cd local-discord-bot

# package.json 생성 (위 내용 복사)
# .env 파일 생성 (토큰 등 설정)

# 패키지 설치
npm install

# 봇 실행 (일시적)
npm start
```

### 4.2 PM2를 사용한 백그라운드 실행 (권장)

디스코드 봇은 **항상 실행되어 있어야** 명령어를 받을 수 있습니다. PM2를 사용하면 프로세스가 종료되어도 자동으로 재시작되고, PC 재부팅 후에도 자동 실행됩니다.

#### PM2 설치

```bash
# PM2 전역 설치
npm install -g pm2
```

#### PM2 설정 파일 생성

`ecosystem.config.js` 파일 생성:

```javascript
module.exports = {
  apps: [{
    name: 'discord-screenshot-bot',
    script: './bot.js',
    instances: 1,
    autorestart: true,
    watch: false,
    max_memory_restart: '1G',
    env: {
      NODE_ENV: 'production'
    },
    error_file: './logs/error.log',
    out_file: './logs/out.log',
    log_date_format: 'YYYY-MM-DD HH:mm:ss Z',
    merge_logs: true
  }]
};
```

#### PM2로 봇 실행

```bash
# 봇 시작
pm2 start ecosystem.config.js

# 봇 상태 확인
pm2 status

# 봇 로그 확인
pm2 logs discord-screenshot-bot

# 봇 재시작
pm2 restart discord-screenshot-bot

# 봇 중지
pm2 stop discord-screenshot-bot

# 봇 삭제
pm2 delete discord-screenshot-bot
```

#### PC 재부팅 후 자동 실행 설정

```bash
# PM2 시작 스크립트 생성 (Windows)
pm2 startup

# 생성된 명령어를 관리자 권한으로 실행
# 예: sudo env PATH=$PATH:/usr/bin pm2 startup systemd -u $USER --hp $HOME

# 현재 실행 중인 앱 저장
pm2 save
```

이제 PC를 재부팅해도 봇이 자동으로 실행됩니다.

#### PM2 유용한 명령어

```bash
# 실시간 로그 모니터링
pm2 logs discord-screenshot-bot --lines 100

# 메모리 사용량 확인
pm2 monit

# 모든 앱 재시작
pm2 restart all

# 모든 앱 중지
pm2 stop all
```

### 4.3 Windows에서 서비스로 실행 (대안)

Windows에서는 `pm2-windows-startup` 또는 `node-windows`를 사용할 수 있습니다.

```bash
# node-windows 설치
npm install -g node-windows

# 서비스 설치 스크립트 생성
node-windows install
```

### 4.4 디스코드 봇 토큰 발급

1. https://discord.com/developers/applications 접속
2. New Application 생성
3. Bot 탭에서 봇 생성
4. Token 복사하여 .env에 설정
5. OAuth2 > URL Generator에서 `bot`과 `Send Messages` 권한 선택
6. 생성된 URL로 봇을 서버에 초대

---

## 5. 테스트

### 5.1 로컬 PC 봇 테스트

디스코드 채널에서:
```
!screenshot https://docs.google.com/spreadsheets/d/... policyTableName=테스트정책표 userName=테스트사용자
```

### 5.2 클라우드 서버 테스트

정책표 생성 API를 호출하여 전체 워크플로우 테스트

---

## 7. 트러블슈팅

### 7.1 봇이 응답하지 않을 때
- 봇이 서버에 초대되었는지 확인
- 채널 ID가 올바른지 확인
- 봇에 메시지 보내기 권한이 있는지 확인

### 7.2 스크린샷이 생성되지 않을 때
- Chrome이 설치되어 있는지 확인
- Puppeteer가 정상 작동하는지 확인
- Google Sheets URL이 공개 링크인지 확인

### 7.3 타임아웃 오류

### 7.4 PM2 관련 문제

**봇이 시작되지 않을 때:**
```bash
# PM2 로그 확인
pm2 logs discord-screenshot-bot --err

# 봇 재시작
pm2 restart discord-screenshot-bot

# PM2 프로세스 목록 확인
pm2 list
```

**PC 재부팅 후 봇이 실행되지 않을 때:**
```bash
# PM2 startup 다시 설정
pm2 unstartup
pm2 startup
pm2 save
```
- `waitTime` 옵션 증가
- 네트워크 연결 확인
- Google Sheets 로딩 시간 확인

---

## 8. 보안 고려사항

1. **봇 토큰 보안**: .env 파일을 절대 공개하지 않음
2. **채널 제한**: 특정 채널에서만 명령어 수신
3. **사용자 인증**: 필요시 명령어에 인증 토큰 추가
4. **명령어 검증**: URL 형식 검증 등

---

## 9. 향후 개선 사항

1. **슬래시 명령어 지원**: `/screenshot` 형식
2. **이미지 최적화**: 크기 조정, 압축 등
3. **에러 재시도**: 실패 시 자동 재시도
4. **로깅**: 상세한 로그 기록
5. **모니터링**: 봇 상태 모니터링

