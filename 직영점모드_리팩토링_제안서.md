# 직영점모드/직영점관리모드 리팩토링 제안서

## 📊 현재 상황 분석

### 구현 상태
- ✅ **90% 완성**: 핵심 기능은 모두 구현됨
- ⚠️ **10% 디버깅**: 반복적인 버그와 복잡성으로 인한 지연
- 🔄 **반복적 문제**: 금액 계산 로직의 복잡성으로 인한 지속적인 수정

### 발견된 주요 문제점

#### 1. **금액 계산 로직의 분산**
```
- MobileListTab.js: 1,858줄 (가격 계산 큐, 캐싱, 재시도 로직)
- OpeningInfoPage.js: 1,492줄 (할부, 요금제, 부가서비스 계산)
- directRoutes.js: 4,451줄 (서버 측 계산, 이통사지원금 매핑)
- 총 7,801줄의 복잡한 계산 로직
```

#### 2. **복잡한 상태 관리**
- 여러 ref 사용 (pendingRequestsRef, initializedRef, queueProcessingCountRef 등)
- 복잡한 큐 시스템 (priceCalculationQueueRef)
- 캐싱 로직이 여러 곳에 분산
- 초기화 로직이 복잡함

#### 3. **코드 중복**
- 모델명 정규화 로직이 여러 곳에 반복
- 가격 계산 로직이 클라이언트/서버 양쪽에 존재
- 에러 핸들링이 일관성 없음

#### 4. **데이터 흐름의 복잡성**
```
시트 데이터 → 서버 파싱 → 캐싱 → 클라이언트 계산 → UI 업데이트
  ↓
각 단계마다 에러 처리, 재시도, 폴백 로직이 복잡하게 얽혀있음
```

---

## 🎯 제안: 단계적 리팩토링 (재설계보다 권장)

### 왜 재설계보다 리팩토링인가?

#### ✅ 리팩토링의 장점
1. **기존 기능 보존**: 90% 완성된 기능을 유지하면서 개선
2. **점진적 개선**: 위험을 최소화하면서 단계적으로 개선
3. **빠른 완성**: 재설계보다 훨씬 빠르게 완성 가능
4. **검증된 로직 활용**: 이미 작동하는 로직을 재활용

#### ❌ 재설계의 단점
1. **시간 소요**: 처음부터 다시 만들면 더 오래 걸림
2. **새로운 버그**: 새로운 코드에서 예상치 못한 버그 발생 가능
3. **기능 누락 위험**: 기존 기능을 놓칠 수 있음
4. **테스트 부담**: 모든 기능을 다시 테스트해야 함

---

## 🛠️ 구체적인 리팩토링 계획

### Phase 1: 계산 로직 통합 (1-2주)

#### 1.1 계산 엔진 분리
```javascript
// 새 파일: src/utils/directStoreCalculationEngine.js
class DirectStoreCalculationEngine {
  // 모든 계산 로직을 한 곳에 통합
  calculateMobilePrice(model, planGroup, openingType, carrier) { }
  calculateInstallmentFee(principal, period) { }
  calculatePlanFee(baseFee, contractType, carrier) { }
  // ...
}
```

**효과:**
- 계산 로직이 한 곳에 모여 디버깅이 쉬워짐
- 테스트 작성이 용이해짐
- 코드 중복 제거

#### 1.2 상태 관리 단순화
```javascript
// React Query 또는 Zustand 도입
// 복잡한 ref 관리 → 간단한 상태 관리로 전환
```

**효과:**
- 코드 가독성 향상
- 버그 발생 가능성 감소
- 유지보수 용이

### Phase 2: 데이터 흐름 개선 (1주)

#### 2.1 API 레이어 정리
```javascript
// src/api/directStoreApi.js 개선
// - 에러 핸들링 통일
// - 재시도 로직 중앙화
// - 타입 안정성 추가
```

#### 2.2 캐싱 전략 개선
```javascript
// src/utils/priceCache.js 개선
// - React Query의 캐싱 활용
// - 무효화 전략 명확화
```

### Phase 3: 컴포넌트 구조 개선 (1주)

#### 3.1 큰 컴포넌트 분리
```
MobileListTab.js (1,858줄)
  ↓
- MobileListContainer.js (상태 관리)
- MobileListTable.js (UI)
- PriceCalculator.js (가격 계산)
- PlanGroupSelector.js (요금제군 선택)
```

#### 3.2 공통 컴포넌트 추출
- 모델명 정규화 유틸
- 가격 표시 컴포넌트
- 로딩/에러 상태 컴포넌트

### Phase 4: 테스트 및 문서화 (1주)

#### 4.1 단위 테스트 추가
- 계산 엔진 테스트
- API 호출 테스트
- 컴포넌트 테스트

#### 4.2 문서화
- 계산 로직 문서화
- 데이터 흐름 다이어그램
- API 명세서

---

## 📈 예상 효과

### 코드 품질
- **코드 라인 수**: 30-40% 감소 예상
- **복잡도**: 50% 감소 예상
- **테스트 커버리지**: 0% → 70% 이상

### 개발 속도
- **버그 수정 시간**: 70% 단축 예상
- **새 기능 추가 시간**: 50% 단축 예상
- **코드 리뷰 시간**: 60% 단축 예상

### 유지보수성
- **버그 발생 빈도**: 80% 감소 예상
- **코드 이해 시간**: 60% 단축 예상
- **새 개발자 온보딩**: 50% 단축 예상

---

## ⚠️ 재설계를 고려해야 하는 경우

다음 조건이 모두 충족되면 재설계를 고려할 수 있습니다:

1. ❌ 현재 코드가 너무 복잡해서 이해하기 어려움
2. ❌ 기존 기능이 제대로 작동하지 않음
3. ❌ 시간적 여유가 충분함 (2-3개월)
4. ❌ 모든 기능을 다시 구현할 수 있는 리소스가 있음

**하지만 현재 상황:**
- ✅ 90% 기능이 작동 중
- ✅ 핵심 로직은 이해 가능
- ⚠️ 시간이 제한적
- ⚠️ 빠른 완성이 필요

→ **리팩토링이 더 적합합니다**

---

## 🚀 실행 계획

### 즉시 시작 가능 (이번 주)
1. 계산 엔진 분리 시작
2. 가장 복잡한 부분부터 리팩토링
3. 점진적으로 개선

### 단기 목표 (1개월)
- Phase 1-2 완료
- 주요 버그 해결
- 코드 품질 개선

### 중기 목표 (2-3개월)
- Phase 3-4 완료
- 완전한 리팩토링 완성
- 테스트 커버리지 확보

---

## 💡 결론

**권장 사항: 단계적 리팩토링**

1. ✅ **현재 코드 기반으로 개선**: 90% 완성된 기능을 유지
2. ✅ **점진적 개선**: 위험 최소화하면서 단계적으로 개선
3. ✅ **빠른 완성**: 재설계보다 훨씬 빠르게 완성 가능
4. ✅ **만족도 향상**: 코드 품질 개선으로 만족도 향상

**재설계는 다음 경우에만 고려:**
- 현재 코드가 완전히 작동하지 않을 때
- 시간적 여유가 충분할 때
- 모든 기능을 다시 구현할 수 있을 때

---

## 📝 다음 단계

1. **이 제안서 검토**
2. **리팩토링 범위 결정** (전체 vs 부분)
3. **우선순위 결정** (어떤 부분부터 시작할지)
4. **일정 수립** (각 Phase별 일정)

**질문이나 추가 논의가 필요하시면 알려주세요!**

